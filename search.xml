<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HDU5008详解_后缀数组_二分_RMQ_算法日常[17/100]]]></title>
    <url>%2F2019%2F08%2F22%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-17-100%2F</url>
    <content type="text"><![CDATA[HDU5008题目链接VJ上面hdu上面 题意给一个串，q次查询里面第k大的字串，并且要求输出这个串最早出现的位置的左右下标值 题解Tips:看不懂题解的话可以看题解下面的题解小细节(之所以在前面提示是因为小编经常看到一个东西自己想了半天，然后发现后面竟然有解释…所以感觉有点浪费时间，所以自己的博文应该防止自己陷入同样的坑) 解法一 无RMQ O(case*q*(log_(n)+n))考虑找到第k小的子串，直接拿原串先构造后缀数组，统计一下第i个后缀有多少个不同的前缀num[i]（也就是在原串中有多少个不重复的子串），按sa排序后，这些连续出现的子串的字典序也是相同的，那么对num[i]求前缀和后就可以去二分一个位置，找到字典序第k小的子串出现的位置pos了(到这里解法二也要用)。这里找到的位置不一定是最靠左的(不理解可以看下面的题解分析)，所以还要在原串中找一下最左的位置，其实到了这里，直接向后，暴力遍历后面排名的串(不理解可以看下面的题解分析)，若串的最长的连续的height[i]&gt;=目标子串长度，则维护min(L,l)就可以直接得到最小的答案 解法二 RMQ O(case(n*log_(n)+q*log_(n)))当然解法一在极限数组（例如10W个a）很可能会TLE的，所以我们来看更快的方法，以应对更高的要求，把平时的节俭(抠门)习惯在计算机上面发挥到极致 先像解法一前面部分一样确定了当前的位置pos，我们要做的就是在pos后面找个R，使得[pos,R]这个区间的height的最小值&gt;=目标子串的长度，那么找R可以直接在[POS,n]中二分，由于我们的height数组并不是有序的，所以我们不能使用lower_bound,但是要应对多次询问，我们不能像解法一一样暴力了，所以可以使用RMQ，在case开始的时候用n*log_(n)进行预处理，然后在多次查询中享受O(1)带来的极致体验(节俭的生活就是如此地惬意),最后我们在[pos,R]区间再RMQ一下就得到最后的答案了。注意这里求区间的RMQ和求答案的RMQ是查询的两个数组，要分别初始化… 题解细节精讲QAQ1: 为什么后面只要找pos后的后缀中的前缀，不用往前找？而且为什么不同的串是那样求出来的？A: 首先是关于一个字符串有多少不同子串的问题，串由小到大排起序来应该是按照sa[i]的顺序排出来的产生的。 比如abbacd，排序出来的后缀是这样的rank值i—-对应的后缀sa[i] 1—-abbacd 第一个串产生的6个前缀都是新的子串(a,ab,abb……) 2—-acd 第二个串除了和上一个串的相同的前缀a(长度为1) 3-1=2 产生了2个子串 3—-bacd 4-0=4 4—-bbacd 5-1=4 5—-cd 2－0=0 6—-d 1－0=0 所以所有不同的前缀应该是(len-sa[i])-height[i]的和，即后缀串长(总串长减后缀起始位置)减去与上一个串的最长公共前缀，然后求和。如果你不了解height数组—-&gt;建议看看学习后缀数组的小建议 然后我们可以观察到字串是按照排名过来的a,ab,abb,abba,abbac,abbacd,ac,acd,b,ba,…… 并且也可以观察到第k大的不同的串如果在多个位置出现，那么一定是在后面的串中出现，比如k=3,即abb只能在后面的串出现(在abba，abbac,abbacd中出现)—&gt;所以只要在后面查找主要原因是所有的不同的串都是每个后缀的前缀 Q2：为什么我们找到的第一个不是最靠左的呢？A:这里可以举一个反例就解决了，而且其实我们在题解二也举了这个例子(10w个a),我们这里为了分析方便就举例给的串是aaa，那么排名rank 对应的后缀串1 a(rank[1]=2,即是后缀2)2 aa3 aaa因此我们就可以看到第一个找到的a不是位置上最左边的，反而是最右边的 AC代码提交都是G++ 解法一123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100010;typedef long long LL;int sa[maxn],height[maxn],rank[maxn],t[maxn],t2[maxn],c[maxn];int n;char str[maxn];int q;LL sum[maxn];void build_sa(int m,int n)&#123; int *x=t,*y=t2; for(int i=0;i&lt;m;i++)c[i]=0; for(int i=0;i&lt;n;i++)c[x[i]=str[i]]++; for(int i=1;i&lt;m;i++)c[i]+=c[i-1]; for(int i=n-1;i&gt;=0;i--)sa[--c[x[i]]]=i; for(int k=1;k&lt;=n;k&lt;&lt;=1)&#123; int p=0; for(int i=n-k;i&lt;n;i++)y[p++]=i; for(int i=0;i&lt;n;i++)if(sa[i]&gt;=k)y[p++]=sa[i]-k; for(int i=0;i&lt;m;i++)c[i]=0; for(int i=0;i&lt;n;i++)c[x[y[i]]]++; for(int i=1;i&lt;m;i++)c[i]+=c[i-1]; for(int i=n-1;i&gt;=0;i--)sa[--c[x[y[i]]]]=y[i]; swap(x,y); x[sa[0]]=0;p=1; for(int i=1;i&lt;n;i++) x[sa[i]]=(y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?p-1:p++); if(p&gt;=n)break; m=p; &#125;&#125;void getheight(int n)&#123; int k=0; for(int i=1;i&lt;=n;i++)::rank[sa[i]]=i; for(int i=0;i&lt;n;i++)&#123; if(k)k--; int j=sa[::rank[i]-1]; while(str[i+k]==str[j+k])k++; height[::rank[i]]=k; &#125;&#125;void process()&#123; memset(sum,0,sizeof(sum)); sum[1]=n-sa[1]; for(int i=2;i&lt;=n;i++) sum[i]=sum[i-1]+n-sa[i]-height[i];&#125;void solve()&#123; scanf("%d",&amp;q); LL l=0,r=0; process(); while(q--)&#123; LL v; scanf("%lld",&amp;v); LL k=(l^r^v)+1; /*获取有第k排名的不同字符的起始位置(sum见process函数)*/ int pos=lower_bound(sum+1,sum+1+n,k)-sum; /*因为每个串都是 后缀 所以sum[pos]-(k-1)就能得到第k个起始的后缀长度！ 然后用n减去,就是k起始的位置！ (字符串下标从0开始,可以用k=1,来模拟理解一遍) */ LL tl=sa[pos],tr=n-(sum[pos]-k+1); l=tl,r=tr; int len=tr-tl+1; while(pos+1&lt;=n&amp;&amp;height[pos+1]&gt;=len)&#123; pos++; tl=sa[pos],tr=tl+len-1; l=min(l,tl),r=min(r,tr); &#125; l++,r++; if(pos&gt;=n+1)l=r=0; cout&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;endl; &#125;&#125;int main()&#123; while(scanf("%s",str)!=EOF)&#123; n=strlen(str); build_sa(123,n+1); getheight(n); solve(); &#125; return 0;&#125; 解法二123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=205000;char str[maxn];int belong[maxn];int s[maxn],rs[maxn];int sa[maxn],t[maxn],t2[maxn],c[maxn];int n,m,tt;int rank[maxn],height[maxn];int d[2][maxn][50];int LOG[maxn];ll num[maxn];int len,l;inline int idx(char c)&#123; return c-'a'+1; &#125;inline char fdx(int x)&#123; return char(x-1+'a'); &#125;void calheight(int n)&#123; int i,k=0; for (i=0; i&lt;=n; i++) ::rank[sa[i]]=i; for (i=0; i&lt;n; i++)&#123; if (k) k--; int j=sa[::rank[i]-1]; while(s[i+k]==s[j+k]) k++; height[::rank[i]]=k; &#125;&#125;void da(int m,int n)&#123; n++; int i,*x=t,*y=t2; for (int i=0; i&lt;m; i++) c[i]=0; for (int i=0; i&lt;n; i++) c[x[i]=s[i]]++; for (int i=1; i&lt;m; i++) c[i]+=c[i-1]; for (int i=n-1; i&gt;=0; i--) sa[--c[x[i]]]=i; for (int k=1; k&lt;=n; k&lt;&lt;=1)&#123; int p=0; for (i=n-k; i&lt;n; i++) y[p++]=i; for (i=0; i&lt;n; i++) if (sa[i]&gt;=k) y[p++]=sa[i]-k; for (i=0; i&lt;m; i++) c[i]=0; for (i=0; i&lt;n; i++) c[x[y[i]]]++; for (i=1; i&lt;m; i++) c[i]+=c[i-1]; for (i=n-1; i&gt;=0; i--) sa[--c[x[y[i]]]] = y[i]; swap(x,y); p=1; x[sa[0]]=0; for (i=1; i&lt;n; i++) x[sa[i]]=(y[sa[i-1]]==y[sa[i]] &amp;&amp; y[sa[i-1]+k]==y[sa[i]+k])? p-1 : p++; if (p&gt;=n) break; m=p; &#125;&#125;int RMQ_init(int x,int A[])&#123; for(int i=1; i&lt;=n; i++) d[x][i][0]=A[i]; for (int j=1; (1&lt;&lt;j)&lt;=n; j++) for (int i=1; i+(1&lt;&lt;j)-1&lt;=n; i++) d[x][i][j]=min(d[x][i][j-1],d[x][i+(1&lt;&lt;(j-1))][j-1]); return 0;&#125;int RMQ(int x,int L,int R)&#123; int k=LOG[R-L+1]; return min(d[x][L][k],d[x][R-(1&lt;&lt;k)+1][k]);&#125;int main()&#123; int k=0; for (int i=0; i&lt;105000; i++)&#123; while((1&lt;&lt;(k+1))&lt;=i) k++; LOG[i]=k; &#125; while(~scanf("%s",str))&#123; int l=strlen(str); for(int i=0; i&lt;l; i++) s[i]=idx(str[i]); n=l; s[n]=0; da(33,n); calheight(n); for (int i=0; i&lt;=n; i++) num[i]=n-sa[i]; for (int i=1; i&lt;=n; i++) num[i]-=height[i]; for (int i=1; i&lt;=n; i++) num[i]+=num[i-1]; ll tot=num[n]; scanf("%d",&amp;m); ll la=0,lb=0; ll k; /*d[0]存着height的rmq,d[1]存着sa的rmq*/ RMQ_init(0,height); RMQ_init(1,sa); while(m--)&#123; scanf("%lld",&amp;k); k=(k^la^lb)+1; if (k&gt;=1 &amp;&amp; k&lt;=tot)&#123; int pos=lower_bound(num+1,num+1+n,k)-num; /*这个len求得很精致,k-(pos-1)位置起始的不同串的个数, 这样就能得到k结束位置距离height结束位置的串长，加上height就是正好len*/ int len=k-num[pos-1]+height[pos]; int l=pos+1,r=n; int mid; int L=pos,R; /*二分右端点使得右边的最需最长公共字串是我们的k长串*/ while(l&lt;r)&#123; mid=(l+r)&gt;&gt;1; if (RMQ(0,pos+1,mid)&gt;=len) l=mid+1; else r=mid; &#125; /*因为上面二分是mid+1,所以这里需要保险一下*/ if (RMQ(0,pos+1,l)&gt;=len) R=l; else R=l-1; /*所有地方求最小的sa*/ la=RMQ(1,L,R); lb=la+len-1;la++;lb++; printf("%lld %lld\n",la,lb); &#125; else la=lb=0,puts("0 0"); &#125; &#125; return 0;&#125; 参考:http://www.voidcn.com/article/p-xboamjdx-bg.htmlhttps://www.cnblogs.com/chanme/p/4000976.html 每天一句叨叨从明天起，做一个幸福的人(每天只玩半个小时的手机,让自己要么大屏高效,要么认真体验生活) 喂马、劈柴，周游世界 从明天起，关心粮食和蔬菜 我有一所房子，面朝大海，春暖花开 从明天起，和每一个亲人通信 告诉他们我的幸福 那幸福的闪电告诉我的 我将告诉每一个人 给每一条河每一座山取一个温暖的名字 陌生人，我也为你祝福 愿你有一个灿烂的前程 愿你有情人终成眷属 愿你在尘世获得幸福 我只愿面朝大海，春暖花开]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>后缀数组</tag>
        <tag>狼胆带你每天头铁一题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组基础题poj1743详解_算法日常[16/100]]]></title>
    <url>%2F2019%2F08%2F21%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-16-100%2F</url>
    <content type="text"><![CDATA[POJ1743题目链接POJ上面 VJ上面 题意给定一个字符串，求最长重复子串，这两个子串不能重叠 解题思路 由于配置不是简单的匹配，有升降调的处理，但是我们无法确定升降的幅度，所以我们首先对输入的数组进行差值处理 可以发现同一个旋律的区段，它们的差值数组是相等的 因为之前我们处理成了差值，所以我们内卷了一个值，我们的差值相当于左右两个值，所以4个值代表着5个值 所以只要找到最长相同串长的长度不小于4的差值区段即可 由于需要求出最长的长度，考虑二分后验证可行性，二分区段的长度x，对差值数组求一遍后缀数组，将最长公共前缀大于等于x的划分成一组，如果存在一组的sa差值大于等于x+1(详见下面的重点解释)，那么就表示x长度的差值数组能够被找到。二分结束即可得到答案。 没学后缀数组？出门左转给你后缀数组学习合集 思路重点为什么c+1,ans+1二分检查的时候，最长公共前缀是x,sa差值却要大于x+1: 因为之前我们处理成了差值，所以我们内卷了一个值，我们的差值相当于左右两个值，所以4个值代表着5个值.所以最长公共字串只要在4的时候就相当于5,然后sa的差值还是要相间隔5才行==&gt;这样真实的5个值也才是真的间隔5个值，所以同理答案也就是c+1(ans+1) 比如:121 2 3 4 5 6 7 8 9 10 1 1 1 1 &apos; 1 1 1 1 中间的&#39;也是1，但是代表的5,6，所以如果从这里开始和前面的4个1构成相同串的话，然后就重叠了一个，所以必须从&#39;后面1开始 我看了别的几个博主对于这题的分析没有谈及，这里，还有些代码没有考虑这里也能AC，说明数据都去卡时间了，没有卡下面这个特例:1291 2 3 4 5 6 7 8 9 为什么da函数的n值要加1而getheight函数不用da要加一个位置的字符,让它比所有的字符都小，所以这个字符起始的后缀是其本身，其排名为0(rank[n]=0,sa[0]=n)然而calheight却不要…因为calheight直接从rank值为1(rank为0的地方是添加的最小字符)的地方记到n，根本不会用到sa[0](排名为0的后缀)，重点还有for中用的是&lt;=..所以只要使用n. for(i=1;i&lt;=n;i++) ::rank[sa[i]]=i; height分组为什么直接遍历下去分就好，不用吧height值相同的放在一起 AC代码1(推荐)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const ll mod=1000000007;const int inf = 0x3f3f3f3f;const int maxn = 20010;int sa[maxn],rank[maxn],height[maxn];int n;int str[maxn];int wa[maxn],wb[maxn],wv[maxn],ws[maxn];int cmp(int *r,int a,int b,int l)&#123;return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;void da(int *r,int *sa,int n,int m)&#123; int i,j,p,*x=wa,*y=wb,*t; for(i=0;i&lt;m;i++) ::ws[i]=0; for(i=0;i&lt;n;i++) ::ws[x[i]=r[i]]++; for(i=1;i&lt;m;i++) ::ws[i]+=::ws[i-1]; for(i=n-1;i&gt;=0;i--) sa[--::ws[x[i]]]=i; for(j=1,p=1;p&lt;n;j*=2,m=p)&#123; for(p=0,i=n-j;i&lt;n;i++) y[p++]=i; for(i=0;i&lt;n;i++) if(sa[i]&gt;=j) y[p++]=sa[i]-j; for(i=0;i&lt;n;i++) wv[i]=x[y[i]]; for(i=0;i&lt;m;i++) ::ws[i]=0; for(i=0;i&lt;n;i++) ::ws[wv[i]]++; for(i=1;i&lt;m;i++) ::ws[i]+=::ws[i-1]; for(i=n-1;i&gt;=0;i--) sa[--::ws[wv[i]]]=y[i]; for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;n;i++) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; &#125; return;&#125;/*r为字符串数组,sa是后缀数组,n为字符串长度*/void calheight(int *r,int *sa,int n)&#123; int i,j,k=0; /*用sa[]得到rank[]*/ for(i=1;i&lt;=n;i++) ::rank[sa[i]]=i; /*j就是后缀i的前一名的后缀位置,然后如果前一个串之间有k,那么就从k--起步*/ for(i=0;i&lt;n;height[::rank[i++]]=k) for(k?k--:0,j=sa[::rank[i]-1];r[i+k]==r[j+k];k++); return;&#125;/*为什么check里面的间隔是c+1: 因为之前我们处理成了差值，所以我们内卷了一个值， 我们的差值相当于左右两个值，所以4个值代表着5个值 所以最长公共字串只要在4的时候就相当于5,然后sa的 差值还是要相间隔5才行==&gt;这样真实的5个值也才是真的 间隔5个值，所以同理答案也就是c+1*/bool check(int c)&#123; int Max=sa[1],Min=sa[1]; for(int i=2;i&lt;=n;i++)&#123; /*这里的for是枚举的排名值，而height就是相邻排名的 最长公共前缀,所以直接分组就行了*/ if(height[i]&gt;=c) Max=max(Max,sa[i]),Min=min(Min,sa[i]); else Max=sa[i],Min=sa[i]; if(Max-Min&gt;=c+1) return true; &#125; return false;&#125;int main()&#123; ios::sync_with_stdio(false);cin.tie(0); while(cin&gt;&gt;n)&#123; if(n==0) break; for(int i=0;i&lt;n;i++) cin&gt;&gt;str[i]; for(int i=0;i&lt;n-1;i++) str[i]=str[i+1]-str[i]+90; /*因为转变差值了，所以少一个值*/ str[n-1]=0;n--; // for(int i=0;i&lt;=n-1;i++) cout&lt;&lt;str[i]&lt;&lt;" "; cout&lt;&lt;endl; /*da要加一个位置的字符,让它比所有的字符都小 然而calheight却不要...因为calheight直接从rank只为1(rank为0的地方是添加的最小字符) 的地方记到n(用的是&lt;=)..所以只要使用n.不需要n+1*/ da(str,sa,n+1,178); calheight(str,sa,n); int l=0,r=n,ans=0; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) l=mid+1,ans=mid; else r=mid-1; &#125; if(ans&lt;4) cout&lt;&lt;0&lt;&lt;endl; else cout&lt;&lt;ans+1&lt;&lt;endl; &#125; return 0;&#125; AC代码2(RMQ版)此AC代码为2019年8月22日做HDU5008(因为那题最好还是用RMQ的后缀数组题)的时候发现的不过这题用RMQ比较鸡肋，为什么? 请看下面的代码头部注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/*今天在第二次研究hdu5008的时候,发现好多题目都是没有用rmq的但是总有大佬不满足于暴力裸sa就完事,于是都加了rmq,然后我有点看不懂,就去逛oi-wiki,发现居然有不重叠重复两次的串也可以用rmq，那不就是我昨天做的poj1743的更优做法吗？是的，然后就在网上搜到了O(test*(nlogn+logn))的做法！之前的写法是O(test*nlogn)的但是实测发现RMQ版的反而还慢了100多ms!好像是因为他的check还是O(n)而非O(1)的因为这里的check是我们自己去寻找一个左右区间，而非输入直接给我们左右区间，所以这里的寻找的复杂度是O(n),所以RMQ无济于补而且RMQ是nlog(n)的预处理... 所以当然会慢啊 ---&gt; 所以在更大一个量级的询问的时候再用比较好----------------上面为简单分析-----下面为用途---------------这里有rmq求排名区间内最远的sa位置差值*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=21000;int dp1[maxn][20],dp2[maxn][20];int mm[maxn];int str[maxn],tmp[maxn];int wa[maxn],wb[maxn],wv[maxn],ws[maxn];int sa[maxn],ranks[maxn],height[maxn];inline bool cmp(int *r,int a,int b,int l)&#123; return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;void da(int *r,int n,int m)&#123; int i,j,p,*x=wa,*y=wb,*t; for(i=0;i&lt;m;i++) ws[i]=0; for(i=0;i&lt;n;i++) ws[x[i]=r[i]]++; for(i=1;i&lt;m;i++) ws[i]+=ws[i-1]; for(i=n-1;i&gt;=0;i--) sa[--ws[x[i]]]=i; for(j=1,p=1;p&lt;n;j*=2,m=p)&#123; for(p=0,i=n-j;i&lt;n;i++) y[p++]=i; for(i=0;i&lt;n;i++) if(sa[i]&gt;=j) y[p++]=sa[i]-j; for(i=0;i&lt;n;i++) wv[i]=x[y[i]]; for(i=0;i&lt;m;i++) ws[i]=0; for(i=0;i&lt;n;i++) ws[wv[i]]++; for(i=1;i&lt;m;i++) ws[i]+=ws[i-1]; for(i=n-1;i&gt;=0;i--) sa[--ws[wv[i]]]=y[i]; for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;n;i++) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; &#125; for(i=0;i&lt;n;i++) ranks[sa[i]]=i; int k=0; for(i=0;i&lt;n-1;i++)&#123; if(k) k--; j=sa[ranks[i]-1]; while(r[i+k]==r[j+k]) k++; height[ranks[i]]=k; &#125; return;&#125;void initRMQ(int n)&#123; /*mm其实是log,这里赋值为-1是为了后面mm[1]=0,也就是2^0=1*/ mm[0]=-1; for(int i=1;i&lt;=n;i++)&#123; /*(i&amp;(i-1))==0表示n==0或者是2的倍数*/ mm[i]=((i&amp;(i-1))==0)?mm[i-1]+1:mm[i-1]; /*这里是预处理sa的rmq*/ dp1[i][0]=dp2[i][0]=sa[i]; &#125; for(int j=1;j&lt;=mm[n];j++) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++)&#123; dp1[i][j]=max(dp1[i][j-1],dp1[i+(1&lt;&lt;(j-1))][j-1]); dp2[i][j]=min(dp2[i][j-1],dp2[i+(1&lt;&lt;(j-1))][j-1]); &#125;&#125;int rmq(int x,int y)&#123; int k=mm[y-x+1]; return max(dp1[x][k],dp1[y-(1&lt;&lt;k)+1][k])-min(dp2[x][k],dp2[y-(1&lt;&lt;k)+1][k]);&#125;bool check(int len,int N)&#123; int s=1,e=1; while(e&lt;N)&#123; if(height[e+1]&gt;=len-1) e++; else&#123; if(rmq(s,e)&gt;=len) return true; s=++e; &#125; &#125; return false;&#125;int main()&#123; int N; while(scanf("%d",&amp;N)&amp;&amp;N)&#123; for(int i=0;i&lt;N;i++) scanf("%d",&amp;str[i]); for(int i=0;i&lt;N-1;i++) tmp[i]=str[i+1]-str[i]+90; tmp[N-1]=0; /*这里没有N--,所以直接使用的N,而RMQ使用的N-1,height封锁掉N号位置*/ da(tmp,N,200); initRMQ(N-1); height[N]=-1; int left=1,right=N/2; while(left&lt;=right)&#123; int mid=(left+right)/2; if(check(mid,N)) left=mid+1; else right=mid-1; &#125; if(right&lt;5) printf("0\n"); else printf("%d\n",right); &#125; return 0;&#125; 每天一句叨叨我不管你是什么垃圾，我只看结果 要达到结果，你应该知道怎么做 I know you have the urge to give up! But you must keep faith! You do make a difference!]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>后缀数组</tag>
        <tag>狼胆带你每天头铁一题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组学习路径以及后缀数组板子推送_算法日常[15/100]]]></title>
    <url>%2F2019%2F08%2F20%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-15-100%2F</url>
    <content type="text"><![CDATA[学习后缀数组的小建议时刻分析数组含义学习后缀数组的核心是时刻分析这到底是排名i的后缀位置还是后缀i的排名值 一般的SA[i]代表着排名第i的后缀位置从哪里开始 然后Rank[i]代表着后缀i的排名 后缀i就从下标i开始一直到字符串末尾的那个后缀s.substr(i) 演算脑子的内存是有限的，所以有时候想不出来，尽量使用草稿纸加以演算，这样才能更高效地学习后缀数组(否则像小编这种脑子不怎么好使的，不演算之前看了一天都没看懂某两行代码) 后缀数组学习材料当然小编也是一个初学者，所以暂时只能说出一些学习的小建议，让我写出来还是不太现实，不过小编可以给你们推荐一些学习的资料 论文下面这篇论文基本上网罗了后缀数组的方方面面，而且写得也十分详细，所以十分推荐后缀数组论文分享 学习网址也挺详细的 OI-wiki上的介绍 题目链接当然是先刷一手kuangbin专题 板子整理推送(LTS)1234567891011121314151617181920212223242526272829303132333435363738394041424344/*板子声明 :1. r从0开始,而非像oi-wiki中的从1开始2. [build使用 n + 1 , calheight 使用 n ](https://www.wolfdan.cn/2019/08/21/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-16-100/)*/int sa[maxn],wa[maxn],wb[maxn],wv[maxn],ws[maxn];/*LCP:最长公共字串部分*/int rank[maxn],height[maxn];/*r为字符串数组,sa是后缀数组,n为字符串长度,m为字符种类数*/void da(int *r,int *sa,int n,int m)&#123; int i,j,p,*x=wa,*y=wb,*t; for(i=0;i&lt;m;i++) ws[i]=0; for(i=0;i&lt;n;i++) ws[x[i]=r[i]]++; for(i=1;i&lt;m;i++) ws[i]+=ws[i-1]; for(i=n-1;i&gt;=0;i--) sa[--ws[x[i]]]=i; for(j=1,p=1;p&lt;n;j*=2,m=p)&#123; for(p=0,i=n-j;i&lt;n;i++) y[p++]=i; for(i=0;i&lt;n;i++) if(sa[i]&gt;=j) y[p++]=sa[i]-j; /*提取第一关键字*/ for(i=0;i&lt;n;i++) wv[i]=x[y[i]]; for(i=0;i&lt;m;i++) ws[i]=0; for(i=0;i&lt;n;i++) ws[wv[i]]++; for(i=1;i&lt;m;i++) ws[i]+=ws[i-1]; for(i=n-1;i&gt;=0;i--) sa[--ws[wv[i]]]=y[i]; for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;n;i++) x[sa[i]]=(y[sa[i-1]]==y[sa[i]]&amp;&amp;r[sa[i-1]+j]==r[sa[i]+j])?p-1:p++; &#125; return;&#125;/*r为字符串数组,sa是后缀数组,n为字符串长度*/void calheight(int *r,int *sa,int n)&#123; int i,j,k=0; /*用sa[]得到rank[]*/ for(i=1;i&lt;=n;i++) rank[sa[i]]=i; /*j就是后缀i的前一名的后缀位置,然后如果前一个串之间有k,那么就从k--起步*/ for(i=0;i&lt;n;height[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];r[i+k]==r[j+k];k++); return;&#125; 每天一句叨叨愿回首岁月之时，你不会后悔]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019杭电多校9题解_算法日常[14/100]]]></title>
    <url>%2F2019%2F08%2F19%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-14-100%2F</url>
    <content type="text"><![CDATA[jls题解因为有些 ddl 要肝.. 把视频题解咕了..大家凑合着看文字题解吧 今年又是 Rikka 和 Yuta 在多校上秀恩爱的一年（说不定也是最后一年了.. sad 1001 Rikka with Quicksort难度：medium 考察了大家对快速排序时间复杂度推导的熟悉程度（当然我是打表推式子的） 如果打表的话可以考虑下面这个式子，它是计算在 $m$ 处增加一个 $1$ 对答案的贡献。 \begin{aligned} h_m(i) &= 0 & i < m\\ h_m(i) &= 1 & i =m \\ h_m(i) &= \frac{1}{i}\sum_{j=1}^{i}\left( h_m(j-1) + h_m(i-j)\right) & i > m \end{aligned}打表之后可以知道 $h_m(m)=1,h_m(n)=\frac{2(n+1)}{(m+1)(m+2)} (n &gt; m)$。应该归纳一下就可以直接证明。所以把对应的贡献求和之后可以得到答案就是： 2(n+1)H(n)-4n-\frac{2(m+2)H(m+1)-4(m+1)-m)(n+1)}{m+2}其中 $H(n)$ 表示调和级数。因为模数确定，可以用分段打表的策略来求调和级数的具体值：即把 $H(kS)$ 的值给打入程序中，这样每一次只需要计算 $kS+1$ 到 $n$ 的逆元就行了。 1002 Rikka with Cake难度：medium easy 用欧拉（欧拉欧拉欧拉）公式 $V-E+F = 2$ 来算蛋糕的块数。 首先考虑点数 $V$，蛋糕的四个角以及射线的端点贡献了 $n+4$ 个顶点（$K$ 太丑了我们用 $n$ 表示射线数），射线和四条边的交点共有 $n$ 个，射线之间的交点有 $c$ 个，因此点数是 $2n+4+c$。 接着考虑边数，对于每一条射线，假设别的射线和他的交点有 $c_i$ 个，那么这条射线被切成了 $c_i+1$ 段，因此所有射线的边数对应的是 $2c+n$（因为每一个交点被用了两次）。同时因为四条边一共和射线交了 $n$ 次，所以四条边界上共有 $4+n$ 条边，所以 $E=2c+2n+4$。 因此总的区域数为 $F=2+c$，因为要去掉最外面的无穷区域，所以答案就是 $1+c$。于是问题就变成了求交点个数 $c$。这是一个经典的问题，分四个方向讨论一下离散化用树状数组求就行。时间复杂度 $O(n \log n)$ 1003 Rikka with Mista难度：medium-easy 在，为什么迫害米斯达？ 可以对每一位分开来计算，和最大不超过 $10^{10}$，因此最多只有 $10$ 位。只要对每一位算出它在多少种情况下是 $4$，全部加起来就可以了。 $40$ 的数据范围指明了可以用 meet in middle 来做，可以先用 $O(2^{\frac{n}{2}})$ 的复杂度分别把前 $\frac{n}{2}$ 个数和后 $\frac{n}{2}$ 个数的所有和求出来，分别存在数组 $A$ 和 $B$ 中，那么对于第 $i$ 位来说，答案就是有多少个数对 $i,j$ 满足 $(A_i+B_j) \text{ mod } 10^{i+1} \in [4 \times 10^i,5 \times 10^i)$。这个问题只要对 $A$ 和 $B$ 按照 $x \text{ mod } 10^{i+1}$ 排序后用 two pointer 扫就可以了。 对每一位分开来做时间复杂度是 $O(2^{\frac{n}{2}}n \log w_i)$，瓶颈在堆每一位排序。不难发现对每一位排序可以用一次归并排序来实现，这样就能省下一个 $\log$，时间复杂度是 $O(2^{\frac{n}{2}}n)$。 1004 Rikka with Geometric Sequence难度：medium 首先长度是 $1$ 的答案就是 $n$，长度为 $2$ 的答案就是 $\frac{n(n-1)}{2}$。我们考虑长度大于等于 $3$ 的情况。 假设公比的最简分数表示是 $\frac{a}{b}(a &gt; b,\gcd(a,b) = 1)$，等比数列长度是 $k$，那么 $x$ 能作为这样的一个等比数列的最后一项的条件就是 $a^{k-1}|x$，因此这样的等比数列一共有 $\left \lfloor \frac{n}{a^{k-1}} \right \rfloor$。而枚举了 $a$，满足小于 $a$ 且与 $a$ 互质的 $b$ 的数量是 $\varphi(a)$，其中 $\varphi$ 表示欧拉函数。 因此我们可以枚举 $a$ 然后对答案求和： \sum_{a=2}^n \varphi(a)\left \lfloor \frac{n}{a^{k-1}} \right \rfloor显然有贡献的 $a$ 必须小于等于 $\sqrt[k-1] n$，因此当 $k&gt;3$ 的时候就能暴力枚举 $a$ 统计答案了，问题就在于 $k=3$ 的时候的处理。这个时候可以证明 $\left \lfloor \frac{n}{a^2} \right \rfloor$ 的取值最多只有 $\sqrt[3] n$ 种：当 $a \leq \sqrt[3]n$ 的时候，只有 $\sqrt[3] n$ 种值，当 $a &gt; \sqrt[3]n$ 的时候，这个商小于等于 $\sqrt[3]n$，因此最多也就只有 $\sqrt[3]n$ 种答案。 所以相当于把 $a$ 的取值分成了 $\sqrt[3]n$ 段，对每一段分别用杜教筛求 $\varphi(n)$ 的前缀和就可以了。这样的时间复杂度比较迷幻，我展开一层积分一下可以得到时间复杂度是 $O(n^{\frac{5}{12}})$。不确定最终的时间复杂度是什么。但是如果预处理前 $5 \times 10^7$ 项的欧拉函数，可以非常轻松的跑过去。 1005 Rikka with Game难度：easy 签到题，随便脑补一下就能知道答案。首先如果第一位是 $a-x$ 的话，先手会直接结束游戏：如果先手增加第一位，那么后手直接结束游戏；如果先手不增加第一位，那么后手增加第一位，此时如果先手还不结束游戏，后手直接选择结束。这三种情况下游戏结束的字典序都要比游戏开始的时候字典序大。 如果第一位是 $y$，那么不管先手还是后手都不会选择修改它：如果先手修改它，后手直接结束游戏；如果后手修改它，先手再选择同一位，然后在下一次轮到先手的时候结束。这样对于修改 $y$ 的那一方都是亏的。 如果第一位是 $z$，那么先手会选择修改它，之后后手也会选择修改它，然后就回到了第一种情况先手直接结束游戏，因此结果就是第一位变成了 $b$. 在上面三种情况下，只有第二种情况游戏不会再只考虑第一位的情况下结束，这时因为大家都不会动第一位，所以相当于不存在，直接考虑后面的情况就可以。 所以最后的结论就是，找到第一位不是 $y$ 的位，如果它是 $z$，则修改成 $b$，否则不变。 时间复杂度 $O(n)$。 1006 Rikka with Coin难度：easy 首先 $10$ 分的硬币最多只会用一个，如果用了两个，直接替换成一个 $10$ 分一个 $20$ 分一定不亏。 $20$ 分的硬币最多只会用三个，如果用了四个，直接替换成一个 $10$ 分两个 $20$ 分一个 $50$ 分一定不亏。 $50$ 分的硬币最多只会用一个，如果用了两个，直接替换成一个 $50$ 分和一个一元一定不亏。 对于任何一种情况，重复使用上述规则一定会达到一个 $10$ 分硬币最多一个，$20$ 分最多三个，$50$ 分最多一个的情况，不会陷入重复甩锅的死循环。 因此枚举这三种硬币分别用了多少个，然后整百的部分直接用一元硬币填，取最少的答案就行了。 1007 Rikka with Travel难度：medium easy 基础直径练习题。 考虑判断 $(x,y)$ 能不能出现。劼论：任意取树上的一条直径，那么如果 $(x,y)$ 能出现，那么一定存在一种方案使得直径的两端都被使用了。证明很简单：假设存在一个端点没有被使用，那么考虑两条直线的四个端点 $a,b,c,d$，一定可以把一个端点给移动到直径的这个端点上，因为直径是树上最长的路径，因此这次移动一定不会减少路径的长度。 考虑对每一个长度 $x$，求可以满足的最长的 $y$，这样所有小于等于 $y$ 的值也都能被满足。考虑在直径上计算这些值：第一种情况，直径的两端分属不同的路径，那么可以枚举直径的一个端点那条路径在直径上的最后一个点，那么这一条路径的最大长度就是这个点到直径端点的距离加上这个点往直径外的最大延伸长度，另一条路径的最大长度也可以类似地求，其中最大延伸长度可以用一个 $O(n)$ 的 DFS 计算出来。第二种情况是有一条路径就是这条直径，那么另一条路径就是这条直径之外的最长路径长度，这个只要把直径上的点都删了再求一遍直径就行。 总的时间复杂度为 $O(n)$。 1008 Rikka with Stable Marriage难度：medium 稳定婚姻真实一个深刻的模型啊..这题明明很简单但是不知道为什么没人做。 考虑把男生和女生分别放到一棵 trie 树里面，然后考虑最高位：首先肯定是让不同子树的男生女生进行匹配，如果左子树里有一队，右子树里有一队，那么交换他们的伴侣肯定一个更好的选择。而因为左右子树的大小可能不均匀，所以在分开来匹配之后，不妨设左子树有一些男生剩下，右子树有一些女生剩下，这个时候就只能让败者组的他们互相舔舐伤口了。 写成代码很简单，下面是一个简单的伪代码： 123456789101112void match(node_b, node_g, depth) &#123; if (node_b.size == 0 || node_g.size == 0) return; if (depth == -1) &#123; marriage(node_b, node_g); return; &#125; match(node_b.l, node_g.r, depth - 1); match(node_b.r, node_g.l, depth - 1); match(node_b.l, node_g.l, depth - 1); match(node_b.r, node_g.r, depth - 1); node_b.update_size(); node_g.update_size();&#125; 其中 node_b 和 node_g 分别表示男孩和女孩对应的 trie 树节点，depth 表示现在考虑的是哪一层。大致的思想就是暴力递归下去然后贪心的匹配就行了。 因为每递归 $O(\log a_i)$ 层一定会有一对新人产生，所以总的时间复杂度是 $O(n \log a_i)$ 的。 1009 Rikka with Traffic Light难度：medium hard 首先可以发现一定存在一个最优方案，所有绿灯区间长度都大于等于 $T_1$，所有红灯区间长度都大于等于 $T_2$。如果如果小于的话，反正这一段时间也没有办法让人过红绿灯，不如就不变了。接着考虑如果灯在第 $t$ 时刻变成了绿灯，最优解中它会在什么时候变成红灯。（对于红灯变成绿灯的分析类似） 第一种可能性是在 $t+T_1$ 时刻变成红灯，在这种情况下，一定有在 $t$ 之前（包括 $t$） 时刻到达且还没有过马路的人，不然这一段没有人能过马路。 第二种可能性是在 $t+T_1$ 时刻之后，考虑在这段绿灯中最后过马路的那个人 $i$，他会在 $t_i+T_1$ 时刻后通过马路。因此这段绿灯在第 $t_i+T_1$ 时刻结束一定不亏。 我们把所有 $t_i+T_1$ 或者 $t_i+T_2$ (取决于 $i$ 的种类) 作为关键点，设 $f_i$ 为在第 $i$ 个人对应的关键切换成另一种灯时的已经能确定过马路时间的人的总等待时间（不妨假设第 $i$ 个人是第一类人）。注意这儿已经能确定过马路时间的人包括在 $t_i$ 时刻之前到达的第一类人和第 $t_i+T_1$ 时刻之前达到的第二类人 (最开始发现的性质保证了他们都能在 t_i+T_1) 时刻过马路。 考虑转移，首先从 $t_i+T1$ 开始，最优方案可能会进行若干段第一种可能性的转移，接着通过一个第二种可能性的转移直接跳到后面的某一个关键点。因为第一种可能性要求必须要有对应的人在等待，因此第一种转移最多进行 $O(n)$ 次。我们可以枚举第一段转移进行的次数，并求出对应的总等待时间（总等待时间的定义和 $f_i$ 一样）。 最后要处理的就是从枚举的这 $O(n)$ 段到后面的某一个关键点之间的转移，这个把式子列出来之后可以发现用斜率优化就能直接优化到 $O(n)$ 了。 总时间复杂度为 $O(n^2)$。数据造的我想吐。 1010 Rikka with Defensive Line难度：medium hard 我九条可怜最喜欢做的一件事，就是出大几何题，对自以为多开就能 AK 的人说“不”。 过气计算几何选手拼尽全力出的计算几何题..然后根本没人帮我验题..偷偷搞了一个 60 核 server 并行用极角排序验了一下.. 发现这个数据范围的 $O(n^2 \log n)$ 的极角排序并行后两三分钟就跑完了.. 感觉有点牛逼 首先可以发现对于一个凸包来说，如果一个直线和它有交，那么一定在直线的两侧（不严格）都有至少一个凸包上的顶点。因此我们对点集剥 $m$ （因为 $K$ 太丑这儿就用 $m$ 代替了）层凸包（重复求凸包，删除凸包上的点这一过程 $m$ 次），只有这些凸包上的点可能作为防御线的两个点之一，其他点都没有用了。 枚举一个点集中的点，把这个点作为坐标系的原点，那么对于任何一个方案，它小于等于 $m$ 的那一边一定覆盖了 $y$ 轴正半轴或者负半轴中的一个。可以先求所有覆盖了 $y$ 轴正半轴的方案，那么另一边只要对称一下再做一遍就行。同时不妨假设另一个端点在 $x$ 轴正方向，逆方向的情况也只要对称一下就行。 考虑这时哪些点可能作为答案：答案是把 $y$ 轴沿着逆时针防线方向旋转碰到的前 $m$ 个点。同时为了判断这些点是否合法还需要求沿着顺时针方向旋转碰到的前 $m$ 个点。如果把这些点求出来，那么就只要对每一个点看一下这 $2m+1$ 个点（包括原点）里是否有超过 $m$ 个点在这一边就行，这是一个非常基础的 two pointer （注意处理共线的情况）。 问题的关键就是如何求逆时针方向（顺时针方向同理）的前 $m$ 个点。因为现在的点集有特殊性：由 $m$ 个相互嵌套的凸包组成，因此我们考虑只有一个凸包的特殊情况。讨论可以发现，$y$ 轴正半轴和凸包的交点以及原点到凸包的切点把凸包分成了若干段，其中每一段从极角上考虑都是有序的。因此 $m$ 个凸包一共分成了 $O(m)$ 段，用一个多路归并把这些段归并起来就行。求交点可以按照 $x$ 轴排序枚举原点，这样就可以分上下凸壳分别扫过去；求割点可以用旋转卡壳预处理，这两部分总的时间复杂度都是 $O(nm)$ 的。 算上 $m$ 路归并的复杂度 $O(m \log m)$，总的时间复杂度为 $O(nm \log m)$。 1011 Rikka with Segment Tree难度：medium 这个题是一个简单的分形题.. 做法也很传统，就是大力递归下去，难点在于比较麻烦。 我们用 $F(N)$ 表示到线段树的区间长度到 $N$ 为止的求和。那么除了 $1$ 的情况直接结束，其他的线段树都会递归左子树和右子树。如果我们假设左右子树都是从 $1$ 开始重新标号的话，那么左右子树都是递归到 $\frac{N}{2}$ 上下取整的子问题，这一部分用一个记忆化的递归就行。 考虑合并左右子树成 $n$ 的情况，首先所有叶子节点的深度都会增加 $1$，这一部分的贡献是 $\sum_{n=2}^N \sum_{i=1}^n i$，可以直接计算。 最后，因为加上左子树之后，右子树的所有点的编号会对应地发生变化，因此需要再算上对应的贡献。令 $g(n)$ 表示对应区间为 $n$ 的线段树所有叶子节点的深度和，设 $m$ 是最大的整数满足 $2^m \leq n$，那么 $g(n) = nm+2(n-2^m)$。而这一部分的贡献就是： \sum_{n=2}^N \left \lceil \frac{N}{2}\right \rceil g\left(\left \lfloor \frac{n}{2}\right \rfloor\right)推一个式子加上一通预处理，就能 $O(1)$ 计算这个和式了。 如果用 map 来进行记忆化的话，时间复杂度为 $O(\log^2 n)$。 每天一句叨叨 jls真牛逼 自己因为浪，导致今天又没学到什么，继续加油吧 你真的有在拼吗？想一想你3个月后的回想，你会后悔吗]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第17周[17/521]]]></title>
    <url>%2F2019%2F08%2F18%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC17%E5%91%A8-17-521%2F</url>
    <content type="text"><![CDATA[Algorithm虽然比赛很自闭，但仍一直在补牛客杭电多校题目，一起加油 ReviewYour Work Is the Only Thing That MattersIf you cease practicing for a second, if you let your mind get wound too tight or simply allowed to drift elsewhere, you will lose that ability. Your bat will stop connecting with the ball, your batting average will drop and soon enough you yourself will be dropped, first from the majors and then the sport altogether. 是啊，我们只要放松一秒，我们的竞技水平就会急剧下滑，所以我们不能放松，否则就是万丈深渊，输掉曾经所有的努力 TipsC++11使用emplace_back代替push_back这个文章好久好在它的泛用性，你可以使用里面的头文件去做其他的时间测试 Share银联挑战赛复赛A,B题_算法日常[8/100] 10进制矩阵快速幂-狼胆带你每天头铁一题-算法日常[9/100] 折半搜索_算法日常[10/521] 2019牛客多校9E题详解_算法日常[11/100] 2019牛客多校10 B题_算法日常[12/100] 2019牛客第十场F题详解_算法日常[13/100]]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客第十场F题详解_算法日常[13/100]]]></title>
    <url>%2F2019%2F08%2F18%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-13-100%2F</url>
    <content type="text"><![CDATA[2019牛客第十场F题详解题目2019牛客第十场F题详解 题解我的分析请看代码 本来以为发现了更快更简单的做法，结果想写成思路给大家看，然后不断想怎么表述这个算法，想着想着发现这是一个假的超快AC算法，然后大家有兴趣的话可以看我的AC代码二的分析(果然写blog做搬运工也是有收获的) AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define pb push_backusing namespace std;const int maxn=6e5+5;const int N=6e5+3;int a[maxn],b[maxn],cnt[maxn],ans,n,r;vector &lt;int&gt; h[maxn];multiset &lt;int&gt; s;void add(int x)&#123; auto p=s.find(cnt[x]); s.erase(p); cnt[x]++; s.insert(cnt[x]);&#125;void del(int x)&#123; auto p=s.find(cnt[x]); s.erase(p); cnt[x]--; s.insert(cnt[x]);&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; r; for (int i=0;i&lt;n;i++)&#123; cin &gt;&gt; a[i] &gt;&gt; b[i]; /* 统一右移2*r */ a[i]+=r*2; b[i]+=r*2; &#125; for (int i=0;i&lt;n;i++)&#123; /*打a[i]的时候,把a[i]-r,a[i]+r也叠加上a[i]上面的值, 这样就能使得a[i]表示打a[i]能获得的总值*/ h[a[i]-r].pb(b[i]); h[a[i]].pb(b[i]); h[aa[i]+r].pb(b[i]); cnt[b[i]]++; cnt[b[i]-r]++; cnt[b[i]+r]++; &#125; for (int i=r;i&lt;=N-r;i++) s.insert(cnt[i]); for (int i=r;i&lt;=N-r;i++)&#123; /*得到中间打这里能够得到的个数*/ int ret=(int)h[i].size(); /*暂时删除相关的所有列值*/ for (auto x:h[i]) del(x),del(x-r),del(x+r); /*然后得到当下最大的3列值*/ auto p=s.rbegin(); ans=max(ans,ret+(*p)); /*再把列值插回去*/ for (auto x:h[i]) add(x),add(x-r),add(x+r); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; 能更快AC的假算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*直接行列序列化排序的做法,真滴是好想法!*//*2019年8月18日20:26:30 发现这是一个假做法！靠着数据水才过的！因为这里只比较了最大的3个行值，就去比较列值了！因为可能有一种情况就是选第4大行，但是取到的列值更多，这应该是有可能出现的，总之这种做法虽然能过 但是是有可能遗漏情况的假算法！必须要枚举到所有的行*/#include&lt;bits/stdc++.h&gt;using namespace std;const int M =1e5 + 10;int num[M *3];int n , r , ans;int cnt[M * 3];struct node&#123; int x , y; int id; bool operator&lt;(node d)const&#123; return x &gt; d.x; &#125;&#125;a[M] , b[M];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n &gt;&gt;r; for(int i =1;i &lt;= n;i++)&#123; cin &gt;&gt; a[i].x &gt;&gt; a[i].y; a[i].x++; a[i].y++; num[a[i].x]++; &#125; /*枚举每个行坐标,相加从上到下3行的值--&gt;二维降到一维*/ for(int i = 1;i &lt;= 100000;i++)&#123; /*之所以放在最左边是因为i是从最左边开始,免去判断*/ b[i].x = num[i] + num[i +r] + num[i +r +r]; b[i].id = i; &#125; /*行值获利大到小排序*/ sort(b + 1 ,b + 100001); for(int i = 1;i &lt;= 3;i++)&#123; memset(cnt , 0 ,sizeof(cnt)); for(int j = 1;j &lt;= n;j++)&#123; /*除去原来的行(3次行值取max)以外的其他列的值的统计*/ if(a[j].x != b[i].id &amp;&amp; a[j].x != b[i].id +r &amp;&amp; a[j].x != b[i].id +r * 2) cnt[a[j].y]++; &#125; int sum = 0; for(int j = 1; j &lt; M;j++) sum = max( sum , cnt[j] + cnt[j +r] +cnt[j + r + r]); ans = max(ans , sum + b[i].x); &#125; cout &lt;&lt; ans &lt;&lt;endl;&#125; 每天叨叨一句天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>狼胆带你每天头铁一题</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客多校10 B题_算法日常[12/100]]]></title>
    <url>%2F2019%2F08%2F17%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-12-100%2F</url>
    <content type="text"><![CDATA[2019牛客多校10 B题题目2019牛客多校10 B题 题解思路 (详见代码注释) C++由于容易数据溢出，所以必须加限制，否则会造成数据溢出的错误，昨晚WA了两个小时的血的教训 k不会到很大的数据范围(限制在了k&lt;10^12) 然后递归的时候是一样的,最终也是递归到x==1,x==2 是按照题中斐波那契递归回去的，所以不会出错 AC代码写了python版之后去写C++版本的，结果一直WA了整整2个多小时，眼睛痛，所以决定明天早起再看看哪里出错了并给出C++版的AC代码(第二天已经更新) Python3版12345678910111213141516171819202122232425# python3lf = [0, 6, 7]# 一千多项的时候远远超过了10^12+7的for _ in range(1000) : lf.append(lf[-2] + lf[-1]) # if _ == 999: # print(If[-1])def f(x, s) : if x == 1 : return "COFFEE"[s] if x == 2 : return "CHICKEN"[s] if s &gt;= lf[x-2] : return f(x - 1, s - lf[x - 2]) else : return f(x - 2, s)for _ in range(eval(input())) : n, s = map(int, input().split()) s -= 1 # 从s到min(s+10,lf[n]), 用中括号括起来生成列表 r = [f(n, t) for t in range(s, min(s + 10, lf[n]))] print(''.join(r)) C++AC代码1_与题解思路相同的1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=1000000007;ll len[505];string ans;int T,n;ll k;char f(int x,ll k)&#123; if(x==1) return "COFFEE"[k]; if(x==2) return "CHICKEN"[k]; if(k&gt;=len[x-2]) return f(x-1,k-len[x-2]); else return f(x-2,k);&#125;int main()&#123; ios::sync_with_stdio(false);cin.tie(0); len[1] = 6,len[2] = 7; ll mx = 1e13; /*这里最好不要break,否则会造成数组的部分是0值，除非先赋值为mx (当然也可以使用C++AC代码二的特殊提前处理去使用break) 但是可以通过min控制数值大小，以免引发数据溢出错误 可以使用min的原因是，k不会到很大的数据范围 然后递归的时候是一样的,最终也是递归到x==1,x==2 是按照题中斐波那契递归回去的，所以不会出错*/ for(int i=3;i&lt;=500;i++)&#123; len[i] = min(len[i-2]+len[i-1],mx); &#125; for(cin&gt;&gt;T;T--;)&#123; cin&gt;&gt;n&gt;&gt;k; k-=1; ans.clear(); ll tn = min(k+10,len[n]); for(ll i=k;i&lt;tn;i++)&#123; ans += f(n,i); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; C++AC代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod = 1e9 + 7;const int inf = 0x3f3f3f3f;const int maxn = 100000 + 5;ll len[505];string str[3];string dfs(int x, ll a, ll b) &#123; /*substr的第二个参数是长度*/ if(x &lt;= 2) return str[x].substr(a-1, b); if(a+b-1 &lt;= len[x-2]) return dfs(x-2, a, b); if(a &gt; len[x-2]) return dfs(x-1, a-len[x-2], b); /*分段后..x-1可以直接从1开始了*/ return dfs(x-2, a, len[x-2]-a+1) + dfs(x-1, 1, b-(len[x-2]-a+1));&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); str[1] = "COFFEE"; str[2] = "CHICKEN"; len[1] = 6, len[2] = 7; ll mx = 1e17; for(int i = 3; i &lt;= 500; i++) &#123; /*前缀和*/ len[i] = len[i-1] + len[i-2]; /* i=80就会跳出*/ if(len[i] &gt; mx) &#123;/*cout&lt;&lt;i&lt;&lt;endl;*/break;&#125; &#125; int T; cin &gt;&gt; T; while(T--) &#123; int n; ll k; cin &gt;&gt; n &gt;&gt; k; int x; /*提前给x降低大小，所以就可以前面使用break，并且减少递归的次数*/ for(x = 1; x &lt;= n; x++) &#123; if(len[x] &gt;= k+10) break; &#125; if(x == n+1) cout &lt;&lt; dfs(x-1, k, min(10ll, len[x]-k+1)) &lt;&lt; endl; else &#123; if((n-x)%2) x++; cout &lt;&lt; dfs(x, k, min(10ll, len[x]-k+1)) &lt;&lt; endl; &#125; &#125; return 0;&#125; 每天一句叨叨不用去刻意讨好谁，因为只有做自己，才配得上最棒的人生]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>狼胆带你每天头铁一题</tag>
        <tag>斐波那契数列</tag>
        <tag>递归</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客多校9E题详解_算法日常[11/100]]]></title>
    <url>%2F2019%2F08%2F16%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-11-100%2F</url>
    <content type="text"><![CDATA[组合数学思维题题目链接2019牛客多校9 E题 题解思路其实解法一二的本质内核是一样的，可以都看一下 解法一当合并这两个集合的时候，应该将这两个集合合并后消失的贡献减去消失的贡献就应该是选择了一个a，选择了一个b，从剩下的众多集合中选择两个(即cd,ce,ef……)那么这个怎么算呢，可以用完全平方公式来推导(a+b+c+d)^2=a^2+b^2+c^2+d^2+2ab+2ac+2bc+2ad+2bd+2cd所以众多集合中选择任意选择两个的情况可以用（和的平方-平方的和）/2来求（最重要的一步） 解法二 AC代码解法一代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using ll = long long;const int MAXN = 100010;int n, m;int f[MAXN], sz[MAXN];ll sum;inline ll sqr(int x) &#123; return 1ll * x * x;&#125;inline int getf(int x) &#123; return f[x] == x ? x : (f[x] = getf(f[x]));&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); ll ans = (__int128) n * (n - 1) * (n - 2) * (n - 3) / 24; printf("%lld\n", ans); for (int i = 1; i &lt;= n; ++i) &#123; f[i] = i; sz[i] = 1; &#125; /*最开始的平方和*/ sum = n; while (m--) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); u = getf(u); v = getf(v); if(ans==0 || u==v) goto END; if (u != v) &#123; /*减掉合并部分的平方和*/ sum -= sqr(sz[u]) + sqr(sz[v]); /*后面的(sqr(n - sz[u] - sz[v]) - sum) / 2;就是`和的平方`-`平方和`=`剩下的所有两两组合`*/ ll tmp = 1ll * sz[u] * sz[v] * (sqr(n - sz[u] - sz[v]) - sum) / 2; f[u] = v; sz[v] += sz[u]; /*新的平方和的维护*/ sum += sqr(sz[v]); /*减去合并减少的贡献值*/ ans -= tmp; &#125; END: printf("%lld\n", ans); &#125; return 0;&#125; 解法二代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod = 1e9 + 7;const int inf = 0x3f3f3f3f;const int maxn = 100000 + 5;ll C[maxn][5];int p[maxn], sz[maxn], cnt[maxn];int n, m;ll ans;set&lt;int&gt; st;inline void init() &#123; for(int i = 0; i &lt; maxn; i++) C[i][0] = 1; for(int i = 1; i &lt; maxn; i++) &#123; for(int j = 1; j &lt; 5; j++) &#123; C[i][j] = C[i-1][j] + C[i-1][j-1]; &#125; &#125;&#125;inline int Find(int x) &#123; return x == p[x] ? x : p[x] = Find(p[x]); &#125;inline void Union(int x, int y) &#123; int fx = Find(x), fy = Find(y); if(fx != fy) &#123; if(fx &gt; fy) swap(fx, fy); p[fx] = fy; ll tp = C[n-sz[fx]-sz[fy]][2]; for(auto i : st) &#123; tp -= C[i][2]*cnt[i]; &#125; tp += C[sz[fx]][2]+C[sz[fy]][2]; if(tp &gt; 0) ans -= 1LL*sz[fx]*sz[fy]*tp; cnt[sz[fx]]--; cnt[sz[fy]]--; if(cnt[sz[fx]] == 0) st.erase(sz[fx]); if(cnt[sz[fy]] == 0) st.erase(sz[fy]); sz[fy] += sz[fx]; cnt[sz[fy]]++; st.insert(sz[fy]); &#125;&#125;int main() &#123; init(); scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; p[i] = i; sz[i] = 1; &#125; cnt[1] = n; st.insert(1); ans = C[n][4]; printf("%lld\n", ans); while(m--) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); Union(u, v); printf("%lld\n", ans); &#125; return 0;&#125; 每天一句叨叨生活总是很奇妙，我们到底该去向何方？ 世俗的成功吗？还是当下的快乐呢？ 珍惜身边的人呢？还是继续寻找？]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>狼胆带你每天头铁一题</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折半搜索_算法日常[10/521]]]></title>
    <url>%2F2019%2F08%2F15%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-10-521%2F</url>
    <content type="text"><![CDATA[题目题目链接2019牛客多校9 D题 题解折半搜索,详见下面的算法推荐和下面的AC的代码 meet-in-middle AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod = 1e9 + 7;const int inf = 0x3f3f3f3f;const int maxn = 1e6;struct node &#123; ll v; int id; bool operator &lt; (const node&amp; r) const &#123; return v &lt; r.v; &#125;&#125;b[maxn];ll arr[40];ll a[maxn], c[maxn];int main() &#123; int n; ll sum; scanf("%d%lld", &amp;n, &amp;sum); for(int i = 0; i &lt; n; i++) scanf("%lld", &amp;arr[i]); int x = n/2, y = n-x; int up1 = (1&lt;&lt;x), up2 = (1&lt;&lt;y); /*全0到全1串的遍历，然后之后是对每个串的逐位遍历，记录此串的和值*/ for(int i = 0; i &lt; up1; i++) &#123; for(int j = 0; j &lt; x; j++) &#123; if(i &amp; (1&lt;&lt;j)) a[i] += arr[j]; &#125; &#125; for(int i = 0; i &lt; up2; i++) &#123; b[i].id = i; b[i].v = 0; for(int j = 0; j &lt; y; j++) &#123; if(i &amp; (1&lt;&lt;j)) b[i].v += arr[x+j]; &#125; &#125; /*让B[i]数组有序，然后使用lower_bound去搜索*/ sort(b, b+up2); for(int i = 0; i &lt; up2; i++) c[i] = b[i].v; /*这里复杂度是2^18*log(2^18) = 4.7*10^6左右*/ for(int i = 0; i &lt; up1; i++) &#123; int p = lower_bound(c, c+up2, sum-a[i])-c; if(c[p]+a[i] == sum) &#123; for(int j = 0; j &lt; x; j++) &#123; if(i &amp; (1&lt;&lt;j)) printf("1"); else printf("0"); &#125; int id = b[p].id; for(int j = 0; j &lt; y; j++) &#123; if(id &amp; (1&lt;&lt;j)) printf("1"); else printf("0"); &#125; break; &#125; &#125; return 0;&#125; 每天叨叨一句“我不同意你， 但我可以支持你”李开复原来是学法律的，但他爱好计算机，后来师从美国卡内基梅隆大学计算机学院院长罗杰·瑞迪。 罗杰非常喜欢李开复，把自己的知识毫无保留地传授给李开复，使得他在编程水平突飞猛进。但随着研究的深入，李开复与导师有了分歧，尤其是在计算机语音识别系统研究时，罗杰主张用传统的方法，可是李开复却想从另一个方向，这悖离了主流，有别于大多数语音技术同行。怎么办？导师给李开复指出来了，让他“悬崖勒马”。可是李开复还是想按照自己的想法做。 有不少关系李开复的好心人提醒他：“你在计算机领域还乳臭未干，人家罗杰是美国国家工程学院和美国艺术与科学学院院士，你听导师的，可以少走弯路。”可是李开复却说：“我想另辟溪径。”“可是这样会得罪导师，如果得不到他的支持，你可能寸步难行。你另搞一套，如果成了，让他多没面子。相反你顺从了他，他是总统特别顾问委员会信息委员会成员、‘图灵奖’获得者，有他的提携，将来前途不可限量。”可是那时的李开复没想那么复杂，还是决定走自己的路。 没想到，尽管导师批评了李开复几次，可是李开复一意孤行。罗杰说：“作为科学家，我也不是全知全能。我不同意你的看法，但我可以支持你。”这让李开复非常意外。 此后，李开复就放开手脚大干起来。不久，罗杰又来问李开复：“有没有什么困难？”“暂时没有。”“如果有什么需要我帮助的，尽管说啊。”李开复反问道：“你不生我的气啊？”“‘不认同’不等于‘不支持’。”罗杰说。 参考链接http://blog.sina.com.cn/s/blog_98acb6e70102w95o.html]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>狼胆带你每天头铁一题</tag>
        <tag>折半搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10进制矩阵快速幂-狼胆带你每天头铁一题-算法日常[9/100]]]></title>
    <url>%2F2019%2F08%2F14%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-9-100%2F</url>
    <content type="text"><![CDATA[头铁来源因为狼胆小编本人比较垃圾，所以只能每天带大家头铁一题简单常识题(大佬眼中的常识，我这个蒟蒻还只能头铁)，希望能帮助到小白，那就很开心了 题目题目链接2019牛客多校5 B题 题解理想中的草稿状态 真实的草稿状态 dreammoon大佬的官方的题解也可以看看 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;typedef unsigned long long ULL;const int SIZE = 3000010;ULL MOD;char s[SIZE];/*矩阵相乘，第一行乘以第一列，第一行乘以第二列……也可以使用for两重循环求*/void mul(ULL* c1, ULL* c2, ULL *res)&#123; res[0] = (c1[0] * c2[0] + c1[1] * c2[2]) % MOD; res[1] = (c1[0] * c2[1] + c1[1] * c2[3]) % MOD; res[2] = (c1[2] * c2[0] + c1[3] * c2[2]) % MOD; res[3] = (c1[3] * c2[3] + c1[2] * c2[1]) % MOD;&#125;int main() &#123; int a,b; int x1,x2; scanf("%d%d%d%d", &amp;x1, &amp;x2, &amp;a, &amp;b); scanf("%s%llu",s, &amp;MOD); int len = 0; /* 统计长度，并且把个位的值(即最后一位的值)减去1 */ for(; s[len]; len++); s[len-1]--; /* 个位减掉了之后向前面借位 */ for(int i = len - 1; i &gt;= 0 &amp;&amp; s[i] &lt; '0'; i--)&#123; s[i] = '9'; s[i-1]--; &#125; ULL now0 = x1, now1 = x2; ULL d[4][4]; d[0][0] = 0; d[0][1] = 1; d[0][2] = b; d[0][3] = a; for(int it = len - 1; it &gt;= 0; it--)&#123; memset(d[1], 0, sizeof(ULL) * 12); /*A "常数"矩阵相乘4次*/ for(int p = 1; p &lt; 4; p++)&#123; mul(d[p-1], d[p-1], d[p]); &#125; s[it] -= '0'; for(int p = 0; p &lt; 4; p++)&#123; if((s[it] &gt;&gt; p) &amp; 1)&#123; ULL* ml = d[p]; std::tie(now0, now1) = std::make_pair((ml[0] * now0 + ml[1] * now1) % MOD,(ml[2] * now0 + ml[3] * now1) % MOD); &#125; &#125; mul(d[1], d[3], d[0]); &#125; printf("%llu\n", now1); return 0;&#125; 少量知识点tie pair是tuple的一个子集 每天一句叨叨今天看到一禅小和尚: 我们尝遍生活的苦，却都只是为了过好平凡的一生 但我觉得如果自己明知道人生是苦，明知道人是基因的机器人(参见算法日常4的叨叨)，却认认认真真地选择好好生活，这就是一种伟大，这就是自由，这就是自己的突破，就是自己的英雄！]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>狼胆带你每天头铁一题</tag>
        <tag>数学</tag>
        <tag>矩阵快速幂</tag>
        <tag>10进制矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[银联挑战赛复赛A,B题_算法日常[8/100]]]></title>
    <url>%2F2019%2F08%2F13%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-8-100%2F</url>
    <content type="text"><![CDATA[缘起8月10号是计算机设计大赛决赛答辩的最后一天，这天下午是牛客多校8，晚上是银联挑战赛复赛，队友出去吃吃喝喝了，我点个外卖，打着比赛，然后第一题就卡住不会做，然后自闭了，果然银联的比赛很重视数学题啊啊啊，是我数学题没怎么练，太菜了—-&gt;所以菜导致既没有吃到好东西，又导致爆零没太多收获，所以还是需要多多努力 A题爱喝「肥宅快乐水」的班长爱喝「肥宅快乐水」的班长 题目解法 看不懂的知识链接隔板法 扩展的隔板法中： 转化前的空盒 == 转化后每个盒子至少放一个 AC代码1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=1000000007;const int inf = 0x3f3f3f3f;const int M = 2e3+7;int C[M][M];int T,n,m;void add(ll &amp;a,ll v)&#123; a += v; if(a &gt;= mod) a-=mod;&#125;void pre()&#123; for(int i=0;i&lt;M;i++)&#123; C[i][0]=1; for(int j=1;j&lt;=i;j++)&#123; C[i][j]=C[i-1][j-1]+C[i-1][j]; if(C[i][j]&gt;=mod) C[i][j]-=mod; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false);cin.tie(0); cin&gt;&gt;T; pre(); while(T--)&#123; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;C[n+m-2][m-1]&lt;&lt;endl; &#125; return 0;&#125; B题整数对整数对 题目解法 AC代码1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll T,n,m,p,ans;int main()&#123; ios::sync_with_stdio(false);cin.tie(0); cin&gt;&gt;T; while(T--)&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;p; ans = 0; ll x = n/p; for(ll r = 0; r &lt; p ; r++ )&#123; /*求出b的种类数*/ ll bn = m/(p/__gcd(r,p)); /*分别对应题解的1,2,3种情况,其实1,3可以合并*/ if(!r) ans+=x*bn; else if(0&lt;r &amp;&amp; r&lt;=n%p) ans+=(x+1)*bn; else ans+=x*bn; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 每天一句叨叨人心的成见如同一座大山，我们总是口上说不能有偏见，其实真正的内心想法却不是这样的… 所以我对别人的偏见，我只能尽量克制，让自己理性对待，然后做之不止，乃成君子 对于别人对自己的偏见不要在意，而是要专注自己的目标 感觉自己生来就有一种追求挑战的血液，在小时候尤为明显，但是感觉在长久的教化过程中削弱了，所以我想要找回本真，生命不息，战斗不止，和天生的不公斗到底，做自己的英雄]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>组合数学</tag>
        <tag>隔板法</tag>
        <tag>数学思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第16周[16/521]]]></title>
    <url>%2F2019%2F08%2F11%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC16%E5%91%A8-16-521%2F</url>
    <content type="text"><![CDATA[Algorithm牛客多校8的签到 ReviewBeing Happy Is Hard Work好多生词啊，所以决定开始背单词Happiness, in other words, is practiced. Tips打算法比赛一定要熟练使用线段树啊，血的教训 Share2019杭电多校1006和1007算法日常[4/100] 后缀数组-算法学习日常[5/100] 2019杭电多校6_1005算法日常[6/100] 2019牛客多校8_B题算法日常[7/100] 每天一句叨叨生活总有太多的美好无法用相机记录下来，所以那就给每一个当下投以最好的微笑吧]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客多校8_B题算法日常[7/100]]]></title>
    <url>%2F2019%2F08%2F11%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-7-100%2F</url>
    <content type="text"><![CDATA[题目题目链接以及描述2019牛客多校8_B题 题意以及思路 AC代码1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100000 + 5;int a[maxn], b[maxn], c[maxn];int main() &#123; int n; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); /*c[i]记录的是a[i]的上一个位置加1的位置*/ c[i] = b[a[i]]+1; b[a[i]] = i; &#125; ll ans = 0; for(int i = 1; i &lt;= n; i++) &#123; ans += 1LL*(n-i+1)*(i-c[i]+1); &#125; printf("%lld\n", ans); return 0;&#125; 每日一句叨叨但求精进,无问西东]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019杭电多校6_1005算法日常[6/100]]]></title>
    <url>%2F2019%2F08%2F07%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-6-100%2F</url>
    <content type="text"><![CDATA[题目题目链接2019杭电多校6_1005_HDU6638 思路自己一开想偏了，想着像以前0,1矩阵那种同权值点一样叠加成为矩形的最大面积来求解，这样子就能让复杂度在O(n^2)的样子 然后并非如此，这里的权值w是一个可正可负的整数…自己隐隐约约地感觉复杂度要达到O(n^2*log(n)),但是没有往下想，虽然想了也不一定会,,,emmmm,继续努力吧 正解 首先将纵坐标离散化到 O(n) 的范围内，方便后续的处理。 将所有点按照横坐标排序，枚举矩形的上边界，然后往后依次加入每个点，这样就确定了矩形的上下边界。 设 v[y] 表示矩形内部纵坐标为 y 的点的权值和，则答案为 v 的最大子段和，用线段树维护带修改的最大子段和即可。 时间复杂度 O(n^2*log(n)) std理解版今天比较晚了，明天要出一趟远门，所以暂时没有手写，对不起自己啊，等回家一定要好好把这个重新写几遍12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int N=2010,M=4100;int Case,n,m,i,j,k,cb,b[N],pos[N];ll pre[M],suf[M],s[M],v[M],ans;struct E&#123;int x,y,z;&#125;e[N];inline bool cmp(const E&amp;a,const E&amp;b)&#123;return a.x&lt;b.x;&#125;/*用纵坐标建的线段树，大佬对于线段树的理解以及如同我对1+1的理解一样了！*/void build(int x,int a,int b)&#123; pre[x]=suf[x]=s[x]=v[x]=0; if(a==b)&#123; pos[a]=x; return; &#125; int mid=(a+b)&gt;&gt;1; build(x&lt;&lt;1,a,mid),build(x&lt;&lt;1|1,mid+1,b);&#125;inline void change(int x,int p)&#123; x=pos[x]; s[x]+=p; if(s[x]&gt;0)pre[x]=suf[x]=v[x]=s[x];else pre[x]=suf[x]=v[x]=0; /*上传的操作精辟,orz*/ for(x&gt;&gt;=1;x;x&gt;&gt;=1)&#123; /*根的左边的 = max(左子树之前的,左子树+右子树之前的)*/ pre[x]=max(pre[x&lt;&lt;1],s[x&lt;&lt;1]+pre[x&lt;&lt;1|1]); /*根的右边的 = max(右子树右边的,右子树+左子树右边的)*/ suf[x]=max(suf[x&lt;&lt;1|1],s[x&lt;&lt;1|1]+suf[x&lt;&lt;1]); /*s是直接叠加的*/ s[x]=s[x&lt;&lt;1]+s[x&lt;&lt;1|1]; /*区间最大值 = max(左子树最大,右子树最大,左子树后面的+左子树前面的)*/ v[x]=max(max(v[x&lt;&lt;1],v[x&lt;&lt;1|1]),suf[x&lt;&lt;1]+pre[x&lt;&lt;1|1]); &#125;&#125;int main()&#123; scanf("%d",&amp;Case); while(Case--)&#123; scanf("%d",&amp;n); for(cb=0,i=1;i&lt;=n;i++)&#123; scanf("%d%d%d",&amp;e[i].x,&amp;e[i].y,&amp;e[i].z); b[++cb]=e[i].y; &#125; /*离散化纵坐标*/ sort(b+1,b+cb+1); for(m=0,i=1;i&lt;=cb;i++)if(i==1||b[i]!=b[m])b[++m]=b[i]; /*给横坐标排序*/ sort(e+1,e+n+1,cmp); ans=0; /*用离散化后的纵坐标覆盖掉原来的纵坐标*/ for(i=1;i&lt;=n;i++)e[i].y=lower_bound(b+1,b+m+1,e[i].y)-b; /*枚举上边界，x是行号，是上边界*/ for(i=1;i&lt;=n;i++)if(i==1||e[i].x!=e[i-1].x)&#123; build(1,1,m); /*加入点确定好下边界，这样上下边界都确定好了*/ for(j=i;j&lt;=n;j=k)&#123; /*又是逐步插入空树维护区间最大值的操作*/ for(k=j;k&lt;=n&amp;&amp;e[j].x==e[k].x;k++)change(e[k].y,e[k].z); if(ans&lt;v[1])ans=v[1]; &#125; &#125; printf("%lld\n",ans); &#125;&#125; 每天一句叨叨今天是情人节，然而…没得女朋友…不过有队友和我一起大杭电多校还是很开心的啦(还是有点点失落) 虽然 但是谁终将声震人间，必长久深自缄默 谁终将点燃闪电，必长久如云漂泊 全力以赴打完这一段时光的退役赛一定会是一个大学乃至人生最珍贵的记忆，所以这段时间先不要让自己被一个体内的激素控制，等时机到了，一定会更加美好！加油吧，少年！]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>线段树</tag>
        <tag>算法学习日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组-算法学习日常[5/100]]]></title>
    <url>%2F2019%2F08%2F06%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8-5-100%2F</url>
    <content type="text"><![CDATA[后缀数组论文分享后缀数组论文分享 每天一句叨叨人一能之，己百之；人十能之，己千之。果能此道矣，虽愚必明，虽柔必强。]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019杭电多校1006和1007算法日常[4/100]]]></title>
    <url>%2F2019%2F08%2F05%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-4-100%2F</url>
    <content type="text"><![CDATA[序 今天是杭电多校第5场，然后1006签到本来应该10mins内写完，然后我菜鸡写了2小时(各种问题不熟练和紧张)，赛后发现有大佬用dc3(一种据说复杂度O(n)的后缀数组算法,发现自己孤陋寡闻) 1007真滴有趣…闪电蛇皮走位，然后自己想复杂了一点点… 题目链接2019杭电多校5 1006解法Ekmp，用s.substr(1)的串来做ekmp函数的原串，s做ekmp函数的匹配串，这样跑一次ekmp就行，然后累加extend ekmp学习教程·我觉得比较好的一个(我也用这个学的) AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;long long ans;// int next[1000000];int nxt[1000000];int extend[1000000];string S, T;int n, m;/* 求解 T 中 next[]，注释参考 GetExtend() */void GetNext(string &amp; T, int &amp; m, int next[])&#123; int a = 0, p = 0; next[0] = m; for (int i = 1; i &lt; m; i++) &#123; if (i &gt;= p || i + next[i - a] &gt;= p) &#123; if (i &gt;= p) p = i; while (p &lt; m &amp;&amp; T[p] == T[p - i]) p++; next[i] = p - i; a = i; &#125; else next[i] = next[i - a]; &#125;&#125;/* 求解 extend[] */void GetExtend(string &amp; S, int &amp; n, string &amp; T, int &amp; m, int extend[], int next[])&#123; int a = 0, p = 0; GetNext(T, m, next); for (int i = 0; i &lt; n; i++) &#123; if (i &gt;= p || i + next[i - a] &gt;= p) // i &gt;= p 的作用：举个典型例子，S 和 T 无一字符相同 &#123; if (i &gt;= p) p = i; while (p &lt; n &amp;&amp; p - i &lt; m &amp;&amp; S[p] == T[p - i]) p++; extend[i] = p - i; a = i; &#125; else extend[i] = next[i - a]; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); int t; cin&gt;&gt;t; while(t--)&#123; ans = 0; cin&gt;&gt;S; n = S.size(); T = S.substr(1); m = n - 1; /*可能程序以为我用了前面的函数声明中的next[],所以说我模棱两可,加个全局的命名空间就行 或者换个变量名也行*/ // GetExtend(T, m, S, n, extend, ::next); GetExtend(T, m, S, n, extend, nxt); for (int j = 0; j &lt; m; j++)&#123; // cout &lt;&lt; extend[j] &lt;&lt; " \n"[j==m-1]; ans += extend[j]+j==n-1 ? extend[j] : extend[j]+1 ; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 1007解法法一a[i] = a[i-1]+a[i-3],就是对于第i项有两种情况，要么是直接往上走要么是闪电 法二dls说暴力打表找规律比较不用动脑子，哭了，臭大佬，好过分 AC代码123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 998244353;const int inf = 0x3f3f3f3f;const int maxn = 100000 + 5;ll a[maxn];int main() &#123; a[1] = a[2] = a[3] = 1; for(int i = 4; i &lt; maxn; i++) a[i] = (a[i-1]+a[i-3])%mod; int T; scanf("%d", &amp;T); while(T--) &#123; int n, l, r; scanf("%d%d%d", &amp;n, &amp;l, &amp;r); if(l &gt; r) swap(l, r); if(l != 1) l++; if(r != n) r--; printf("%lld\n", a[r-l+1]); &#125; return 0;&#125; 注因为今天一直在听dls的直播，尽管后面的题听不懂，想听听dls一般解题思路是啥(其实后面听不懂就容易发呆了),所以今天还没有补很多题，然后就只写了这么一点点,我好弱啊 每天一句叨叨人总得有个目标，才能继续勇敢而坚强地活着，大部分成年人，在三十岁左右已经没了活着的目标，为了不让自己死去，他们制造了一个孩子，有了这个小孩，他们终于找到了努力工作和继续活下去的目标。 不，不是的，那是基因的谎言…让你这个机器人帮忙传递他们的存在 但如果你知道这是谎言，并决定真的要选择它，那才是真正的选择 教育本来就是不平等的，有些人很年轻就是OI金牌了，然而有些人还在发愁下次要怎么骗外公外婆我出去玩了，其实是偷偷跑去了网吧，如饥似渴地享受那几个小时的奥比岛，赛尔号，功夫派，洛克王国，地下城与勇士，英雄联盟…(从小学到高中渐渐变化的是游戏),然而别人早就享受到了算法的美妙，并将来很大程度能因此受到更好的教育，然后享受社会上最好的资源，过上幸福的生活，虽然我不能这样定义幸福，但是不平等确实存在，想要跨越社会阶层的鸿沟，可能要花上很久很久的努力.不过，我认为，跨越社会阶层的鸿沟，才是这个和平时代个人最英雄的挑战.做你自己的英雄，不断超越自己，并同时珍爱身边的人，过好这一生… 今天说的好像有点小多，叨叨叨多了，快滚去运动洗澡睡觉，明天继续来补题]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>ekmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python写字符串模拟真香_算法日常[3/100]]]></title>
    <url>%2F2019%2F08%2F04%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-3-100%2F</url>
    <content type="text"><![CDATA[题目链接2019牛客多校第6场B题 描述 解法解法一把8段中每段都处理成为一个整数,然后找出最长的连续0,相同的长度的话就让0放前面的段(因为0的ASCII码是48,比:的58小),然后进行判断性输出(数字用%x可以实现以16进制输出) 详见代码注释 C++版AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/*"%x"以16进制的形式输出,是我孤陋寡闻了*/#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int a[10];int main()&#123; int T,t; scanf("%d",&amp;T); for(int ii=1;ii&lt;=T;ii++)&#123; int f=0,l=0,nl=0; /*观察下面的代码容易知道,只有最前面为0的时候是f=1, 其他地方为0,f为i-nl(减掉了0的长度即为0开始的地方) 综上: f是最长连续0开始的位置 然后l是保存维护最长连续0的长度 nl是当前的最长连续0的长度*/ for(int i=1;i&lt;=8;i++)&#123; a[i]=0; for(int j=1;j&lt;=16;j++)&#123; scanf("%1d",&amp;t); a[i]=a[i]*2+t; &#125; if(!a[i]) nl++; else&#123; /*判断现在的连续0的数目是否超过之前的连续0的数目*/ if(nl&gt;=l&amp;&amp;nl&gt;1)&#123; f=i-nl;l=nl; &#125; nl=0; &#125; if(i==8&amp;&amp;nl&gt;1)&#123; if(nl&gt;l)&#123; f=i-nl+1;l=nl; &#125; /*末尾有0，但是末尾的连续0和最前面的连续0相同 所以考虑字典序最小，由于'0'-48,':'-58 所以优先让前面输出0,后面就输出':'*/ if(nl==l&amp;&amp;f==1)&#123; f=i-nl+1;l=nl; &#125; &#125; &#125; printf("Case #%d: ",ii); if(f==1)printf(":"); for(int i=1;i&lt;=8;i++)&#123; if(i==f)&#123; printf(":"); i+=l; &#125; if(i&gt;8)puts(""); else printf("%x%c",a[i],":\n"[i==8]); &#125; &#125; return 0;&#125; 解法二通过枚举每种有0的串，然后统一加到一个列表中，之后通过sort(优先长度然后优先字典序)，最后输出 详见我的Python注释代码 Python_AC代码12345678910111213141516171819T=int(input())for t in range(T): b=input() a=[] for i in range(8): # 这个[2:]是去掉'0x' a.append(hex(int(b[i*16:i*16+16],2))[2:]) s=[] s.append(':'.join(a)) for i in range(8): for j in range(i+1,8): # 对每个i中的后缀长a[i:j+1]判断各元素是否都是等于0的 # 是就直接把字符串丢进去,比C++AC版本中的记录长度简单很多 if all(map(lambda x:x=='0',a[i:j+1])): # 用':'分隔的a[i]串 s.append(':'.join(a[:i])+'::'+':'.join(a[j+1:])) # 优先用长度排序,其实是同长度按照字典序排序 s.sort(key=lambda x:(len(x),x)) print('Case #%d:'%(t+1),s[0]) 每天一句叨叨 岁月还漫长总会有人陪你骑马喝酒走四方]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>Python写算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第15周[15/521]]]></title>
    <url>%2F2019%2F08%2F04%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC15%E5%91%A8-15-521%2F</url>
    <content type="text"><![CDATA[Algorithm已经下定决心要努力刷题了，所以每天都有刷 ReviewChina Has Started a Grand Experiment in AI Education. It Could Reshape How the World Learns. 语句摘选 In three hours we understand students more than the three years spent by the best teachers. Three things have fueled China’s AI education boom. The first is tax breaks and other incentives for AI ventures that improve anything from student learning to teacher training to school management. For VCs, this means such ventures are good bets. According to one estimate, China led the way in over $1 billion invested globally last year in AI education. Second, academic competition in China is fierce. Ten million students a year take the college entrance exam, the gaokao. Your score determines whether and where you can study for a degree, and it’s seen as the biggest determinant of success for the rest of your life. Parents willingly pay for tutoring or anything else that helps their children get ahead. Finally, Chinese entrepreneurs have masses of data at their disposal to train and refine their algorithms.The population is vast, people’s views on data privacy are much more lax than in the West (especially if they can get coveted benefits like academic performance in return), and parents are big believers in the potential of technology, having seen how much it has transformed the country in just a few decades. Squirrel’s approach may yield great results on traditional education, but it doesn’t prepare students to be flexible in a changing world, the experts I spoke to say. “There’s a difference between adaptive learning and personalized learning,” says Chris Dede, a professor at Harvard University in the Technology, Innovation, and Education Program. Squirrel is doing adaptive learning, which is about “understanding exactly what students know and don’t know.” But it pays no attention to what they want to know or how they learn best. Personalized learning takes their interests and needs into account to “orchestrate the motivation and time for each student so they are able to make progress.” Much of Squirrel’s philosophy stems from Li’s own experiences as a child. When he was young, he didn’t have very good emotional intelligence, he says, and reading books on the subject didn’t help. So he spent half a year dividing the skill into 27 different components and trained himself on each one. He trained himself to be more observant, for example, and to be an interesting conversationalist (“I spent a lot of time finding 100 topics, so I have a lot of material to talk with others,” he says). He even trained himself to keep smiling when others criticized him. (“After that, in my life, I do not have any enemies.”) The method gave him the results he wanted — along with the firm belief that anything can be taught this way. That’s exactly what China lacks. If you are able to speak multiple languages, you are able to talk to different people; you are able to communicate different ideas感想 估计阅读时间是17mins，然而我抠脚的英语水平加上文章的深度和联想性让我看了整整一个小时 AI教学有很好的数据分析优势，计算机的快速处理数据能力，不分日夜地工作能力，都使得AI教学有很好的前景，只要不断地迭代分析数据的算法，一定可以让计算机拥有快速检测一个学生水平的能力，传统老师与计算机的差距在于经验的积累速度，不过对于单个知识点来说目前可能一个老师可能能给更好的帮助，所以我认为当下如果有AI算法辅助分析一个学生的水平，然后给针对的训练，再在个别的知识点上用上老师，那么可以大大降低对老师经验性的要求。因为我认为一个顶级老师和一个初级老师的区别仅在于对知识系统性的掌握以及对学生知识框架的快速认识能力上面(后者为主)，所以有了AI算法的辅助，将能降低家长花重金请名师的成本，而可以请一个初级老师+AI算法辅助的方式 感叹世界变化之快！ 感觉自己如果要成为认知层的上层人士，必须和世界进行连接，和更多的大师交流，那就必须学好英语，不然看一篇这样简单的文章要花上太久的时间…所以坚持好好学English！ Tips推荐一个OIwiki网站,内容很全面,分享给你们 Share线段树入门-AcWing-245-你能回答这些问题吗 priority-queue和multiset异同以及线段树空树插入维护初见 8数码和15数码算法结论和延展 拓扑排序以及C++读取空行[算法学习日常1/100] 反二分题的做法-算法日常[2/100] Python写字符串模拟真香_算法日常[3/100]]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反二分题的做法-算法日常[2/100]]]></title>
    <url>%2F2019%2F08%2F03%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-2-100%2F</url>
    <content type="text"><![CDATA[序今天是个好日子，开局多校D看起来就是个简单的二分模拟,马上动手写起来啊！然后一直写到了比赛结束(当然中途看了一下其他题,并且给队友提供了j题的解题思路) 反二分的2019牛客多校6D题题目链接 哒哒马蹄终究是错因为这个题目终极不是正规的二分做法！因为答案根本不满足二分算法中的答案单调性，比如如下反例1215 539 39 39 39 39 60 60 60 60 60 100 100 100 100 100 答案是199，而200不能是答案，201也不能是答案 (二分输出答案是216)(因为二分总是在较大数值的时候是满足的可能性极大的,所以二分后整体的结果偏大,其实有更小的答案漏掉了) 不过这题的美丽错误美就美在了它让人有种是二分的错误—(哒哒的马蹄，是个美丽的错误) 如何AC不过因为数据比较弱(其实造一个完美避开二分的数据几乎是不可能在题目数据范围实现的，如果可以，那我把二分后往小的方向开得更远一下枚举，根据上面分析为了避免小概率事件还可以多搞一下向大的方向也枚举)，所以我们现在可以有两种做法 先二分，然后在这个ans下继续向小的方向枚举20项 因为答案的下界和上界相差很小，可以直接枚举 二分再向小方向走1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/*因为数据弱，所以不满足单调性的时候这样这样来凑一手*/#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=1000000007;const int inf = 0x3f3f3f3f;const int M = 1e3+10;int T,n,K,v[M],sum,vis[M];bool check(int x)&#123; if(x*K&lt;sum || x&lt;v[n-1]) return false; if(x&gt;=v[n-1] &amp;&amp; K&gt;=n) return true; for(int i=0;i&lt;n;i++) vis[i]=0; int tmp=0,ts=sum; int i=1; while(ts&gt;0)&#123; int tps = 0; while(i&lt;=n &amp;&amp; vis[n-i]) i++; if(n-i&gt;=0) &#123; tps += v[n-i]; // cout&lt;&lt;"I get you! : "&lt;&lt;v[n-i]&lt;&lt;endl; vis[n-i]=1; &#125; else break; while(tps&lt;x)&#123; int tn = upper_bound(v,v+n-i,x-tps)-v; int j=1; while(j&lt;=tn &amp;&amp; vis[tn-j]) j++; if(tn-j&gt;=0) &#123; tps += v[tn-j]; // cout&lt;&lt;"I get you! : "&lt;&lt;v[tn-j]&lt;&lt;endl; vis[tn-j]=1; &#125; else break; &#125; // cout&lt;&lt;"How much is the tps "&lt;&lt;tps&lt;&lt;endl; ts -= tps; tmp++; &#125; if(tmp&gt;K) return false; return true;&#125;int main()&#123; ios::sync_with_stdio(false);cin.tie(0); cin&gt;&gt;T;int kase=1; while(T--)&#123; cin&gt;&gt;n&gt;&gt;K; sum = 0; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;v[i]; sum+=v[i]; &#125; sort(v,v+n); int l=1,r=1e6; while(l&lt;r) &#123; // cout&lt;&lt;"l: "&lt;&lt;l&lt;&lt;" r: "&lt;&lt;r&lt;&lt;endl; int mid = (l+r)&gt;&gt;1; if(check(mid)) r=mid;else l = mid+1; &#125; int ans = l; for(int i=ans;i&gt;=ans-20;i--) if(check(i)) ans = i; cout&lt;&lt;"Case #"&lt;&lt;kase++&lt;&lt;": "&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 正规做法-从下界开始枚举123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 代码来源--杭电的一个二人小分队 jesus#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N=1086;int v[N],vis[N];int n,k;bool check(int vv)&#123; int num=k; for(int i=0;i&lt;=n;i++)&#123; vis[i]=0; &#125; int left=n; int maxx=n,no=1; while(num)&#123; int sp=vv; for(int i=maxx;i&gt;0;i--)&#123; //如果当前剩余容量比最小的更小，不能继续装，退出循环 if(sp&lt;v[no])break; //如果当前剩余容量足够，并且物品i还没有装过，则装入 if(sp&gt;=v[i]&amp;&amp;!vis[i])&#123; sp=sp-v[i];vis[i]=1;left--; //如果无剩余，直接退出循环 if(!sp)break; &#125; &#125; //压缩下次寻找的范围 while(vis[maxx])maxx--; while(vis[no])no++; num--; &#125; //如果无剩余，则正好输出 if(!left)return 1; return 0;&#125;int main()&#123; int cases; scanf("%d",&amp;cases); for(int ti=1;ti&lt;=cases;ti++)&#123; scanf("%d%d",&amp;n,&amp;k); int sum=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;v[i]); sum+=v[i]; &#125; sort(v+1,v+n+1); int b=sum/k; if(sum%k)b++; int maxx=max(v[n],b); int ans=maxx; int i=maxx; while(i)&#123; if(check(i))&#123; ans=i;break; &#125; i++; &#125; printf("Case #%d: %d\n",ti,ans); &#125; return 0;&#125; 每天一句叨叨人生本来就是一场修行，人的基因把我们当做机器人，然后让我们为他们传递生命，所以给我们制造了很多激素，其中一些情绪激素让我们时而快乐时而悲伤，时而兴奋时而自闭，我们可能无法改变太多，唯有做的就是享受这个当机器人还能发发牢骚的快乐，并享受这一次人生的偶然，尽自己的快乐，去奋斗，去创造，因为平庸更使自己感到乏味…那就成为一个，不断进化，并快乐地享受其中的机器人吧]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>反二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序以及C++读取空行[算法学习日常1/100]]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%86%99%E5%B0%81%E6%83%85%E4%B9%A6%E7%BB%99%E7%AE%97%E6%B3%951%2F</url>
    <content type="text"><![CDATA[算法学习日常第一天2019年8月2日 今天上午，重新认识算法的全貌各种资源及知识点总结 并且还了解到了常见错误写法，当然自己当年也写过很多错误 下午先是补牛客5的多校G题的dp—接着昨天的补都补了90mins(含对着手写第一遍)，还是太菜了 然后补H题，发现自己昨天写了3个小时的这个题目不是字符串插入题…而是一个拓扑排序题..真的自己菜得可怕..写错分类怎么可能做对，然后自己又焦虑了很久，知道2019年8月2日15:48:15才静下来认真地学习拓扑排序 拓扑排序在紫书上学了下，就是把点对关系看成一个图里面的指向关系，即把每一个点对看做小数指向大数的有向边，如果图没有有向环的话，说明是可以的，否则是不行的 记自己头铁处理空行读入，搞了整整一个小时读取空行 拓扑排序以及空行头铁见代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/*2019年8月2日19:25:05拓扑排序bfs拓扑排序算法思想1、在AOV网络中选一个没有直接前驱的顶点, 并输出之;2、从图中删去该顶点, 同时删去所有它发出的有向边;---&gt;(我下面的题目使用stop实现删除)3、重复以上步骤, 直到◆ 全部顶点均已输出，拓扑有序序列形成，拓扑排序完成；◆ 或者图中还有未输出的顶点，但已跳出处理循环。这说明图中还剩下一些顶点，它们都有直接前驱，再也找不到没有前驱的顶点了。这时AOV网络中必定存在有向环。*/#include&lt;bits/stdc++.h&gt;using namespace std;const int M = 1e4+5;int n,m,lentmp;string s[10][10];/*用string本来可以不用下面的len*/int len[10][10];int it[10][10];string ans,t;bool check();bool solve();int main()&#123; ios::sync_with_stdio(false);cin.tie(0); cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m*(m-1)/2;i++)&#123; cin&gt;&gt;t&gt;&gt;lentmp; int x=t[0]-'a',y=t[1]-'a'; if(x&gt;y) swap(x,y); len[x][y] = lentmp; // if(lentmp) cin&gt;&gt;s[x][y]; /*我的头铁(~~比赛因此卡1小时去谷歌~~)写法 先直接用cin.get()吃掉t和lentmp后面的回车 再getline(), 否则getline会吃那个回车而导致少读数据*/ cin.get(); getline(cin,s[x][y]); &#125; if(!solve()) puts("-1"); return 0;&#125;/*暴力检测每队关系是否和整个串中的样子是一样的法二: 也可以每一对关系得到一个ans的tmp串,然后再去==判断 但是效率低*/bool check()&#123; for(int i=0;i&lt;m;i++)&#123; for(int j=i+1;j&lt;m;j++)&#123; int now = 0; for(int k=0;k&lt;n;k++)&#123; if(ans[k]=='a'+i||ans[k]=='a'+j)&#123; if(ans[k]!=s[i][j][now]) return 0; now++; &#125; &#125; if(now!=len[i][j]) return 0; &#125; &#125; return 1;&#125;bool solve()&#123; for(int i=0;i&lt;n;i++)&#123; /* 这里是每个大串的排序关系-通过m次的关系问询确定的 注意前面巧妙地处理出了j小于k---&gt;这就是拓扑排序的思路 1.对没有出现过的关系(即s[j][k]的那一维全为空)stop[j]和stop[k]全都赋值为1 2.对于到最后了的关系(即s[j][k][]='\0')全赋空 因为有m*(m-1)/2 对 关系，也就是每两个都有比较，所以一定能够得出最前面的一个字符..所以就完美了！ 这里每次stop都会清零！*/ bool stop[10] = &#123;&#125;; for(int j=0;j&lt;m;j++)&#123; for(int k=j+1;k&lt;m;k++)&#123; if(!s[j][k][it[j][k]]) stop[j]=stop[k]=1; else if(s[j][k][it[j][k]]=='a'+j) stop[k]=1; else stop[j] = 1; &#125; &#125; bool done = false; for(int j=0;j&lt;m;j++)&#123; if(!stop[j])&#123; ans+='a'+j; for(int k=0;k&lt;m;k++)&#123; if(k&lt;j) it[k][j]++; else if(k&gt;j) it[j][k]++; &#125; done = true; break; &#125; &#125; if(!done) return 0; &#125; if(!check()) return 0; cout&lt;&lt;ans&lt;&lt;endl; return 1;&#125; 晚上成功补完H题和I题，发现好像没有时间补B题了，明天上午来补一下B题 每日一句叨叨杜月笙知道成功需要代价，他想为自己洗白(小时候家里穷只能混黑帮)，为整个帮派洗白，但穿了大半辈子长褂(为了不露出纹身)，让自己的说书先生给自己讲了大半辈子学，也为上海的繁荣安定做了大半辈子贡献，但却最终未被认可(通过人脉被选之为一个参议长，但蒋介石让他自己退位)，但杜月笙却永远被后人被历史铭记 若命运不公，那就和它斗到底！]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>拓扑排序</tag>
        <tag>BFS</tag>
        <tag>读取空行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8数码和15数码算法结论和延展]]></title>
    <url>%2F2019%2F07%2F31%2F8%E6%95%B0%E7%A0%81%E5%92%8C15%E6%95%B0%E7%A0%81%E7%AE%97%E6%B3%95%E7%BB%93%E8%AE%BA%E5%92%8C%E5%BB%B6%E5%B1%95%2F</url>
    <content type="text"><![CDATA[此类问题是否有解定义一个东西先定义此类问题矩阵的逆序数的和值为除去0以外其他数的排列(把二维一行行地读取的循序的排列)的逆序数和 发现一我们可以发现排列中相邻的两个数交换位置会它们两相互之间的逆序数值,而其他部分以及他们各自和其他部分的逆序数值都不变,所以矩阵的逆序数+1或-1,也就是矩阵的逆序数的奇偶性发生了改变 发现二我们还可以发现0左右移动不影响矩阵的逆序数的奇偶性，然而如果是上(下)移动的话，就想到于一个数连续和左(右)边3个数进行了交换位置，所以矩阵的逆序数的奇偶性会变 发现三矩阵的改变只能通过与0变换位置，所以只有在与0上下交换的时候才会产生矩阵的逆序数的奇偶性的变化 结论所以我们知道最终状态逆序数为0,且最后0在最后一行(高中学化学经常讲终态法)，也就是矩阵要有解，最终逆序数的奇偶性为偶，那么就要在初始状态的逆序数上面 加上 0值在初始状态移动到最后一行产生的逆序数奇偶性的变化值仍为偶数则有解 题目有解性题HDU-6620 2019杭电多校4 手写AC代码1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int T,a[16];int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;T; while(T--)&#123; int cnt = 0; for(int i=0;i&lt;16;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;16;i++)&#123; if(!a[i])&#123; cnt+=3-i/4; &#125; else&#123; for(int j=0;j&lt;i;j++)&#123; if(a[j] &amp;&amp; a[j]&gt;a[i]) cnt++; &#125; &#125; &#125; if(cnt&amp;1) cout&lt;&lt;"No"&lt;&lt;endl; else cout&lt;&lt;"Yes"&lt;&lt;endl; &#125; return 0;&#125; 求最少步数如果我们要求解步数的话,我们首先是用逆序数进行判定是否有解，有解才进行搜索 使用曼哈顿距离递减 和 IDA*(迭代层数达到120层就放弃) 的方式曼哈顿是初始排列到目标排列每个数字abs(x1-x2)+abs(y1+y2)的和值 给个板子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/*先用结论判断是否有解呀！不然没解跑这个会死循环，燃烧你的CPU的话我不背锅哦 */#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;//limit全部的曼哈顿距离之和int map[4][4], map2[16], limit;int flag, length;//各个数字应在位置(i,j)对照表,比如0在位置(3,3)int goal[16][2] = &#123;&#123;3,3&#125;,&#123;0,0&#125;,&#123;0,1&#125;,&#123;0,2&#125;, &#123;0,3&#125;,&#123;1,0&#125;,&#123;1,1&#125;,&#123;1,2&#125;, &#123;1,3&#125;,&#123;2,0&#125;,&#123;2,1&#125;,&#123;2,2&#125;, &#123;2,3&#125;,&#123;3,0&#125;,&#123;3,1&#125;,&#123;3,2&#125;&#125;;int nx[4][2] = &#123; &#123; -1, 0 &#125;, &#123; 0, -1 &#125;, &#123; 0, 1 &#125;, &#123; 1, 0 &#125; &#125;;//估价函数,曼哈顿距离,小于等于实际总步数int hv(int a[][4])&#123; int cost = 0; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; int w = map[i][j]; // 不算0 if (w != 0) cost += abs(i - goal[w][0]) + abs(j - goal[w][1]); &#125; &#125; return cost;&#125;/* x,y起始坐标，len是已经走过的长度,pre_move是上次走的方向 */void dfs(int x, int y, int len, int pre_move)&#123; if (flag) return; int dv = hv(map); if (len == limit) &#123; //成功 退出 if (dv == 0)&#123; flag = 1; length = len; return; &#125; else //超过预设长度 回退 return; &#125; for (int i = 0; i &lt; 4; i++) &#123; //不和上一次移动方向相反,对第二步以后而言 if (i + pre_move == 3 &amp;&amp; len &gt; 0) continue; int tx = x + nx[i][0]; int ty = y + nx[i][1]; if (tx &gt;= 0 &amp;&amp; tx &lt; 4 &amp;&amp; ty &gt;= 0 &amp;&amp; ty &lt; 4) &#123; swap(map[x][y], map[tx][ty]); int p = hv(map); if (p + len &lt;= limit &amp;&amp; flag == 0) &#123; dfs(tx, ty, len + 1, i); if (flag) return; &#125; /* 递归回来后恢复现场 */ swap(map[x][y], map[tx][ty]); &#125; &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--) &#123; int x1, y1; //map2一维 map二维 for (int i = 0; i &lt; 16; i++)&#123; scanf("%d", &amp;map2[i]); if (map2[i] == 0) &#123; x1 = i/4; y1 = i%4; map[x1][y1] = 0; &#125; else &#123; map[i/4][i%4] = map2[i]; &#125; &#125; /* 曼哈顿长度要递减的 */ limit = hv(map); flag = 0; length = 0; //要求120步之内到达,其实如果可以的话最多80多步就可以走完 while (flag == 0 &amp;&amp; length &lt;= 90)&#123; //得到的是最小步数 dfs(x1, y1, 0, 0); /* 加大初始额曼哈顿距离的限制，让递归的行走能不曼哈顿距离递减得多试探几步 */ if (flag == 0) limit++; &#125; // if (flag) // printf("%d\n", length); if(flag) cout&lt;&lt;"Yse"&lt;&lt;endl; else cout&lt;&lt;"No"&lt;&lt;endl; &#125; return 0;&#125; 后续不好意思，写完后才发现重复造轮子了，不过应该我写得应该算比较简单，可以立马用上吧]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>逆序数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[priority_queue和multiset异同以及线段树空树插入维护初见]]></title>
    <url>%2F2019%2F07%2F30%2Fpriority-queue%E5%92%8Cmultiset%E5%BC%82%E5%90%8C%E4%BB%A5%E5%8F%8A%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%A9%BA%E6%A0%91%E6%8F%92%E5%85%A5%E7%BB%B4%E6%8A%A4%E5%88%9D%E8%A7%81%2F</url>
    <content type="text"><![CDATA[priority_queue和multiset异同优先级队列只能按照排序顺序访问一个元素 - 即，可以获得最高优先级的项目，想要访问其他的元素，就必须删除顶端元素。 优先级队列还允许重复元素，因此它很像是一个multiset。 但是multiset比priority_queue的好处就在于multiset不用删除掉优先级最高的元素就可以访问其他优先级的元素，就相当于一个动态的有序数组 同为log(n)插入，但是multiset却能访问更多，真香 虽然priority_queue可以通过删除再恢复的方式达到访问其他优先级的元素，但是实现很不优雅，而且让一个log(n)的操作蹩脚地魔改成了接近O(n^2)的操作，并且容易卡时间 比如HDU-6609这一题暴力priority_queue虽然我很不愿意把我很喜欢的一种STL加上暴力的前缀，但是确实是很朴素自然，大道至简但是这里有点过分使用了…所以下面是TLE的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=1000000007;const int inf = 0x3f3f3f3f;const int M = 2e5 + 7 ;int Q, n, m, w[M];ll sum;int k;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pre;priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; q;int main()&#123; ios::sync_with_stdio(false);cin.tie(0); cin&gt;&gt;Q; while(Q--)&#123; /* init */ sum = 0;k=0; while(!q.empty()) q.pop(); while(!pre.empty()) pre.pop(); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i]; for(int i=1;i&lt;=n;i++)&#123; /* 根据题意不能弹出本次加入的 */ /* 根据题意应该不会在空的时候满足条件 */ // int pre=inf; /*每弹出一个k++,所以每回收pre一个k--*/ // while(!pre.empty()) pre.pop(); while(!q.empty()&amp;&amp;sum+w[i]&gt;m)&#123; k++; pre.push(q.top()); sum-=q.top(); q.pop(); &#125; /*输出*/ cout&lt;&lt;k&lt;&lt;" "; if(i==n)&#123; cout&lt;&lt;endl; break; &#125; /*回溯*/ ll tmp = 0; /* = 再想想*/ bool f=0; while(!pre.empty()&amp;&amp;tmp+pre.top()&lt;=w[i])&#123; f=1; tmp += pre.top(); q.push(pre.top()); k--; pre.pop(); &#125; /*能加入一个就无需加本身了,要加回之前的sum值 本身未加入的话就相当于弹出了一个k++*/ /*不对,加回本身,让其在后面的循环中进入pre*/ // if(f) sum += tmp,k++; if(f) sum += tmp; q.push(w[i]); sum += w[i]; &#125; &#125; return 0;&#125; multiset12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;const int maxn = 2e5 + 10;int a[maxn];multiset&lt;int&gt; ss;int main()&#123; int t; scanf("%d", &amp;t); while (t--) &#123; ss.clear(); long long int n, m; scanf("%lld%lld", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;a[i]); &#125; long long int sum = 0; int tem = 0; for (int i = 0; i &lt; n; i++) &#123; long long int suma = sum; int jishu = 0; if (suma + a[i] &gt; m) &#123; auto j = ss.end(); /* 这里用计数jishu记下软删除的数量，由于priority_queue 只能访问第一个值，所以不支持软硬删除操作...所以会用真实删除再 恢复的操作会TLE...因为这样会从O(nlog(n))魔化到O(n^2) */ /* 由题意a[i]&lt;=m，满足下面条件时一定不会出现ss为空 */ while (suma + a[i] &gt; m) &#123; j--; suma -= *j; jishu++; &#125; &#125; /* 第一个铁定是0的 */ printf("%d ", jishu + tem); ss.insert(a[i]); auto j = ss.end(); sum += a[i]; /* 用tem记录下硬删除的数量 */ while (sum &gt; m) &#123; j--; sum -= *j; /* 这里由于find返回的是指针，所以就会只删除一个值 而不是删除数值那样把所有数值都删除掉 */ ss.erase(ss.find(*j)); tem++; &#125; &#125; printf("\n"); &#125;&#125; 线段树树空树插入维护初见这个线段树标程真是魔鬼一般地折磨了我整整7个小时…菜鸡刚学线段树，还没有过插入空树的经历，然后这个std是插入空树…我好菜啊 所以放一发带思考注释的手抄代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;using namespace std;#define mod 1e9+7#define ll long longconst int M = 2e5+7;ll int a[M],number[M&lt;&lt;2],bz[M&lt;&lt;2];int number2[M&lt;&lt;2],bz2[M&lt;&lt;2],to[M];struct node&#123; int id; ll b;&#125; no[M];bool cmp(node a,node b)&#123; return a.b==b.b ? a.id&lt;b.id : a.b&lt;b.b;&#125;/* 自己重写std感觉上推数值好像还是不对，如果不理解的话，下次就算有板子也不能秒掉！所以还是要先理解一下 ，多多重现算法*//* 先写着，等下写完全部看看有没有新的认识 *//* 2019年7月30日16:59:35 还是不懂，维护区间之和难道不是要左右相加吗？2019年7月30日20:34:57 突然灵光一闪！因为你一开始是一棵空树，然后你一个个插入，如果使用的是max，就相当于(to[i],n+1)这个区间以及每个子区间都是你的插入值的和. 因为都是直接到了叶子节点去加和如果使用加法，那么就出错了，就有很多重复计算，所以说[1-&gt;n]区间就是最大的前缀和所以询问的时候就可以直接加和*/void PushUp(int rt)&#123; number[rt] = max(number[rt&lt;&lt;1],number[rt&lt;&lt;1|1]);&#125;/* 其实这里是多组测试的初始化0值 *//* 但是number2不PushUp清零吗？这里好像有问题，但为什么std能AC惊呆的发现竟然放在了pushdown下推标记的时候清零了...感觉线段树的写法真多*/void build(int l,int r,int rt)&#123; bz[rt]=bz2[rt]=number[rt]=0; if(l==r)&#123;number2[rt]=0;return;&#125; int mid = (l+r)&gt;&gt;1; build(l,mid,rt&lt;&lt;1); build(mid+1,r,rt&lt;&lt;1|1); PushUp(rt);&#125;void pushdown(int l,int r,int rt)&#123; if(bz[rt])&#123; bz[rt&lt;&lt;1] += bz[rt]; bz[rt&lt;&lt;1|1] += bz[rt]; number[rt&lt;&lt;1] += bz[rt]; number[rt&lt;&lt;1|1] += bz[rt]; bz[rt] = 0; &#125; if(bz2[rt])&#123; bz2[rt&lt;&lt;1] += bz2[rt]; bz2[rt&lt;&lt;1|1] += bz2[rt]; number2[rt&lt;&lt;1] += bz2[rt]; number2[rt&lt;&lt;1|1] += bz2[rt]; bz2[rt] = 0; &#125;&#125;void change(ll o,int L,int R,int l,int r,int rt)&#123; if(L&gt;R) return; if(l==r)&#123; number[rt]+=o; /* 之前初始化成了0，所以这里可以这样...这个标程写得真随意... */ number2[rt]+=1; return ; &#125; /* 此节点(区段l,r)全被包含在内 */ if(L&lt;=l &amp;&amp; r&lt;=R)&#123; /* 先自己赋值，下推标记就直接给儿子赋值 */ number[rt]+=o; bz[rt]+=o; bz2[rt] += 1; return ; &#125; int mid = (l+r)&gt;&gt;1; /* pushdown和PushUp都只管修改相邻层 */ pushdown(l,r,rt); /* 区段l,r包含L,R,或者有交叠,则访问子节点(子区段) */ if(L&lt;=mid) change(o,L,R,l,mid,rt&lt;&lt;1); if(R&gt;mid) change(o,L,R,mid+1,r,rt&lt;&lt;1|1); PushUp(rt);&#125;ll query(ll k,int l,int r,int rt)&#123; if(l==r) return number2[rt]; int mid = (l+r)&gt;&gt;1; pushdown(l,r,rt); int ans; if(k &lt; number[rt&lt;&lt;1]) ans = query(k,l,mid,rt&lt;&lt;1); else ans = query(k,mid+1,r,rt&lt;&lt;1|1); PushUp(rt); return ans;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); build(1,n+1,1); for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;a[i]); no[i].b = a[i]; no[i].id = i; &#125; sort(no+1,no+n+1,cmp); /* 把与n+1有关的节点都打上number=1e9,number2=1的标记... 只给n+1对应的叶子节点处打上了标记！其他地方没有进去过！ 就相当于在那里插入了一点*/ change(1e9,n+1,n+1,1,n+1,1); for(int i=1;i&lt;=n;i++) to[no[i].id] = i; for(int i=1;i&lt;=n;i++)&#123; /*一个个插入,第一个时还没插入，是空树，所以肯定返回0*/ ll k = query(m-a[i],1,n+1,1); printf("%lld ",i-k); /*按照队友的说法,那这里就是插入第一个*/ /* 给排名在to[i]到n+1的地方都所有区段打上区间数值和number 和此区间个数和number2 */ change(a[i],to[i],n+1,1,n+1,1); &#125; puts(""); &#125; return 0;&#125; 借鉴: C++&amp;STL&amp;multiset&amp;杭电多校第三场 1007 find the answer]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>线段树</tag>
        <tag>STL</tag>
        <tag>优先队列</tag>
        <tag>multiset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AcWing-245.你能回答这些问题吗]]></title>
    <url>%2F2019%2F07%2F30%2FAcWing-245-%E4%BD%A0%E8%83%BD%E5%9B%9E%E7%AD%94%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%E5%90%97%2F</url>
    <content type="text"><![CDATA[背景2019牛客杭电多校都把线段树当做最最最基础的知识点，杭电3甚至把线段树当做签到，所以线段树要多练啊 题目你能回答这些问题吗 算法线段树入门题 O(Mlog(N))一步步思考线段树过程关键点不能简单的对比对比左右子区间的dat和值(区间最大和值)来更新本节点的区间最大和值，还要对比右子树的rmax+左子树的lmax的和值 c.dat=max(max(a.dat,b.dat),a.rmax+b.lmax); 附图可以参考，关键看代码注释 手写AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int SIZE = 5e5+7;struct SegmentTree&#123; int l,r; int lmax,rmax,sum; int dat;&#125; t[SIZE&lt;&lt;2];int a[SIZE],N,M;void pushup(int p)&#123; t[p].sum = t[p*2].sum + t[p*2+1].sum; t[p].lmax = max(t[p*2].lmax,t[p*2].sum+t[p*2+1].lmax); t[p].rmax = max(t[p*2+1].rmax,t[p*2+1].sum+t[p*2].rmax); t[p].dat = max(t[p*2].dat,max(t[p*2+1].dat,t[p*2].rmax+t[p*2+1].lmax));&#125;void build(int p,int l,int r)&#123; t[p].l=l,t[p].r=r; if(l==r)&#123; t[p].sum=t[p].lmax=t[p].rmax=t[p].dat=a[l]; return ; &#125; int mid = (l+r)/2; build(p*2,l,mid); build(p*2+1,mid+1,r); pushup(p);&#125;void change(int p,int x,int v)&#123; if(t[p].l==t[p].r)&#123;t[p].dat=t[p].sum=t[p].lmax=t[p].rmax=v;return ;&#125; int mid = (t[p].l+t[p].r)/2; if(x&lt;=mid) change(p&lt;&lt;1,x,v); else change(p&lt;&lt;1|1,x,v); pushup(p);&#125;// int ask(int p,int l,int r)&#123;// if(l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) return t[p].dat;// int mid = (t[p].l + t[p].r)/2;// int val = -(1&lt;&lt;30);// if(l&lt;=mid) val = max(val,ask(p&lt;&lt;1,l,r));// if(r&gt;mid) val = max(val,ask(p&lt;&lt;1|1,l,r));// return val;// &#125;/* 此处感谢队友帮忙debug */SegmentTree ask(int p,int l,int r)&#123; if (l&lt;=t[p].l &amp;&amp; r&gt;=t[p].r) return t[p]; int mid=(t[p].l+t[p].r)&gt;&gt;1; int val=-(1&lt;&lt;30); SegmentTree a,b,c; a.dat=a.sum=a.lmax=a.rmax=val; b.dat=b.sum=b.lmax=b.rmax=val; c.dat=c.lmax=c.rmax=val; c.sum=0; /* 要么都在最左边，要么都在最右边，要么跨越了左右，跨越了左右就要判断 c.dat=max(max(a.dat,b.dat),a.rmax+b.lmax); 这个点没想到会卡住 --&gt; 我就是从前面的注释的ask函数出错来的*/ if (l&lt;=mid&amp;&amp;r&lt;=mid)&#123; a=ask(p&lt;&lt;1,l,r); c.sum+=a.sum; &#125; /* 还要注意左区间r&lt;=mid,右区间l&gt;mid */ // else if (l&gt;=mid&amp;&amp;r&gt;=mid)&#123; else if (l&gt;mid&amp;&amp;r&gt;mid)&#123; b=ask(p*2+1,l,r); c.sum+=b.sum; &#125; else&#123; a=ask(p&lt;&lt;1,l,r); b=ask(p*2+1,l,r); c.sum+=a.sum+b.sum; &#125; c.dat=max(c.dat,max(max(a.dat,b.dat),a.rmax+b.lmax)); c.lmax=max(c.lmax,max(a.lmax,a.sum+b.lmax)); c.rmax=max(c.rmax,max(b.rmax,b.sum+a.rmax)); return c;&#125;int main()&#123; ios::sync_with_stdio(false);cin.tie(0); cin&gt;&gt;N&gt;&gt;M; for(int i=1;i&lt;=N;i++) cin&gt;&gt;a[i]; build(1,1,N); int i,x,y; while(M--)&#123; cin&gt;&gt;i&gt;&gt;x&gt;&gt;y; if(i==1)&#123; if(x&gt;y) swap(x,y); cout &lt;&lt; ask(1, x, y).dat &lt;&lt; endl; &#125; else change(1,x,y); // for(int i=1;i&lt;=9;i++)&#123; // cout&lt;&lt;"dat: "&lt;&lt;t[i].dat&lt;&lt;" sum: "&lt;&lt;t[i].sum&lt;&lt;" lmax: "&lt;&lt;t[i].lmax&lt;&lt;" rmax: "&lt;&lt;t[i].rmax&lt;&lt;endl; // &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[银联挑战赛初赛第二场B题]]></title>
    <url>%2F2019%2F07%2F28%2F%E9%93%B6%E8%81%94%E6%8C%91%E6%88%98%E8%B5%9B%E5%88%9D%E8%B5%9B%E7%AC%AC%E4%BA%8C%E5%9C%BAB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目题目链接码队弟弟的求和问题 题面 题解思路 数论分块知识点图片截取了大佬的blog 手写AC代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll mod = 1e9+7;ll n,m;ll inv6;ll qpow(ll a,ll b)&#123; ll res = 1; while(b)&#123; if(b&amp;1) res = res*a%mod; a = (a*a)%mod; b&gt;&gt;=1; &#125; return res;&#125;ll f(ll n)&#123; return n*(n+1)%mod*(2*n+1)%mod*inv6%mod;&#125;ll solve(ll n)&#123; ll ans = (n*(n+1)/2%mod)*n; // ll ans = n*n%mod*(n+1)/2%mod; for(int i=1,j;i&lt;=n;i=j+1)&#123; /*i=j+1,以及n/i要加括号*/ j = n/(n/i); /*其实j不会大于n*/ if(j&gt;n) j=n; ans = (ans - (f(j)-f(i-1))*(n/i)%mod + mod)%mod; /*只要保证每次相减时两个都是正数 然后结果再来一次保证正数操作就不会出错*/ &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); inv6 = qpow(6,mod-2); cin&gt;&gt;n&gt;&gt;m; ll ans = solve(n)*solve(m)%mod; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 菜鸡我踩坑坑我35mins123// bug是因为除号必须在mod前！ll ans = (n*(n+1)/2%mod)*n;// ll ans = n*n%mod*(n+1)/2%mod;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第14周-14-521]]></title>
    <url>%2F2019%2F07%2F27%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC14%E5%91%A8-14-521%2F</url>
    <content type="text"><![CDATA[Algorithmgogogo ReviewDo You Really Need Another Computer Monitor? 是啊，对于单一的工作，没有很多要素的工作一个屏幕就够了 但是对于需要很多要素的工作，比如一边看编程视频教学，一边跟着写这种要素很多的工作，有两个屏幕真的能提高自己的效率 Tips线段树从零开始 线段树详解 Share2019牛客多校3 I]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客多校3 I]]></title>
    <url>%2F2019%2F07%2F26%2F2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A13-I%2F</url>
    <content type="text"><![CDATA[题目题目链接Median 题意3个数产生一个中位数，现在给你一串中位数，请还原出一个合理的原串 InputT组,每组给n表示原串的长度,然后是给你中位数串b[1]-&gt;b[n-1] 范围: n的和不超过10^6,每个b不超过10^9 Output有合理的串则输出原串,否则输出-1 题解结论若存在合理的解,那么解的每个位置的最终值一定是它能影响到的3个中位数之一 证明 Dp解法 自己动手写AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;const int M = 1e5+7;bool f[M][3][3];int pre[M][3][3];int v[M][3];int b[M],a[M];int T,n;int mid(int x,int y,int z)&#123; static int tmp[3]; tmp[0]=x,tmp[1]=y,tmp[2]=z; sort(tmp,tmp+3); return tmp[1];&#125;/*回溯构造*/void back(int i,int j,int k)&#123; while(i&gt;=1) &#123; a[i] = v[i][j]; int pr = pre[i][j][k]; j = k; k = pr; i--; &#125;&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); for(int i=2;i&lt;=n-1;i++) scanf("%d",&amp;b[i]); /*init*/ b[0]=b[1]=b[2]; b[n+1]=b[n]=b[n-1]; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;3;j++) for(int k=0;k&lt;3;k++) f[i][j][k]=false; /*注意:我给的手写题解中a[3]对应b[1],b[2],b[3] 我这里为了实现方便是用的对应b[2],b[3],b[4]*/ for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;3;j++)&#123; v[i][j]=b[i-1+j]; &#125; sort(v[i],v[i]+3); &#125; /*边界条件: 前i-2个中位数(此时i=2为0个中位数)是满足条件的 最终f[N][i][j]的时候的是N-2个中位数是否满足条件*/ for(int i=0;i&lt;3;i++) for(int j=0;j&lt;3;j++) f[2][i][j]=true; /*solve*/ bool findans = false; for(int i=3;i&lt;=n;i++)&#123; for(int j=0;j&lt;3;j++)&#123; for(int k=0;k&lt;3;k++)&#123; for(int l=0;l&lt;3;l++)&#123; if(!f[i-1][k][l]) continue; /*判断前面的位置和本位置使用与他们位置相关的 3个中位数的排列中哪些排列能够满足要求 v[i][j]对应的是b[i-1],b[i],b[i+1]中的一个*/ if(mid(v[i-2][l],v[i-1][k],v[i][j])!=b[i-1]) continue; f[i][j][k]=true; /*记录下前面使用的是l大的*/ pre[i][j][k]=l; /*break写完再探索-std中用了break 我认为应该遍历全部情况,所以去掉了break 然后两份代码都AC了,所以可能解唯一或者是按照std 生成的数据吧*/ // break; &#125; if(i==n &amp;&amp; f[i][j][k])&#123; findans = true; back(i,j,k); goto END; &#125; &#125; &#125; &#125; END: if(!findans) printf("%d\n",-1); else&#123; for(int i=2;i&lt;n;i++) &#123; assert(mid(a[i-1],a[i],a[i+1]) == b[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; printf("%d%c",a[i]," \n"[i==n]); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>多校</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第13周-13-521]]></title>
    <url>%2F2019%2F07%2F22%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC13%E5%91%A8-13-521%2F</url>
    <content type="text"><![CDATA[Algorithm牛客多校中一题 ReviewRule of Three: Bad Ideas, Arguments and Brainstorming When you do a brainstorm to solve a problem or generate an idea, you’ll always experience two sides. First you flare to generate as many ideas as possible. Then you focus to decide on the one path that you’re actually going to execute on. 确实,做决定的时候要好好选择,别人批评,自己选择,选择好然后专注做下去,自己负责 Tips我再也不装扮博客了 那我也不装了 Share2019牛客多校第一场补题笔记 2019牛客多校第二场补题笔记]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客多校第二场补题笔记]]></title>
    <url>%2F2019%2F07%2F21%2F2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%8C%E5%9C%BA%E8%A1%A5%E9%A2%98%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[题目链接2019牛客多校第二场 background出题人:sd0061赵轩昂，北京航空航天大学，WorldFinal 2015/2016 Eddy好像就是出题人的电脑用户名 出题评价题目对我这个菜鸡来说较难，题意复杂 讲题评价逻辑清晰，对每一题的讲解由浅入深，对时间复杂度不断优化精细讲解，层层入深，获得大家的一致好评(只是目前我这个菜鸡对于很多浅的地方还没学好甚至还没学过，所以补补补o(╥﹏╥)o) A题意 Eddy大佬走路 先让0-&gt;N-1都有标记 -&gt; 第i天走一圈需要Ni步(每天脚长不一样还行),可以前进和后退,然后收集完所有标记(每个地方都有标记,即0-&gt;N-1处都是标记)就立马感到无聊了就立马回去吃饭睡觉打豆豆(你的记录值中Eddy大佬走到Mi就算是收集完了所有的标记) 你每天观摩大佬走路(giao) 你复查数据的时候，你不确定到底数据是不是对的，然后你想知道这些天的数据正确的可能性(所以很自然的知道后面为什么要你输出前缀积,原来写笔记确实可以加深理解奥) input T组测试(T天的观测) 然后每组测试都是给你Ni和Mi(每天Eddy的走路信息) Output 输出前i天的数据都正确的可能性(也就是每天可能性之积) 思路 Corner Case: 当N=1的时候，也就是1步就可以走完一圈，无论Eddy大佬前进还是后退，肯定是1步走完(这样肯定收集完了所有的标记),所以可能性为1 当M=0的时候，你记录的是Eddy大佬在0处就收集完了所有的标记,这是不可能，因为Eddy大佬一开始从0出发，所以一开始就已经拥有0号标记了,而一旦Eddy收集完所有的标记之后必定会立马回家,所以离开的地方的那个标记一定是最后收集到的,而且是第一次收集到的那个标记，所以你记录值为0显然是错的,所以可能性是0 一般情况(N非1,M非0) 有了上面M=0的理解，这里就好理解了，因为Eddy大佬一开始从0出发,然后Eddy大佬可以前进也可以后退，所以Eddy大佬最后一个到达的点可以是非0的其他任意一个点，所以最后到达每个点的可能性都是等概的，也就是1/(N-1) 对了，输出的是前i的概率积 AC代码(自己再手写一遍收获更多)1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int mod = 1e9+7;int T,n,m;ll ans;ll mul(ll a,ll b)&#123; a *= b; return a&gt;=mod?a%mod:a;&#125;ll qpow(ll a,ll b)&#123; ll ret = 1; while(b)&#123; if(b&amp;1) ret = mul(a,ret); /* b&gt;&gt;1,那么a就要变成a*a */ b&gt;&gt;=1; a = mul(a,a); &#125; return ret;&#125;ll inv(ll a)&#123; return qpow(a,mod-2); &#125;ll solve(ll n,ll m)&#123; if(n==1) return 1; if(m==0) return 0; return inv(n-1);&#125;int main()&#123; ios::sync_with_stdio(false); /*init*/ ans = 1; cin&gt;&gt;T; while(T--)&#123; cin&gt;&gt;n&gt;&gt;m; /*solve*/ ans = mul(ans,solve(n,m)); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; Bemmmm,看懂了一点点题解,但是对于题解中的BM完全不熟悉,所以先留坑 C,D自己太菜了,留坑Eemmmm,看懂了一点点题解,但是还是不太熟悉基础的算法,我先去补基础的算法,留坑 F题意给定2N个人,(N &lt;= 14),两两间有边权,把这2N个人分为2组,每组N个,求两组间的边权和最大 题解朴素法(也称暴力法),在新加入一个人的时候，比如说加入了A组，那么直接将它与B组间已经有的所有人的边权加一遍 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int M = 50;int d[M][M];int a[M],b[M];int cnt1,cnt2;ll ans;int N;void dfs(int cur,ll val)&#123; /*当达到2*N+1的时候,正好已经插入了2*N个人了,所以开始比较*/ if(cur&gt;2*N)&#123; ans = max(ans,val);return ;&#125; if(cnt1&lt;N)&#123; a[cnt1++]=cur; ll tmp = 0; /*每次加入了cnt1之后,就要把左边队伍新加人与对面队伍当下所有人产生的竞争值加入左边队伍*/ for(int i=0;i&lt;cnt2;i++) tmp+=d[cur][b[i]]; dfs(cur+1,val+tmp); /*上面的遍历return之后要恢复现场,即之前产生的影响要消除掉,避免对后面的操作有影响*/ cnt1--; &#125; if(cnt2&lt;N)&#123; b[cnt2++]=cur; ll tmp = 0; /*每次加入了cnt2之后,就要把右边队伍新加人与对面队伍当下所有人产生的竞争值加入右边队伍*/ for(int i=0;i&lt;cnt1;i++) tmp+=d[a[i]][cur]; dfs(cur+1,val+tmp); cnt2--; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;N; for(int i=1;i&lt;=2*N;i++) for(int j=1;j&lt;=2*N;j++) cin&gt;&gt;d[i][j]; ans = 0; /*像一颗树一样遍历下去,然后到达叶子的时候进行比较出最大值再返回*/ dfs(1,0); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; G计算几何,留坑H题意给定一个N*M的01矩阵(1&lt;=N,M&lt;=1000),求第二大全是1的矩阵面积 题解 枚举每一行，以当前行为底，记录每一列往上不间断最多延长多远，那么这样之后就变成了一维的柱状图求最大/次大/k大矩形面积，可用单调栈求解 由于要记录第二大,之前求最大的做法(poj2559)是直接用max维护ans,width合并的做法在这里就要改成把所有解先丢进一个vector(之后排序复杂度 ans个数 * log(ans个数))(或者维护一个k大的小值优先的priority_queue,复杂度算上维护也是ans个数 * log(ans个数)) 但是这里必须把(width-1)*ddz[top]也放入状态级,因为求第二大,所以只要把次大状态加入(详细原因看下面说的坑点) 所以推荐使用把全状态扔进vector，这样还可以求第k大，虽然慢点 坑点图中最后一行样例的dp的单调栈这里是小于也没有用，因为1会占据掉3的宽度，而且仍为高度1，之后就在0到来的时候累加宽度 (宽度直接从4加到了6，跳过了5,因为1之前会占据掉3的宽度)，然后就会无视掉矩阵面积是5的情况！！！ 所以用width会导致状态数减少，这里求第二大可以把width-1的状态也加入，从而达到正确答案并减少了一定状态数 不过还是推荐使用全状态，就是用cnt++，把所有状态放入vector，这样就可以求出第k大 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/*5 1001001011000010110110100001111010001100101111110010*/#include&lt;bits/stdc++.h&gt;using namespace std;const int M = 1e3+5;int dp[M][M];int ddz[M],w[M];vector&lt;int&gt; ans;int n,m;void solve(int *f)&#123; int top = 0; ddz[top] = -1; f[m+1] = -1; for(int i=1;i&lt;=m+1;i++)&#123; /*等于时是否弹出这需要自己注意一下,就是严不严格单调的选择*/ if(ddz[top]&lt;f[i]) ddz[++top]=f[i],w[top]=1; else&#123; int width = 0; /*此处注意要先加宽度*/ while(top&amp;&amp;f[i]&lt;ddz[top])&#123; width+=w[top],ans.push_back(ddz[top]*width),ans.push_back(ddz[top]*(width-1));top--;&#125; /*我的做法是 : 等于是加入,不严格单调*/ ddz[++top]=f[i],w[top]=width+1; &#125; /*推荐下面的方法*/ // if(ddz[top] &lt;= f[i]) ddz[++top] = f[i]; // else &#123; // int cnt = 0; // /*然后这里可以写宽度进行优化*/ // while(top &amp;&amp; ddz[top] &gt; f[i]) &#123; // cnt++; // ans.push_back(ddz[top] * cnt); // top--; // &#125; // while(cnt--) ddz[++top] = f[i]; // ddz[++top] = f[i]; // &#125; &#125;&#125;int main()&#123; char c[M]; while(~scanf("%d%d",&amp;n,&amp;m)) &#123; /*init*/ ans.clear(); for(int i=1;i&lt;=n;i++)&#123; /*对于每一列的每一行进行连续高度扫描*/ scanf("%s",c); /*此行非0,则可以接上上面连续来的高度(可能为0)*/ for(int j=1;j&lt;=m;j++) dp[i][j] = c[j-1] == '0'? 0 : dp[i-1][j]+1; &#125; // for(int i = 1;i&lt;=n;i++) &#123;for(int j=1;j&lt;=m;j++) cout&lt;&lt;dp[i][j]; cout&lt;&lt;endl;&#125; cout&lt;&lt;endl; /*solve*/ /*对每一行进行直方图扫描求解*/ for(int i=1;i&lt;=n;i++) solve(dp[i]); sort(ans.begin(),ans.end()); /*考虑特例*/ int sz = ans.size(); if(sz&lt;=1) printf("0\n"); printf("%d\n", ans[sz-2]); &#125; return 0;&#125; I听Eddy大佬说有7种dp,太难留坑J也太难留坑]]></content>
      <categories>
        <category>算法</category>
        <category>多校</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客多校第一场补题笔记]]></title>
    <url>%2F2019%2F07%2F19%2F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA%E8%A1%A5%E9%A2%98%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[题目链接2019牛客多校第一场 A题题解知道了单调栈，那么第一题就很好解决了，就是两个串到每个位置都比较一下前面的最小值的下标是否相等(用单调栈来实现—后面讲)，如果相等则继续，如果都没有找到就是都是自己最小，也用单调栈处理成为相等，如果遇到不相等，那么i-1就是题目所要求出来的k的值 补充 单调栈单调栈的一大优势就是线性的时间复杂度，所有的元素只会进栈一次，而且一旦出栈后就不会再进来了。 单调递增栈可以找到左起第一个比当前数字小的元素。比如数组 [2 1 4 6 5]，刚开始2入栈，数字1入栈的时候，发现栈顶元素2比较大，将2移出栈，此时1入栈。那么2和1都没左起比自身小的数字。然后数字4入栈的时候，栈顶元素1小于4，于是1就是4左起第一个小的数字。此时栈里有1和4，然后数字6入栈的时候，栈顶元素4小于6，于是4就是6左起第一个小的数字。此时栈里有1，4，6，然后数字5入栈的时候，栈顶元素6大于5，将6移除，此时新的栈顶元素4小于5，那么4就是5左起的第一个小的数字，最终栈内数字为 1，4，5。 1234567891011/* L是输出端，然后s是辅助数组,c是源数组 */void solve(int* c, int* L) &#123; int top = 0; s[0] = node&#123;0, 0&#125;; for(int i = 1; i &lt;= n; i++) &#123; /*找到向左走第一个比它小的数 */ while(top &amp;&amp; s[top].val &gt;= c[i]) top--; L[i] = s[top].id; s[++top] = node&#123;i, c[i]&#125;; &#125;&#125; 参考链接:https://www.cnblogs.com/grandyang/p/8887985.html AC代码代码是队友写的,orz1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int inf = 0x3f3f3f3f;const int maxn = 100000 + 5;struct node &#123; int id; int val; &#125;;int a[maxn], b[maxn];int l1[maxn], l2[maxn];node s[maxn];int n;/* L是输出端，然后s是辅助数组,c是源数组 */void solve(int* c, int* L) &#123; int top = 0; s[0] = node&#123;0, 0&#125;; for(int i = 1; i &lt;= n; i++) &#123; /*找到向左走第一个比它小的数 */ while(top &amp;&amp; s[top].val &gt;= c[i]) top--; L[i] = s[top].id; s[++top] = node&#123;i, c[i]&#125;; &#125;&#125;int main() &#123; while(~scanf("%d", &amp;n)) &#123; for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;b[i]); solve(a, l1); solve(b, l2); int ans = n; for(int i = 1; i &lt;= n; i++) &#123; if(l1[i] != l2[i]) &#123; ans = i-1; // ans = n-1; break; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125; B题看到大佬的分析 C题，D题能力有限，战略计划原因没有补这两题 C题解推荐C题可以看大佬的题解 E题1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;#define MAXN 2000#define MOD 1000000007int n,m;int dp[MAXN+5][MAXN+5];int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; for(int i=0;i&lt;=n+m;i++) for(int j=0;j&lt;=n+m;j++) dp[i][j]=0; dp[0][0]=1; for(int i=0;i&lt;=n+m;i++) for(int j=0;j&lt;=n+m;j++)&#123; if(i+1&lt;=j+n&amp;&amp;j&lt;=i+m) dp[i+1][j]=(dp[i+1][j]+dp[i][j])%MOD; if(i&lt;=j+n&amp;&amp;j+1&lt;=i+m) dp[i][j+1]=(dp[i][j+1]+dp[i][j])%MOD; &#125; printf("%d\n",dp[n+m][n+m]); &#125;&#125; F图片以及思路转载+少量整理+感谢借鉴两位大佬的思路和博文进行整理的，感谢Izayoi_wWAautomaton 题目要求36E，而E = (22/36) S，所以ans = 22 * S 关于三角形的面积，已知三个顶点坐标，我们可以用叉积来求，如ΔABC，S = (1/2) * ( 向量(AB) ✖ 向量(AC) )。 这里要注意，叉积有正有负，最终的答案为11倍叉积的绝对值。 AC代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int inf = 0x3f3f3f3f;const int maxn = 100000 + 5;int main() &#123; ll x1, y1, x2, y2, x3, y3; while(cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3) &#123; ll res = 11*((x1-x2)*(y3-y2)-(y1-y2)*(x3-x2)); if(res &lt; 0) res = -res; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; G,H,I因己太菜先留坑J题解解法一: 直接交叉相乘 解法二: 直接看出题人叉姐的解法 AC代码123456789101112131415#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef __int128 ll;int main() &#123; long long x, a, y, b; while (scanf("%lld %lld %lld %lld", &amp;x, &amp;a, &amp;y, &amp;b) != EOF) &#123; ll p = x; p *= b; ll q = y; q *= a; if (p &gt; q) printf("&gt;\n"); else if (p == q) printf("=\n"); else printf("&lt;\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>多校</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[真的有必要把文章发布到多个平台吗？]]></title>
    <url>%2F2019%2F07%2F16%2F%E7%9C%9F%E7%9A%84%E6%9C%89%E5%BF%85%E8%A6%81%E6%8A%8A%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E5%88%B0%E5%A4%9A%E4%B8%AA%E5%B9%B3%E5%8F%B0%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[如题真的需要把自己的文章发布到多个网站平台吗？比如WordPress，Hexo，CSDN，知乎，简书，博客园，sf，开源中国等等… 说实话，我也不知道具体答案，因为答案总是和个人情况有关的 源起我之前看李自然说的视频，他说自媒体的运营应该全平台覆盖,把公域流量变成自己的私域流量，然后我也就开始了每次写一篇文章就风风火火地把自己的文章发布到自己wordpress，自己的hexo，自己的简书，自己的CSDN，自己的知乎，而且还在自己的关于界面写上了欢迎加我微信，然后一起拉群讨论… 冲突今天，是放暑假的第5天，大家都回家了，当然还有很多巨佬在疯狂地自学，我昨天连续学了3个小时技术，然后做了8个小时的算法，感觉很开心，但是今天上午睡过头，今天下午和晚上因为增强看板娘的事情，以及处理gitee大于上传100M出现了问题导致自己今天到9点都没有刷算法题，然后此时写完一篇博文，准备写算法，然后一想到自己还有4个平台没有上传自己的博文……开始思考自己是不是要把其他的平台停止更新了 取舍 感觉自己并不想通过写个人博客来转化变现，只想自己整理一些东西，然后分享给大家，所以也就不那么想去花太多时间运维什么的了 搞这么多东西其实和我真正要做的人生五件事是完全无关的！所以以后不仅不能花太多时间在这个无关的事情上面，而且还要想见了鬼一样地避开这些事情… 所以以后就用Hexo做笔记的整理与环境搭建的记录，然后值得分享的技术文档就发布到CSDN上面去，因为CSDN越做越好了，而且它的SEO做得最好(怪不得广告多…槽点…不过这也是生命线,无可厚非)，符合我分享给大家的意愿，然后用coding的私人仓库和wordpress小站来做备份… 询问你们怎么取舍的呢？]]></content>
      <categories>
        <category>思索</category>
      </categories>
      <tags>
        <tag>思索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git reset 和 git reset --hard区别]]></title>
    <url>%2F2019%2F07%2F16%2Fgit-reset-%E5%92%8C-git-reset-hard-%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[git reset 和 git reset --hard区别先说知识点 有时候，进行了错误的提交，但是还没有push到远程分支，想要撤销本次提交，可以使用git reset –-soft/hard命令 缺省情况git reset缺省为git reset --soft 二者区别： git reset –-soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可 git reset -–hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容，撤销的commit中所包含的更改被冲掉 我忘了知识点踩坑沙雕认为 当下情况:最新版本的100M压缩包已经在本地删除，但是本地版本库中之前有个版本中还有，所以git push到gitee会被拒收..但是git一定要先传输完前面的版本之后再传后面的修改(所以我要帮git本地仓库手动执行git rm前面版本的文件，或者忘了文件名，通过下面3的复杂的操作，来完成此项操作) 真的不知道怎么去掉本地仓库的4commit，因为去不掉的话就会先向远程库提交超100M文件然后被拒接，所以原地重复… 然后如果git rm 忘了那个压缩包的名字了，所以直接回退版本到昨天的样子，然后再git reflog回来并展示今天的所有修改，git checkout归还所有修改，然后把今天的修改备份，之后再回到昨天的版本库，然后重新提交今天的内容，除了你个超过100M的压缩包 慢慢懂了奇怪，最后一次版本回退又没有删除本地文件，可能是因为恢复过？ 原来是git reset —hard 和 git reset —soft的区别 所以我幸幸苦苦寻找了好久的取消commit而不影响工作区就是git reset —soft 真是汗啊，因为用得少，所以学了又忘了，所以现在踩一遍坑，使得自己更深刻了，也提醒了自己 对于基础知识 还是要多重复，学习多次，不断加深记忆，或者很可能还是会踩坑 参考：https://blog.csdn.net/yangfengjueqi/article/details/61668381]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[makedown写作超方便的图片使用方式]]></title>
    <url>%2F2019%2F07%2F14%2Fmakedown%E5%86%99%E4%BD%9C%E8%B6%85%E6%96%B9%E4%BE%BF%E7%9A%84%E5%9B%BE%E7%89%87%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[序言 写makedown用图片的时候总是在上传图床的时候，以及使用图片链接的时候会感觉有一些麻烦 我以前使用的是，github图床通过手动git上传,然后自己再一个个去打开github的图片的download的页面去获取图片的分享链接—-自己也觉得很麻烦，但是我的小站目标是人在站在，人不在，站希望也还在的战略目标，所以追求的极致的稳定，而不是一时的快速，所以没有使用那些可以直接粘贴上传到免费图床的操作，因为我怕指不定哪一天这种图床没有消息地就倒闭了，那我的数据就这样没了，小站将遭到巨大的打击，所以我还是慢慢使用这种方式用了3个月，知道我听学长说用七牛云太方便了，还能加速网站加载速度，所以我今天也花了许多时间了解七牛云，发现七牛云确实有免费的10G图床和每月10G的加速流量，但是我觉得这样的加速在前期是很好的，不过有个小问题就是你不自定义域名的话到时候可能失效(自定义域名要备案，腾讯云的域名备案又要买腾讯云的服务器…),而且10G对于我的小站战略来说有点不合适，所以就抛弃了，然后无意看到了PicGo+github图床，于是了解了一下，操作了一下，发现是我要找的靓仔啊！ 使用PicGo上传图库下载PicGo在GitHub的最新发布页面下载 博主本人是windows，所以下载的.exe文件直接安装就可以了 配置起来使用官方文档找到GitHub图床配置进行必要的配置 注： 仓库名是用户名/仓库名 指定存储路径是以仓库为根目录的远程仓库存储路径(可以先在本地仓库先创建一个文件夹，然后再文件夹下创建一个readme.md(为什么？看下面的小发现)，然后git push,这样就是设置这个文件夹了) github图床好像是不支持直接自定义域名的,我试过了,如果有朋友知道的希望能告知，谢谢 我的配置 小发现本地文件夹如果没有文件的话，远程仓库对应的这个文件夹是不会生成的，所以以后最好新建文件夹都写一个readme.md 上传图片这个应该大家配置不出问题，这里都会用的 复制链接使用 VScode写makedown使用snippets我发现我的使用了hexo的fancybox3之后，有一个图集的功能，很是炫酷，但是每次图片粘贴要很复杂的输入123&lt;a href=&quot;&quot; data-fancybox=&quot;images&quot;&gt; &lt;img src=&quot;&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/a&gt; 于是我就想到了snippets 预警如果用了除hexo以外的其他平台，请谨慎使用我的snippets代码！因为data-fancybox=&quot;images&quot;这个图集功能只能用在hexo, 但是可以用于其他的snippets啊 配置snippets去官网看配置 贴一下我的配置 12345678910111213"Mypic":&#123; "prefix":[ "pic", "pic-snippets" ], "body": [ "&lt;a href=\"$&#123;1&#125;\" data-fancybox=\"images\"&gt;", "\t&lt;img src=\"$&#123;1&#125;\" width=\"50%\" height=\"50%\" /&gt;", "&lt;/a&gt;", "$0" ], "description": "Use my images fancybox3"&#125;, 开启makedown的snippets使能！其实VScode是默认关掉了makedown的snippets的使能的！但是你却找不到配置，我在网上找了好久，发现一个大神写了出来，可能是他去提交过issue吧,下面开始解决(昨天被这个问题坑了好久) 进入文件-&gt;首选项-&gt;设置-&gt;打开代码配置 进入setting，输入makedown 配置成true，have fun 插曲电脑重启？ 2019年7月14日16:41:04 写了50mins后，电脑自动关机，重启电脑，看着文档白茫茫的一片，内心一万只草泥马在奔腾…去你大爷的本地写作，就连最基本的hexo新建文章后的信息也不给我留，是个狠人！不想写VScode的snippets的写作方式了——&gt; 跑到coding的备份库一看，还有20mins的工作量被保存，还好一点点吧 努力学习，努力赚钱，换一个不会莫名其妙重启的电脑 写作一定要多多保存备份 可以在网站上写makedown，然后把snippets复制粘贴到网上的makedown上面，这样就重分利用了网站的自动及时保存的功能 发现snippets的图集功能不是所有平台的makedown通用的 所以非特殊情况应该以后不会怎么用这个操作 使用PicGo和以前使用git上传的区别上传 picgo 可以直接截图上传，支持重命名 也可以拖动上传 git 只能在全部搞好之后使用命令行一次上传 下载没区别链接 picgo 可以直接复制相册里面的，不用去网页一个个点开 还支持各种格式切换，并且支持自定义 git 只能手动点开网页一个个去找 总结 PicGo确实对自己有帮助，就是链接不用一个个点开网页了 而且上传了的图片也可以按照每次重新设置不同的路径让文件放入不同的路径 git也可以通过先pull的方式继续让本地和远程仓库保持同步 总而言之还是挺好用的]]></content>
      <categories>
        <category>write</category>
      </categories>
      <tags>
        <tag>write</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第12周-12-521]]></title>
    <url>%2F2019%2F07%2F14%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC12%E5%91%A8-12-521%2F</url>
    <content type="text"><![CDATA[Algorithm虽然刷了一些题，写了篇priority_queue入门，但还是太少了呀，下周得好好加油 ReviewHow to define you snippets in VScode? TipsPicGo官方文档 Sharemakedown写作超方便的图片使用方式]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下雪啦(#^.^#)]]></title>
    <url>%2F2019%2F07%2F11%2Ftest%2F</url>
    <content type="text"><![CDATA[下雪啦(#^.^#) The winter is here ,让我们一起超越小姐姐吧 留个纪念 因为比较烧显卡，而且对访问速度影响比较大，所以就关掉了]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[priority_queue使用坑点和题集]]></title>
    <url>%2F2019%2F07%2F09%2Fpriority-queue%E4%BD%BF%E7%94%A8%E5%9D%91%E7%82%B9%E5%92%8C%E9%A2%98%E9%9B%86%2F</url>
    <content type="text"><![CDATA[2019年7月9日23:27:19 更第一波 priority使用pair比较的坑点所以用pair的priority_queue只能使用struct的重载比较，why?! 重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。—-&gt; 所以不能使用node型的priority_queue的函数重载操作符的方法 node可以函数操作符重载 pair不支持重载运算符 priority_queue定义不支持”嵌入式”函数重载的方法，即 priority_queue]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第11周-11-521]]></title>
    <url>%2F2019%2F07%2F07%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC11%E5%91%A8-11-521%2F</url>
    <content type="text"><![CDATA[Algorithm最近难的考试都考完了，整理了一段时间，接下来开始算法刷题冲刺 ReviewVScode remote/ssh#_getting-started 最近下载了VScode Insiders 折腾了一手Remote SSH发现还是有很多坑的 ssh只能密钥连接 ssh只能连接22端口 许多文件都无法打开 许多工作区间都无法建立文件文件夹当然上面3，4也可能是我技术太菜了，对linux的shell管理不太懂，导致自己没有像有些大佬一样建立了命令行的连接,所以最近一直在学linux，等我学完，可能可以捞自己一手 TipsGit学习—&gt;如何通过Shell脚本自动定时将Gitlab备份文件复制到远程服务器?扩展efi分区 Share技术分享git备份wordpress 读书分享怎样成为精力管理的高手-听书有感]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎样成为精力管理的高手-听书有感]]></title>
    <url>%2F2019%2F07%2F07%2F%E6%80%8E%E6%A0%B7%E6%88%90%E4%B8%BA%E7%B2%BE%E5%8A%9B%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E6%89%8B-%E5%90%AC%E4%B9%A6%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[2019年7月2日22:08:39 00 你为什么需要管理精力 各种时间管理 工作法，有一定的改善，但是还是没有根本性的解决问题 时间总是不能扩张的，而时间质量可以扩张，这种就需要精力管理！ 作者发现一个很牛逼的人，就是全职工作者，然后还是学生，还是3个孩子的爸爸！！！然后他就和那个黄同学学习了精力管理！然后就各种人生开挂！！！ 所以学完了前几天的时间管理后，现在开始学习精力管理！那么我也可以成为大佬，成为一个真正的大佬01 精力管理的金字塔模型 精力好不是天分 你只要掌握了方法，你就能锻炼你的精力 金字塔如下 意义感 —&gt; 目标,使命(人为什么活着!)—&gt;&gt;创造美好的生活 注意力 —&gt; 专注,聚焦(很重要,人可控) 情绪 —&gt; 感恩,乐观,兴奋 体能—&gt; 饮食,运动,睡眠,健康 02 怎样设计最佳运动方案 运动是改善体能的最佳方式 —-&gt; 疾病则反之 人有氧运动得越多，这样人的大脑就可以获得更多氧气，这样大脑就反应很快 长期静坐，可能导致死亡 进化论: 好吃懒做的祖先更容易活下来—保留精力 找到喜欢和享受的运动，一周5天，每天30mins-1小时 —- &gt; 脚伤了，可以游泳！ —-&gt; 多多冥想运动的好处 中等强度220-年龄=200*(60-70%)=130 心率达30mins 设定明确的目标，设定具体的时间，运动量的目标 每天走到8000步 反馈！游戏之所以上瘾，是因为反馈快，所以运动一定要反馈 没时间的话，高轻度间歇训练(每天一分钟都可以!) 刷牙可以单腿站立，下蹲 站立的工作 跑步可以了解一个新的城市 放大回来记一下运动量的要求 得到的 高效学习，时间管理，现在又学精力管理，加油，一定可以竞赛，项目，成绩，健康都做好的，加油 2019年7月3日22:45:5503 吃对了，就不会累 睡眠: 昼夜节律 内生平衡节律(睡得久想醒,醒得久想睡) 下午2-3会报警，所以就困 白天多嗮太阳和晚上多睡会,多喝水 想要获得好的精力少吃多餐高碳水化合物，会发饭晕(所以主要控制血糖水平的波动) 少吃多餐 3顿-&gt; 5顿 (早中午少吃主食，多吃蔬菜，间隙可以加水果) 上午补充坚果水果 一天大致安排 早上高蛋白高纤维 上午补充坚果水果 10点-11点 中午6-7分饱,大量蔬菜，或者鸡肉鱼肉高质量蛋白质 下午3-4点 水果坚果，蓝莓草莓等 晚上可以相对多一点碳水化合物，谷物或者杂粮 总结: 少吃多餐，让血糖尽可能保持平衡 吃低糖,营养质量高的食物NQI(食堂营养占比/热量占比)&gt;=1 才好 作者建议 &gt;=2 水果蔬菜 —- 特别是深绿色的蔬菜 加工的 薯片等 + 白米白面都是 NQI&lt;1 的 蛋白质per/碳水化合物percent 约= NQI 多喝水,让身体充分水化缺水带给你疲劳的感觉 —- &gt; 夏困 判断喝水够不够 体重/32 == 55/32 = 1.7 L = 3瓶水 排尿判断—-两小时左右一次,而且尿颜色很浅 咖啡每天4杯内不会死…茶也行但是不要加糖！ 2019年7月4日23:12:1304 睡得好，能提升你的决策水平 1w个小时刻意练习 天才的平均睡眠时间，8小时16mins 和正常人差不多 睡多久合适，成年人7-9小时 如何提高睡眠质量 没事别上床—&gt;建立上床是睡觉的条件反射，醒着躺床上20mins不能入睡就要起床看书，按时起床！每天必须要同一时刻起床，不能赖床 重视白天的活动.日光下的活动更好—可以合成褪黑素(焦虑也会睡不好，就想我那天石膏21天去复查前夜3,4,5,6点都醒过) 睡前做准备:创造入睡的环境和心情(屋子黑暗+睡前别看显示屏),降低身体体温(体温下降过程),加入白噪音(风雨,动物音),让大脑进入睡眠状态(看难的书) 酒精和打鼾,酒精会绕乱深睡眠,呼吸睡眠暂停综合症,打鼾超5s,要去看医生,大脑会缺氧,损伤大脑,高血压等等 2019年7月6日00:41:28 05 击退消磨意志的疾病 坐姿要好 节律饮食 2019年7月7日16:14:03把所有的都学完了，现在直接做总结吧 重温并记住精力管理的金子塔 意义感 —&gt; 目标,使命(人为什么活着!)—&gt;&gt;创造美好的生活 注意力 —&gt; 专注,聚焦(很重要,人可控) 情绪 —&gt; 感恩,乐观,兴奋 体能—&gt; 饮食,运动,睡眠,健康 找到自己的人生意义这要自己不断去尝试，去寻找 注意力和情绪通过呼吸练习和冥想练习来做到[讲真的，我第一练习的时候，我哭了] ==分享给你== 链接：https://pan.baidu.com/s/1wsDsFvFbJNrqIoIYVo-I9Q 提取码：undp]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git备份wordpress]]></title>
    <url>%2F2019%2F07%2F07%2Fgit%E5%A4%87%E4%BB%BDwordpress%2F</url>
    <content type="text"><![CDATA[git备份wordpress登陆网站目录初始化git仓库 并且 与远程仓库对接上传首先使用ssh工具(Xshell或者putty等)登入之后进入到自己wordpress网站的根目录然后初始化仓库git init 在远程coding或gitee上面新建私有仓库上面，土豪可以在在GitHub上面建私有仓库 把自己网站所在的vps的公钥放到coding或gitee的ssh密钥管理里面添加公钥 把本地仓库文件传到远程仓库123456# 一定要把下面的ssh路径改成你的ssh路径啊，然后origin也可以改成其他名字(对应本地对远程的一种称呼)git remote add origin git@git.dev.tencent.com:username/wordpreessbackup.git# git 本地远程推送三连击git add --allgit commit -m "你的注释"git push -u origin master 我们想把数据库也备份怎么办？那就干啊，直接在网站根目录下面执行数据库备份，先来看看数据库备份通用的语句12345678# hostname直接是本机，所以我们不用写# username是我们的数据库的用户名# mypwd是我们的数据库密码# databasename就是要备份的数据名字mysqldump -hhostname -uusername -pmypwd databasename &gt; /path to backup/bakname.sql# 所以我的语句应该是如下，你们也可以看着改动，这些数据的信息可以登陆宝塔面板看，或者找到你以前建网站的时候保存的一些重要信息mysqldump -uwolfdanDB -ppassword wolfdanDB &gt; wolfdanDB2019_7_6.sql 然后就成功了，再次推送到远程即可 如果你出了一些问题可以看这里，否则可以直接看下一步：注: 其实wolfdan我是先犯了下面的错误然后才有上面一条龙正确的，所以下面的这些错误修正意见基本上是说把上面步骤完善好，233 没有生成密钥且不会生成密钥的朋友可以看我以前发的文章，虽然当时写得比较水，但还是能看图解决问题的 更新仓库发现没有访问权限则检查自己有没有做上面 生成密钥 和 添加公钥 上传文件被告知src refspec master does not match any，我们使用git status检查发现是没有git add --all — &gt; 也就是说我们要先本地commit 写bash代码，并且使用crontab定时执行备份 并定时 清理一个月前备份的sql文件(节省内存呀) 如果每次都手动执行，难免会有忘记的时候，而且就算你博闻强识，你不嫌花时间吗？我们的追求当然是全自动化！当然现在不想折腾了可以保存页面下次来继续折腾 写出backup.sh文件—&gt; 当然要把一些变量改成你的 变量值1234567891011121314151617181920212223242526272829303132333435363738#!/bin/bash#this is wherepath=/home/www/wolfdan.cn#数据库名称sqlName=wolfdanDB#用户名称userName=wolfdanDB#用户密码userPasswd=root#当前时间DATE=`date +"%Y-%m-%d"`#Log存放路径LogFile=$path/backupLog/$DATE.log#新建日志文件touch $LogFile#追加日志到日志文件echo "wolfdan.cn git auto backup to coding server, start at $(date +"%Y-%m-%d %H:%M:%S")" &gt;&gt; $LogFileecho "---------------------------------------------------------------------------" &gt;&gt; $LogFile# 原本我以为执行bash会自动把目录切换，直到crond自动检测bash的log文件，并在log文件中告知我没有 .git文件，我才知道要自己手动cdcd $pathmysqldump -u$userName -p$userPasswd $sqlName &gt; wolfdanDB$DATE.sqlgit add --allgit commit -m "`date '+%Y-%m-%d %H:%M:%S'`"git push origin masterecho -e "---Have a nice day in www.wolfdan.cn----welcome to contact me by VX:wolf_dan2--------\n"&gt;&gt; $LogFile 赋予backup.sh执行权限并且测试一下chmod 777 backup.sh sh backup.sh 我自己之前bash没写好出现的一些问题bash变量赋值不能为空 数据库名称和密码什么的不能出错使用crontab定时vim /etc/crontab 没有vim可以sudo apt-get install vim(Debian/Ubuntu用户)-sudo yum install vim(CentOS用户)下载或者暂时用 vi 代替在注释下面添加你要的任务就行1234567891011121314151617181920SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed# 我的wolfdan.cn 每周备份0 3 * * 0 root /home/www/wolfdan.cn/backup.sh# 自动删除一个月前的sql，下周git的时候会同步到云端删除0 4 * * 0 root /home/www/wolfdan.cn/auto_rm.sh 重载配置并启让配置生效1234#重新加载cron配置文件sudo /usr/sbin/service cron reload#重启cron服务sudo /usr/sbin/service cron restart crontab测试和auto_rm.sh放一起了，所以不妨继续往下看写auto_rm.sh文件编码bash文件一定要小心写cpp时的习惯性变量赋值的空格！1234567891011121314151617181920212223#!/bin/bash# 路径Dir=/home/www/wolfdan.cn#当前时间DATE=`date +"%Y-%m-%d"`#Log存放位置LogFile=$Dir/backupLog/$DATE.log#新建日志文件(其实backup的脚本已经建立了，不过建立同名的会直接输出到那里，所以没有关系)touch $LogFile#追加日志信息echo "wolfdan,cn auto_rm .sql file a monoth ago. Start at $(date +"%Y-%m-%d %H:%M:%S")" &gt;&gt; $LogFileecho "------------------------------------------------------------------------------" &gt;&gt; $LogFile# 查找备份路径下，超过30天 且文件后缀为.sql 的 sql备份文件 然后删除find $Dir -type f -mtime +30 -name '*.sql*' -exec rm &#123;&#125; \;echo -e "----Done!Welcome to www.wolfdan.cn and add my VX:wolf_dan2---have a nice day!-------\n" &gt;&gt; $LogFile 赋予权限并且测试执行chmod 777 auto_rm.sh 12345678910# 这里我们先创建1些一个月前的文件touch -t 201905011230 test1.sqltouch -t 201906011230 test2.sqltouch -t 201907011230 test3.sql# 查看目录下文件 当然也可以用 ll 详细查看带时间的文件信息ls# 然后 测试sh auto_rm.sh# 再次查看 当然也可以用 ll 详细查看带时间的文件信息ls crontab定时测试细心用户可能看到我定时文件里面以及写上了auto_rm.sh任务了，没有写上的朋友快去写上吧 先修改crontabe配置vim /etc/contab假设我们现在是11:15,那么我们把日，月，周全打成*号，然后min设置成17，hour设置成11，这样就定时在2mins后了，然后auto_rm设置比backup多1mins 1234567891011121314151617181920SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed# 我的wolfdan.cn 每周备份17 11 * * * root /home/www/wolfdan.cn/backup.sh# 自动删除一个月前的sql，下周git的时候会同步到云端删除18 11 * * root /home/www/wolfdan.cn/auto_rm.sh 当然要重载并重启服务啦啦啦1234#重新加载cron配置文件sudo /usr/sbin/service cron reload#重启cron服务sudo /usr/sbin/service cron restart 当然我们又要创建一个月前的测试文件1234# 这里我们先创建1些一个月前的文件touch -t 201905011230 test1.sqltouch -t 201906011230 test2.sqltouch -t 201907011230 test3.sql 然后在11:18的时候去ls查看是否还有test1.sql 和 test2.sql 以及输出日志 输出日志是以前的，ball ball 你们动手试试给个反馈吧…不妨把你们的结果发到评论区，谢谢你们也可以加微信拉群讨论，我会经常发一些朋友圈 wolf_dan2参考的大佬文章: https://blog.csdn.net/ouyang_peng/article/details/77334215]]></content>
      <categories>
        <category>wordpress</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脚踝韧带拉伤经历分享]]></title>
    <url>%2F2019%2F07%2F06%2F%E8%84%9A%E8%B8%9D%E9%9F%A7%E5%B8%A6%E6%8B%89%E4%BC%A4%E7%BB%8F%E5%8E%86%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[想看经验的同学直接拉到最下面第一天 上午足球踢远考试前训练摔得，我对面那兄弟踢得老远，我去捡球，一时间兴奋，跳起来踩住球,自己却没稳住脚踩在球上面落地摔，脚内侧接近80度内弯，外侧剧痛，手肘擦地出血，屁股处的骨头感觉要断了，(看着我摔的同学没一个人过来？？？良久，还是没有一个人过来？？？excuse me?)然后感觉自己还能动的时候走到了厕所 (感觉良好)，在厕所洗手..然后动一下腿都两眼全黑，差点晕倒在厕所!赶紧老实了不动了，让自己紧紧扶住墙靠着洗漱台，然后用小爱同学打电话给了室友zy，结果zy的手机在寝室 然后等了好久眼睛能模糊看点字的时候打电话给了yzh，结果yzh手机在别人包里面—- &gt; 人间悲剧 好不容易扶着墙跌跌撞撞走到了操作入口处，向一个同学qhz挥手，没有理我…向来上WC的电三同学求助，让他帮我叫一下yzh，他说先上厕所，让一个高高瘦瘦的人叫老师，他说老师在测成绩应该不会过来—-&gt; what’s your problem?你看不到我快要死掉的样子吗？ 感想以上都是我没有体现出自己的受伤情况的严重性,所以他们都视若无睹 —- &gt; 以后我一定要多多关注别人的表情细节,因为很可能别人急需帮助 然后就是叫来了yzh，然后yzh把我背到了校医院，帮我挂号(校医院收款处竟然因为最近大四学长学姐毕业退款导致自己垫了钱啥的然后不能用支付宝了，只能现金)然后也不先急救… mdzz(原来是不会死的情况下就不会先救你，而是按照交钱和挂号排队慢慢来，当然急诊的照片什么的都会提前，然后也会无需挂号)—-&gt;不过我去校医院等待治病，他还在和别人(一个以前的病人)互喷一些钱的东西—-&gt;让我对校医院产生了比较不好的印象… 后面yzh又帮我去买冰棍让我冷敷，然后买了牛奶和面包 然后又体育测试完又背我从校医院到了901，太感谢了，明显感觉他背我很累 中午资询了以前有脚踝扭伤经验的同学xjy，ta详细地和我说各种就诊操作-&gt;现在想想，必须感谢ta 下午zy不上课陪我去看医生，然后还好他带了身份证，全程用他的身份来就医的(在医院遇到的很多人的情况都比我严重,心疼他们)然后zy陪着我打石膏，细心地带我去厕所帮我询问什么的 回来后感谢xjy和bh的看望，我叫xj帮忙带饭，xj的叫bb帮带饭，bb和kcn的慰问，然后中途碰到 zy学长 的细心慰问，感觉世上还是很多爱的 自己装B不用轮椅回寝室，结果累死，然后叫zy来帮我，zy叫孙崇山来帮忙，然后孙把我背了上楼，感谢 晚上大家教我如何单腿上床，如何单腿下床 尴尬: 被yzh背着自己不好意思看前面，感觉自己好没尊严 下午坐着轮椅很尴尬 下午因为不好意思出去上厕所，憋了好久的尿的尴尬 晚上发现想上大厕，发现要单脚蹲大然后憋着的尴尬 晚上想洗澡却只能擦一擦的尴尬 晚上回去因为到时候没人给我抬轮椅而直接用拐杖回去的尴尬 晚上要没有贴止血贴，手肘满是血，然后脚上是石膏睡觉的尴尬 明天要考电磁场电磁波了，自己6章只复习了前3章的部分的的尴尬,但是晚上复习的时候又老想着这几天怎么过的尴尬 认为没有什么比活着更重要，然后又想要记下此篇生活，所以就干脆不复习了 2019年6月13日23:24:49 回去吧，大家都在准备明天的考试，所以不能最后一个走，不然可能又要麻烦别人了，所以自己回去吧 不想告诉家里人我腿受伤了的强忍，以及自己感到孤独和无助的尴尬(其实自己是很想很想要一个人来帮助我的,但是又不想打扰身边同学的生活,也不好意思让他们帮我但又想他们帮我的尴尬)(更不想让家里人知道了担心，虽然我觉得可以轻易接收家里人的爱，但我也爱他们，我不想让他们为我太担心，所以我还时是不能告诉他们) 感想:以后一定多多帮助身边的人以后一定多多观察身边的人是否需要真的帮助以后一定多多观察身边的人是否需要帮助但又不好意思，学会假装碰巧去帮助别人第二天 感谢zy早起去帮我去901门口拿轮椅回到寝室楼下接我 感谢zy把我推到考场 感谢xj给我带午饭(以后对任何身边的人都当亲人一样地给予帮助，因为不这样做的话，说不定你那天就腿瘸了，然后大家都不帮你是最恐怖的，而且你平常不对别人好的话，在你为难的时候你也不好意思向别人寻求帮助，比如你想要xj给你带饭，但你又想到前段时间你拒绝了帮xj装内存条！所以你会无比愧疚，所以将心比心原来不是这么容易学会的，而是要经历生活的磨炼才能学会的，感谢生活) 以后一定要多多关注别人的难处，帮助别人 今天第一次成功单脚蹲厕(右腿小麻) 然后zy晚上带我会寝室 今天擦澡，洗身体，洗头发，换衣服，结果一屁股坐下去，直接右膝盖关节直接抽筋，现在每次膝盖收缩性略弯都会痛，一个人在厕所里面坐立不安地换衣服，真的好难，没想到残障人士生活这么难，这么苦，我才发现四肢健全的生活是多么难能可贵 妈妈突然打电话过来了，吓死我了，我还以为导员告诉我妈我咋了呢，还好没告诉，当妈妈问我最近怎么样，让我注意个人卫生，等等的时候，我差点没忍住，差点哭出来…因为我没办法洗澡，只能搽澡😭，然后有那么一瞬间好想告诉妈妈我受伤了，我好想妈妈给我安慰，但是我不能，不能让妈妈担心，对不起，妈妈，我不能让你知道，之后也不能让你知道，否则你以后一定会总觉得我有事没有告诉你，对不起，妈妈，我爱你(忍住泪水) 第三天 感谢zy推我去实验室 2019年6月15日08:15:01发现自己过来实验没有带电脑，然后发现自己上次CV好久的数字钟的代码在电脑里面，算了，腿伤了不方便，所以直接再搞一次吧(xj本来说要回寝室所以不帮我带饭，结果还是来了901，可能东西在这边吧，不怪她) 感谢gpc主动帮我带饭 2019年6月15日15:56:42 下午拉肚子了然后回来时拐杖蹦蹦蹦声音太响，门口那几个都看着我，尤其是jmq学长(那个有188的博士生学长)然后我和他对视了一会，轻声念叨:绝了下次记得微笑回视！ 不要总想着尝试走，一周后再尝试走，遵从医嘱！ 因为我差劲的社交，导致我现在要别人带个饭都这么困难(因为大家今天考完英语6级了，都直接出去浪了，所以也不好要别人给带饭…)，有些时候，真的很无奈，很伤心，很无助…只能少吃几顿……….但其实病了不能少吃…哎，算了，忍受3周吧 [ 现在才过了22 天,都有点感受不太到当时的感觉，不行，保持原汁原味的记录 ] 不要这么没有出息，谁都会有无助的时候，在自己被自己之前的愚蠢导致一手烂牌的时候只能努力恢复，然后吸取教训，以后避免风险 —&gt; 不准哭,杀不死只会让你更加坚强 受伤之后还敢爱————&gt;做自己的真正的英雄(不要把精力浪费在这里了!花了30mins发呆了,这样毫无意义) (如果你不保持经历苦难,新的苦难出现的可能性就越来越大)所以等痊愈之后坚持健身锻炼，坚持看书，坚持写项目，坚持社交和口才锻炼 2019年6月15日18:25:33庆幸自己没有死掉，我一定要好好活着，等到痊愈之后更加要好好活着，上帝一定会让勤奋的人站在他面前！ what is dead may never die,but rises again harder and stronger.逝者不死，必将再起，其势更烈 第四天一天呆在寝室，中午晚上wdc都给我送饭，然后就是晚上wdc还帮我锁大锁，真好，这是我腿受伤以来最开心的一天 第五天 今天又是待在寝室的一天，然后10点吃了zy给我带的早餐…为啥他不带中餐呢他也很尴尬 下午饿了吃了多包辣条 然后晚上让zy给我带了一个酸菜肉堡 想到明天周二突然陷入了极度痛苦不愿 面对 “明天下雨，中午饭不怎么好让别人带，上三楼上课的尴尬境地之中”—-&gt; 算了，办法一定比苦难多，只有不可预测的一些因素才让生命更加丰富多彩 下午吃的辣条在空调的袭击下导致肚子很痛了，然后就等晚点人少再去拉屎，先洗头吧 然后又折腾了许久，不过比上次好多了，加油，别人四肢全断都在认真生活 第六天 由于室友大家没有早起，导致没有吃早餐，2019年6月18日10:44:45 饿了，难受 2019年6月18日12:42:41 今天中午xj帮我带饭，然后自己也直接带饭到了9楼，她出去吃的，很抱歉…… 所以以后除了周二和周四,都直接待在寝室…因为跑腿腿可以直接送到寝室门口 [之后因为羞愧再也没有要xj带过饭了…—-&gt; 以后如果真心帮助别人也要尽量不动声色得帮助，别让别人难堪，导致别人下次再也不敢找你帮助了 ] 多了一种视角，你是否会麻烦别人却没有给与相应的价值(比如让xj带饭，麻烦了别人)，所以还是尽量使用服务业提供的服务 我的包—&gt;5本大书-&gt;knotex电脑 感谢下午lky给我带饭，帮我带包上3楼 感谢超哥吃完饭理完发推我从C座到寝室并且帮我带包上6楼感谢啊感谢 第七天 睡了10小时，emmmm第一次把腿垫高睡，有点不适应，然后梦到自己腿好了，石膏都被自己撑坏了，梦醒之后，石膏依旧 就不该看《胡广生》的MV，导致自己哭的稀里糊涂，不成样子 刚刚想在寝室上个厕所，结果蹦蹦蹦，右脚踩入茅坑，不过还好只是轻微砸了一下关节骨，没有其他伤害，左脚还好有石膏，所以只是震了一下，还好 试了一下，左脚能够比较好的动了，只是不能承重，所以还得一段时间静养—-&gt;结果今天折腾过了头，反而造成了一定损伤。mdzz 又看了40mins脚踝如何恢复，佛了，然后认真做实验(EDA实验) 真是疯狂折腾受伤的韧带！小心后遗症！所以每次去厕所都小心点!好吧 —-&gt; 1、 伤情被自己整到恶化 2. 然后大家这段时间都很忙很累，心情很烦，所以还是最好自力更生吧，天将降大任于斯人也！ 晚上我没有问清楚就让zy和wdc带饭，结果可能他们因为忙都来不及去吃饭，所以还锁他妈的大锁，所以他们就没有回来，没有给我带饭，理解别人的难处，别人都已经仁至义尽了，谢谢，真的谢谢 2019年6月19日20:27:25 留寝被查，真好，生活再难，也能活过去，脚伤期间，各种事情的重要性会变的，让我变成最差的学生吧，I don’t care！ 太浪了，花了太多精力去抱怨生活不公！第八天 昨天瞎折腾，导致伤愈情况表得糟糕了，艹，犯错难免，以后警惕 习主席说的对，只有经历了大风大浪还不倒的才是大海，才能看淡其他风雨，才不会想一个小池塘，遇到大风浪是会倒下，所以接受脚伤现状，努力改善，积极变得更好，我治愈之后会更加强大(就像高考前的一段慢性肠炎，然后运动了好长一段时间，这次，我将运动到我不在的那一天，文明精神，野蛮体魄) 放下手机，认真生活 暴雨，然后VHDL课后孙先没走，先问我要不要帮忙，我说等雨小，你们先去吃饭，别管我 然后下雨被困11教，发现11教很多教室不开，沃日，于是先在一个人少的楼梯那里等雨停，看书，之后小雨再回去 后面楼道开始有蚊子…日 感谢一个阿姨提建议让我 和学校反应让我去申请住一楼 [ 当然我没有去申请 ] 成长 今天成长还是很大的，首先是在zy帮忙打伞的作用下，在中雨中从寝室走到英语课教室 然后晚上在11教等雨停了，自己又拄着拐杖慢吞吞地走回了寝室，其实自己还是很叼的哦 第九天 拄拐去打水泡咖啡，自己爱护自己的身体，然后才能为全人类贡献80年！(100岁退休，工作过程也可以享受生活) —-&gt; change the world , make some difference! 2019年6月21日12:50:59，我问zy还回来吗，然后zy说他在星达，以后自己不要把鸡蛋放在同一个篮子，风险太大，早上他答应我给我带饭，于是就一直等他，结果我笑了，算了吧，别人帮你，你得感谢，别人不帮你，那是理所应当… 从来不想给别人造成麻烦，可是现在自己腿伤了只能给别人造成麻烦，难受 喝完那碗胡辣汤[是跑腿腿送餐到寝买的,我的整个思想是 朋友不会永远帮你，但是有钱可以一直买到服务 , 当时的思想也很有趣]，我整个的思维全被 跨越阶层 所占据，我一定要成为一个高阶层人士，实现财务自动增长，看遍世界各地的各种世间百态，成为一个独立，自律，无往不利的我(不要幼稚，活成一个普通人在很多方面都会受到巨大的限制，你永远无法获取更多更好的资源，你永远要忍受别人的压迫，每一天接受残忍社会的教育，在你现在还有机会的时候，努力跨越出你的阶层，成为自己的英雄，然后再去改变你想要改变的世界) 发现自己前天的折腾导致脚踝肿起来了，今天才发现，我服了，下次再也不折腾了！慢慢养吧，一个暑假，不急，到时候人就少了，而且没有关系，慢慢养 然后查资料发现是脚下垂太久，血液不流通导致的，而且绑带有点紧，所以晚上抬高会勒住，所以也会有影响，把腿架起来就好多了 15点开始又认真学习如何治疗韧带拉伤 学了1小时如何恢复，zy回来了，让他教我AD，然后zy20mins解决了我可能几天都解决不了的问题，真好 发现抬腿坐着屁股剧痛，然后不抬腿脚又浮肿，自闭了，所以今天先早点躺着吧 第十天 感谢炒饭阿姨把饭端到桌子上去给我吃[当时10点我去错峰吃饭] 感谢一个微胖小姐姐看到我出一食堂马上快步过来给我拉帘子 WC是我避开密集人流的避难所，所以感谢学校的厕所多[终于理解为什么厕所是社会的包容发泄所避免所了] 回9楼的时候遇到了hsj老师，他好像才知道我伤了 想着不要去看复查干什么，但是身体却很诚实地去干了…看了一个小时，基本上都是看过的，算了，不看了，认真学习，晚上吃鸡后睡觉，明天养足精神去复查 今天拄拐正常生后一整天，然后上帝都奖励我的乐观和勤劳，让我到楼下想掏出手机时正好快递电话来了，这快递比预计时间早20mins，真好，大吉大利，今晚吃鸡，庆祝脚伤但坚挺到了第10天 吃了一个小时的晚饭，然后直接上床休息，看视频，看书，争取明天复查有个好状态 晚上偷偷拆开一点点脚内测石膏，发现一片紫色，绝了，才发现，再撑拐杖10天吧，然后发现屁股那块骨头也没太好，还是痛—不过那应该只是轻微摔伤骨头，应该没有大碍，主要是脚 讲真的,自己当时每次复查前都极度渴望复查时能卸掉石膏,是石膏生活的不便以及麻烦别人的尴尬让我有了这种超强的欲望第十一天 凌晨涂了本草精华液，结果没想到药效如此猛烈，直接吸血一般，导致我左边大腿的血管都有明显地感觉到左脚关节处在抢血！！！左脚关节更是风起云涌！ 5点50梦醒，6点50起床 感谢司机看我不方便开到校门接我后倒车，7点35在车上 第一个就诊，结果去打石膏搞了好久好久，真TM慢 脚部抬高好像真有用，因为脚有时候好烦一阵一阵的翻涌 那个医生说让我加固石膏，下周继续复查。然后那个帮我拆石膏的人说让我走一下，我愣了半天，他说，你怕啥，我才走，发现竟然可以走，就是有点小痛，我惊了，然后那打石膏的医生让我多躺着 先学习吧，晚上再想吃饭的事[基本上每到饭点必定发愁] 发现脚抬高过久也不行，因为脚后跟会有痛感 感谢zy带的酸辣粉，不过一吃肚子就有反应了，我去WC 第十二天(含巨量的腿伤的日志及感想)摔伤日志 我会告诉你我跑到双子楼11去请假再去综合楼盖章，再去食堂买饭，再爬6楼回寝室吗？我会告诉你途中我去二食堂上个电梯摔了一下伤腿吗？我买14块的饭菜不好在那吃而错过好喝的酸梅汤吗？ 不，我不会！我只会在人多的时候走快点，在没人的时候先停下来休息一会继续上路，我只会在没站稳后立马调整，只会在摔倒后立马起来，之后在悲伤的时候劝说自己积极乐观，勤奋坚强，只会每天偷偷扯开一点点绷带偷偷看自己的恢复情况，只会每天梦到自己腿好了，又变回了那个走路像一阵风的骚年，只会…… 虽然有时候也会在心里诉苦， 啊，我的酸梅汤没喝，亏了！ 啊，为啥用剪刀剪掉绷带的所谓石膏拆除费要27块？下次我带把剪刀过去自己拆好不好啊？ 啊，别人不帮你是理所应当，别人帮你你得感激涕零，是啊，世态炎凉啊，还好还有那么几个好朋友愿意在他们方便的情况下帮帮我，感谢了… 懂得: 别人不帮你是理所应当，别人帮你你得感激涕零 努力赚钱，因为别人不能帮你的，你可以通过用钱去买到送饭到寝的服务 那些不愿在你痛苦时给你施以援手的朋友都是所谓的朋友而已，不要太较真 以前发现妈妈只会通过分数对你严管或者松管，总结出的”价值决定一切”其实用在这个现实的社会更加合适不过，所以，我要努力创造价值，make a difference，让绝大多数人都希望我健康地活着，不管是真诚的还是价值捆绑的 珍惜那些真正的朋友，努力报答他们，耐心帮助那些真正需要帮助的人 不要把太多时间浪费在抱怨上面，真的没用 表现得越强大，获取的帮助就越少，但之后你会成为真的强大！ ？？？ 说来有点奇怪，第一次叠完衣服，不放柜子，放床上，竟然是为了:垫高脚 :-) 第十三天 感谢中午余镇榜给我带饭到实验室 [当时在做模电课设] 第十四天 下午吃饭到1点半，然后看别人伤病恢复记录，发现别人恢复了好久好久，莫名害怕，还说软骨损伤不可再生，哭了，还好及时制动，2点33开始认真写完硬件作业，然后上床复习模电吧 第十五天[2019.6.27] 伤腿告诉我，我没必要花时间做不必要的社交，比如寝室去K歌，很蠢，因为大家都很个人化，所以你也无需牺牲自己去迎合大家，你就是你 老师让我过来，结果大家踢比赛，老师做裁判，我在这看着，老师还没理我，emmmm，算了，先坐着看书吧 [ 后面老师看在我平时成绩还不错的份上，但是又不能让我分数高过其他人，所以折中给我了80，感谢 ] 背电脑回寝室… 第十八天 7点21拼命走快点，4号楼6楼到3教302拼死用了21mins，你真棒！ [去考大物实验笔试] 再撑3天3夜就可以洗澡了，身上好多地方可以戳出生推瞪眼丸 [尽管有搽澡] 在厕所躲避人流20mins回寝室，不想去食堂了，很累，回去吃面吧 然后花了1小时回寝室(走得路长了，右脚关节痛…)休息，浪，吃面(大脑都缺氧了，才吃早午餐，下不为例) 感谢晚上zxb帮我带板子送归实验楼，并且帮我带饭 [后面才知道他先去吃饭，然后带饭回6楼给我，然后再去实验楼] 第二十天 考完模电提前40mins交卷，实在写不出了，和翟老师说明情况，她让我再看会，我说有点地方没复习，实在写不出了，就走了 [ 其实当时还有一个很重要的原因是自己需要去错峰吃饭…] 第二十一天(第二次复查之日,也是医生说的3周之日) 凌晨3点，3:00噩梦醒，噩梦是医生说不做拆线检查，应该是多余的担心，继续睡 [ 没想到当天真的没让我做核磁共振检查 ] 艹，4点28又以为7点了 5点14天亮了，6点，6点半 都醒了 日 还没7点 绝了，看来积攒了21天的期望值，情绪有点激动啊 5:59逼我设置6点半闹钟 7点25在校门口遇到vhdl老师，叫他没听见，就一直看着他没叫第二次，他戴着墨镜.. 等了接近20mins，然后自闭了，然后一个识货的知道学生腿伤都是踢球导致的私家车司机过来说10元，比出租车多2元，等到自闭的我管不了这么多了就做了，和他交流，他说这个点大家都上班，本来就很难打车 唯一不爽是他抽烟了… 然后这人看我好像不识货8元给他10元(要不是打不到车，我会多给你2元？)..想让我在对面下，我拒绝了，还好我没有继续傻 8点16苟到了等候就诊区 那老医生一脸不屑，让他的小助理给我开单……就问我骨折没，多少天，然后肿不肿，片也只看了一小会，我说我左边也痛，要不要核磁共振，他看着我不说话，我去，20块，就这样没了… 然后我回家自己拆掉，牛逼！温水泡脚，再拄拐两三个星期 完成了小时候长期不洗澡的梦想，也完成了这21天的梦想，我要洗澡，回来的路上，每走一步就在心里默念一下我要洗澡我要洗澡(受够了搽澡) 今天洗了可能有生之年最快乐，最充满期待的一次澡今天解锁:先左脚下一节台阶楼(伤腿)，后右脚跟上[上楼其实比下楼简单，因为不要比较大的关节弯曲，终于理解为什么这么都伤腿分享的小伙伴都说下楼痛了] 第二十二天(拆石膏第二天)解锁踱步下楼(左下一，右不用跟左脚，可以下下一节台阶，但是有点痛)之后2019年7月6日11:10:34今天是拆石膏第4天，也就是第24天 就是每天做康复训练，网上找的 热水泡脚 搽活血的药物 总结以及学到的 伤腿的日子里面自己也看各大平台的经验贴，基本上每天都看，有些贴子都看了好多遍了，分享一个写得比较搞笑的贴子截图—-以及对单腿蹲厕的网友体验 以后设计产品一定要尽可能多的考虑一下是否有少量人士使用我的产品会产生不便 学会了换位思考 更珍惜健康和时间(生命) 更加珍惜那些在困难中帮助我的朋友们(yzh,zy,wdc,yzb,zxb等) 经验 尽量多休息，把脚抬高 不要轻易尝试走动 过程大概是:红肿-&gt; 消肿(打着石膏容易产生已经好了的心理,此时千万别做出过激的尝试) -&gt; 微肿,脚面发紫(就是很多毛细血管损伤的那种) -&gt; 肿越来越少，然后发紫也变少 -&gt; 小腿肌肉恢复 -&gt; 能够单腿平衡很久 康复训练多锻炼小腿，这样才能早日走路 祝愿 伤病的时间确实有点难熬，不妨利用此段时间多多看书，提升自己，加油，祝愿你们能够早日恢复到日常走路带风的样子!]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第十周(10-521)]]></title>
    <url>%2F2019%2F06%2F30%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC%E5%8D%81%E5%91%A8-10-521%2F</url>
    <content type="text"><![CDATA[Algorithm最近考试加腿伤,刷题太少,惭愧 ReviewDecrypting Blockchain最近facebook发行了Libra币的白皮书，这是一件世界级的大事，因为它可能影响全世界的货币格局，也可能是美国想用新的技术手段来巩固他们的美元地位，而且可能造成货币垄断，所以这周给大家分享区块链的科普，更深入的可以自行搜索Libra然后多多关注 TipsLIBRA, EXPLAINED 最近一直在极客时间学linux，所以Tips本应该是极客时间的文章，但是想到你们看不了，所以放了对Libra币的讨论文章 Share最近一直在极客时间和得到学习，而且也在忙考试，和腿伤休息，所以这周的分享比IT技术分享高一个维度，是人生管理分享如何快乐生活,忙而不碌]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎么成为时间管理的高手-听书有感]]></title>
    <url>%2F2019%2F06%2F29%2F%E6%80%8E%E4%B9%88%E6%88%90%E4%B8%BA%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E6%89%8B-%E5%90%AC%E4%B9%A6%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[第一讲 规划与备忘1. 项目管理表 做计划，细分计划，不重不漏，然后头脑中要有想象，设置截止日期！(不要不设置截止日期) deadline可以用来反馈，若此次没做完，下次做相同任务量任务可以更好设置截止日期————主要目的是让自己对时间有个概念 设置进度提示:进展不顺的子项目要标红 ， 正常进行的标绿 2. 所以要有日历表,日程表日历表 先做重要的事情，先放石头，再放沙子—-&gt;长期投资的事情，巨大红利(技术长期积淀) 好的日历计划不是填满每个小时，而是留有20%缓冲，截止日期也是20%缓冲 日程表 每天事项划掉是感觉很爽的 第二讲 行动:把时间变成产出1. 把事项改成动作把事项改成动作,而非一个大任务,若是大任务,就分解成小动作,让每个当下只有一个动作 2. 干扰多，事情杂怎么办? 悬而未决会让你受羁绊—-所以4板斧解决 1.转让别人帮忙做，若这件事情有人比你做的更好，而且不是必须需要你在场，那么就可以让别人帮忙做，让这个任务更好地被完成 2.做 虽然说要事优先，但如果一个动作只要2-3mins，那就马上做掉，防止占据大脑内存 比如: 一个实验之后，马上和别人探讨写完报告总结。因为这时候印象最深，效率最高，就算当时很累，也很值得 3.存存起来(马上放日程表)，以后做—注意不要放在大脑里面,否则会影响自己全情投入 4.扔不重要的，可以直接扔掉 总结： 不要让自己的大脑被占据担心自己做不好而拖延怎么办? 面对大人物做报告，也把对方当做自己的学生，因为你是专家 反正要做，不如找个积极的心理暗示 和别人交流，听取别人的建议 2019年6月29日 学完上面并做笔记 2019年6月30日15:38:22 开始下面的学习 第三讲 敏捷工作法:让计划赶上变化不要把时间浪费在努力工作中完美主义的时间浪费完美有代价，把一件80分的事做到了100分，导致其他很多应该做到60分的事情没有做 范围蔓延别人要求帮不是你要做的事情的时候,不断让步,结果自己帮别人做了好多事情 返工没有沟通好，需求没有谈好 敏捷工作法最小可交付,持续迭代把自己的每个输入，处理，要想做自己的输出，自己要干什么 最小可交付，就是做一个小demo，然后大家提出反馈，让你可以调整，这样就不用大的返工 别人给你任务，你给别人的deadline为第一次交付的时间 交互一个小交付后，你就可以做下一个任务了 如果多个项目重要的事情多迭代，紧急的事情先迭代 敏捷工作法， 不要进行多个任务，让手里只有一个项目 第四讲 管理合作者的时间透明的沟通习惯 做决策的时候就拉大家过来一起决策 同步站会，让大家站着开会同步进度 让自己的任务进度能被看见 尽量当面沟通！能见面就别打电话…能打电话就别发邮件… 敢于和上级沟通时间 管理者只会记得上面的任务,不记得给下属的任务 主动给上级反馈你的进度，让其对你的任务进行重要度排序，这个也很受上级欢迎 团队领导如何管理上级 不要把下属的事情自己做,不要所有事都亲力亲为 下属不是因为成长而能做事情，而是因为做事情而能力成长 下属让你帮忙做，你要思考最终责任人是你还是他 担心下属能力，就从小的任务开始训练他，比如给讲PPT，一次给他3mins等等，然后慢慢渐渐增加 第五讲 如何与忙碌相处 忙碌的人完成事情更快，而且不容易错过deadline，闲的人反之 我们要避免内卷化忙碌就是被自己忙死，但是恶性循环，没有时间提升自己 改善:要做到自驱模式的忙碌确定计划确定自己的人生计划 这种计划一般是除了本来要做的事情外 开创新领域 自己想做的 这种事情会让自己很快乐的，会产生积极的情绪，然后良性循环也会让自己做本职工作的时候效率更高想象自己定的目标是给未来的简历 给学习留出足够的投入 在学习上，投入自己心痛的钱(可以自我提升的比肩自己每天工作赚取的钱)这样自己就会非常地重视，并且努力学习，并且会积极主动地学以致用 最后发现人生最大的成本其实是时间 跑出自己的良性循环让自己的技能提升，然后马上使用自己提升的技能 对于制定人生计划:自己10年想要什么是想不明白的或者说很难想明白，要做的是不断迭代自己，在自己本职工作上面，尝试自己的兴趣点的一个小任务的迭代，每次如果都有好的结果，那么就多迭代一次，多多探索，直到自己发现自己学习到了有能力胜任新的职位的时候就可以对自己的人生进行一次大的迭代，就是找到本职工作和新技能工作的能力交叉的工作，然后就这样持续地迭代自己的人生 注: 当然如果你一开始就有一个人生目标，然后你的每一次小的迭代都是往这方面进行的小迭代，小进步，这样就更好了，有目标地探索，能让你走得更有方向感，离成功更加容易到达，因为一直在向着目标走啊！ 总结 管理时间就是管理人生时间就是生命，管理好时间就是管理好人生 让时间服务于你，而不是你服务于时间，这样你就能过上自驱的快乐忙而不碌的生活，然后就能有充沛的精力去陪伴家人，去享受生活 最后祝愿大家能幸福健康，职场节节高升!过出自己想要的人生! 单林敏(wolfdan) 2019年6月 于合肥]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第九周(9-521)]]></title>
    <url>%2F2019%2F06%2F23%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC%E4%B9%9D%E5%91%A8-9-521%2F</url>
    <content type="text"><![CDATA[Algorithm最近踢球脚扭了，不能走路，要休息，所以刷题较少 ReviewThe Internet is changing your brainWe can remember the things that we need to remember but, forget the things that we rarely use. That is not a problem, it is entirely sensible and should be expected.我们要在变化快速适应，要积极求变，不断进步，终身学习 Tips 当然要推荐且必须要放耗子叔最近新发的文章啦 如何超过大多数人 就是不管干啥都要多多访问官网，比如配置next，官网才是最新的资讯因为自己对busuanzi统计的折腾，发现还是官网好啊 NexT 使用文档 Share在另一个终端上同步写HEXO AD14.2如何安装各种库 安装破解Altium Designer14.2]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AD14.2如何安装各种库]]></title>
    <url>%2F2019%2F06%2F17%2FAD14-2%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E5%90%84%E7%A7%8D%E5%BA%93%2F</url>
    <content type="text"><![CDATA[AD14.2如何安装各种库我们先以安装NSC Amplifier.IntLib为例子安装文件由于我不知道NSC Amplifier.IntLib在哪,所以我直接搜索找到了这个官方网站的一直文档分支链接进入之后看图操作下载吧下载 使AD软件链接路径 开心食用 下载各种库？当然是找官网啦啦啦官网老库 注意:你清楚你要的库是哪个大文件包—&gt;否则1.谷歌搞清楚2.自己下载整个库解压后搜索 最后注好像又是重复造轮子，搬运工，所以大家多多了解这种解决方案的思路啦，以后多多触类旁通啦 谢谢大家的浏览啦]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>总有一些事情值得</tag>
        <tag>hardware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在另一个终端上同步写Hexo]]></title>
    <url>%2F2019%2F06%2F17%2F%E5%9C%A8could-studio%E5%90%8C%E6%AD%A5%E5%86%99Hexo%2F</url>
    <content type="text"><![CDATA[在另一个终端上同步写Hexo用Cloud Studio做示范,其他非linux可以适当借鉴 2019年6月17日20:49:03发现Cloud Studio发布的环境也没有保存npm！所以只能每次都重新安装，所以小编将会加急写个脚本出来—&gt;结果发现在cloudstudio运行脚本各种奇葩bug，所以大家要用cloudstudio写hexo的话可以每次粘贴一下下面的程序段，当然建议直接在本地装吧，这种免费但不怎么稳定的东西用着心累1234567echo "-------CloudStudioWriteHexoOnce-------"curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | shwget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | shexport NVM_DIR="$HOME/.nvm" &amp;&amp; [ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh" # This loads nvmnvm install stablenpm install -g hexo-clinpm install 1. 添加密钥并且Git pull你自己的仓库由于本着不重复造轮子的心态,所以不会云备份Hexo的朋友们可以看某大佬写的文章 2. 安装node.js安装 Node.js 的最佳方式是使用 nvm cURL: $ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh Wget: $ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh 配置nvm环境 export NVM_DIR=&quot;$HOME/.nvm&quot; &amp;&amp;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 安装完成后，重启终端并执行下列命令即可安装 Node.js $ nvm install stable 3. 在blog的根目录安装依赖 注意:blog的根目录就是你之前hexo init &lt;folder&gt;的这个foldernpm i 然后测试hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 4. 写新文章测试 5. 发布自己的环境 这一步十分重要！！！ 博主就是由于之前这一步没做，导致了环境重置 因为cloud studio的工作目录和环境是分离的！ 丢失环境只能重建 发布自己的环境 谢谢大家的浏览啦]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装破解Altium Designer14.2]]></title>
    <url>%2F2019%2F06%2F16%2F%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3Altium-Designer14-2%2F</url>
    <content type="text"><![CDATA[安装破解Altium Designer 14.2.3 http://pandownload.com/ 百度云盘第三方不限速版软件(小单推荐) 欢迎访问wolfdan.cn AD软件链接：https://pan.baidu.com/s/1m6mNk_uqHGb3q6Moc1zqQA 提取码：eqyo 2.1用1打开这个链接，然后下载，只下载两个压缩包就行了， 2.2然后一起解压到当前目录 2.3看视频安装 个人分享链接:https://pan.baidu.com/s/1EHtVTZWtefQwVn6GVleE6g 提取码：zhf1(防止上面失效用的) 注:不好意思，好像重复造轮子了,dbq,但希望能帮到你…用完即走就好(毕竟是工具性质,分享性质的网站)]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>总有一些事情值得</tag>
        <tag>hardware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第八周(8-521)]]></title>
    <url>%2F2019%2F06%2F16%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC%E5%85%AB%E5%91%A8-8-521%2F</url>
    <content type="text"><![CDATA[ARST打卡第八周(8/521)探险就要做好面对乌云密布的准备注·最近因为踢球脚韧带拉伤了,所以最近喜欢看比较悲壮的图片,希望大家多多注意身体健康 AlgorithmARST第八周的刷题 ReviewDevOps: Tools vs. MindsetAnd it is so true: without developing a collaborative environment within the teams, and a culture to adapt to continuous change, no organization can claim to have achieved DevOps implementation success, no matter what tools or technologies you use.对的，通力合作才是最棒的DevOps Tips一个大佬的求职逆袭 Share如何使用一个域名同时构建Hexo和WordPress]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用一个域名同时构建Hexo和WordPress]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%9F%9F%E5%90%8D%E5%90%8C%E6%97%B6%E6%9E%84%E5%BB%BAHexo%E5%92%8CWordPress%2F</url>
    <content type="text"><![CDATA[两把椅子，看见同一片美景 wolfdan blog主本人的配置:其他配置可以灵活参考 BT面板管理的WordPress 腾讯云管理域名 Hexo分布在github page和coding.me pages上面 使用的wolfdan.cn做WordPress的域名，www.wolfdan.cn做Hexo的域名（主要是因为之前我的WordPress就是用的wolfdan.cn的域名,所以如果我想要反过来操作的话—&gt;那么1. 数据库里面不太好改的，2. 容易出一些文章链接不正常，3. 网站SEO会很奇怪—&gt;好奇的朋友可以自己尝试一下） 操作一.给coding重新绑定域名 我的是绑定www.wolfdan.cn，你们参考一下 去腾讯云解析,把github的pages解析关闭掉，然后www.wolfdan.cn只留下pages.coding.me的CNAME的解析(详细操作请看图)这样做是为了顺利申请www.wolfdan.cn的域名的SSL，因为如果还开着github的那个解析会申请失败(可以解决问题:coding申请SSL失败) pages解析 二.绑定好其他域名 去github.io仓库的setting设置custom domain的域名绑定 Hexo的你的博客根目录下的source根目录下新建一个CNAME文件，里面写上你刚刚绑定的域名，这样是为了防止每次发布后重新绑定github的域名 用@记录绑定自己vps的地址最后解析的画面 在bt面板添加网站并申请ssl添加网站申请ssl 修改wp-config（看情况是否需要操作） 开始测试玩耍收工咯注： 测试效果的时候，谷歌浏览器要输入网址的话，域名最后一定要加/,比如blog主的https://www.wolfdan.cn/，否则很可能出现谷歌智能跳转到以前访问过的https://wolfdan.cn上面去(我就在上面花了好久时间…) 提前谷歌了一下，发现自己应该没有重复造轮子，才写下此篇，2019年6月15日19:03:53应该没有重复造轮子，感谢大家浏览 由于自己是5天后才写的，所以难免会有很多纰漏，如果大家有哪里看不懂的可以给我评论留言，谢谢大家的浏览和支持]]></content>
      <categories>
        <category>域名</category>
      </categories>
      <tags>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[许岑老师的《如何成为有效学习的高手》读书有感]]></title>
    <url>%2F2019%2F06%2F12%2F%E8%AE%B8%E5%B2%91%E8%80%81%E5%B8%88%E7%9A%84%E3%80%8A%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E6%9C%89%E6%95%88%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%AB%98%E6%89%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[高效学习关关键词适合自己、学习方法、短时间、注意力、解决难题、设定目标，以及名师 找到适合你的学习方法 自然主义核心在于模仿，结构主义为的是创造 模仿类的学习—比如语言等,就是不断地模仿,不要花过多的时间去死扣结构 而学习创造性的学科时，比如艺术类，设计类，那么就要学好基础结构，这样才能有效创造 练习不必顾全大局，练习的时候就可以把练习的东西先拆解反复练习，之后在组合练习的时候再顾全大局 不要收藏，而是多碎片化学习(没有整块学习时间的情况下)，当然碎片化学习的前提是你要有一定的知识体系(比如你要会1+1=2吧) 不谈兴趣,用任务驱动学习 生活驱动,工作驱动,以教为学 生活工作中的一些事情推动你学习,那种就是很强的驱动 每次学习都要有教别人的任务心态去学习,比如写分享文章等,这样就能使得自己的学习变成一个强的任务驱动的学习过程，进而让自己成为一个高效的学习者 你99.999999999%没有拖延症 事情的重要程度决定了你的行动力,所以给自己要学习的任务的重要性加码 精致地对待自己的生活 买贵的学习工具(贵到让你心痛),那么你就会刻意学习了,因为这么贵,怎么舍得不好好利用,不每天都用几下,感觉少用一下都是亵渎钱财 平时生活中要有仪式感,比如好好吃饭 使用射灯,让自己有一种在舞台表演的感觉 进入高质量的睡眠,白天累到自己,比如超认真工作一天,睡前几小时锻炼身体,或者超级专注地玩游戏 设定有效的目标 首先要有足够明确的目标，强烈的任务驱动欲望，而不是自己的白日梦那种偶尔幻想级别的任务，否则太容易半途而废了，比如你要出国留学,你现在迫在眉睫地需要练习好口语,还比如你下学期要打ICPC比赛了,你要急速提升你的算法竞赛能力 直奔大师 在明确了自己的目标也就是自己要去到哪里之后，然后先来一次直奔你要去的地方的模仿(因为这里涵盖了兴趣和任务驱动),然后再是扎实地练习基础功，然后就不断地向着真正意义的大师慢慢进发 怯场是最糟糕的自觉。一个人他胆子变得比之前的大一点，能走的路可能就长一点 制造反馈 当学东西的时候，一定要想办法把学习的成功展示出来，应用出来 比如文字类的，写个总结(就是自己看着文章用自己的话来表述) 口语类的就给自己录音反复练习 动作类的就给自己拍视频然后看自己的动作是否规范，然后反复练习 突破瓶颈 解决自己的心态问题,在排除了技术问题后,要足够地自信 扩大涉猎范围,在你的专业里面,你要不断地积累 更加专注,请教名师 结语 如果自信来自于自律，那就是扎扎实实的自信。如果自信来源于幻想，那就是盲目的自信]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于认知,财富,阶层的听书blog记]]></title>
    <url>%2F2019%2F06%2F10%2F%E5%85%B3%E4%BA%8E%E8%AE%A4%E7%9F%A5-%E8%B4%A2%E5%AF%8C-%E9%98%B6%E5%B1%82%E7%9A%84%E5%90%AC%E4%B9%A6blog%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[洛克菲勒行事准则: 绝对不要把精力发在不可逆转的事情上面！(所以不要花时间去抱怨) 记录读书笔记以及学习技术的blog，让自己忘了详细细节的时候能够快速查找到，也让自己加深理解—-&gt;然后想想怎么让人们能够轻松地给语音知识做笔记，这可能是一个爆点(脑电波？) 我们必须面对现实，现实就是没有那么多时间让你搞清楚一切，你必须做出当前限制下的选择！所以我们一般情况下是定好目标，选好方法，合适取舍！而非一直死磕！因为一般你不会一直做嗑盐，除非你是科学家，但你的梦想是伟大的工程师啊，所以你必须学会转变思维方式，确立目标，选好方法，合适取舍！ 虽然你喜欢一直搞通全部，但这是不可能的，你要接受现实，但你必须努力去达成目标，目标域内关键的东西必须搞清楚 围棋智慧，两只眼活，所以让自己算法能力练习到前25%，演讲沟通管理写作技能练习到前25%，那你就可以成为伟大的工程师，好的就是这样 多只眼更爽 自己需要表达+算法+思维不断强化 中国族群给哈佛这些私立学校捐款才能提高我们中国族群的哈佛入学率，而中国大学国家资助，所以只要多多纳税就好 美国自由，福利到，导致穷人不自控不自制，然后穷人很找就乱性生了孩子又容易单亲然后教育就不好，并且天天和穷人待在一起，思维觉得这样也好，然后穷人循环，然而富人反之，中国却可以让你有机会接触富人，让你在没有很强自制力前强制压迫你学习的机制，所以反而贫富流动性很好 中国也有分层，各处都有分层，但是分层的本质来自于思维方式导致的分层！你的思维是否就只是一个中产阶级的思维？ 底层用技术教育，中层用素质教育，精英层用决策教育(你说1+1=3，那其他人同意吗？) 顶级精英，培养你自行决策，让你学会选择，中产是提供作业，让你多样化完成 所以多练习自己的决策能力！！！选择去改变世界，永远不按套路出牌，成为英雄，超越自己的命运 跨阶层的人才是英雄 不知道自己知道是经验！是认知最高境界 人和人唯一差别是认知 提升认知1.自我否定(不能对任何事确定地说我知道)2.行动(知行合一，认知到重要的马上行动)(早死早超生)3.和认知比你高的人待在一起！！(找职业就找认知比你高的老板或同事)(腾讯开放各平台就可以和各大佬交流认知！！！) 风险投资人 == 用概率算法，是一种精密算法的概率游戏，富人思维，好的亲友环境可以给你这种思维]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第七周(7/521)]]></title>
    <url>%2F2019%2F06%2F09%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC%E4%B8%83%E5%91%A8-7-521%2F</url>
    <content type="text"><![CDATA[AlgorithmAlgorithm ReviewLearning Containers In addition to all the traditional work of a DBA, I’ll be adding a bunch of information on containers as I learn it. For good or for ill, a lot of stuff like query tuning, backups, HA/DR, and more, is NOT going away. 我认为:是的，容器化改变了运维现状，以后的运维师将会变少，但不会消失，极度优秀的运维师反而还会出现新的供不应求—-从古至今，市场从而不缺技术人员，只缺技术人才，所以我相信对于运维职业消失的担忧其实和当下的CV程序员对于自己是否会被裁掉的担忧是一样的,因此，我们面对技术变革，唯一需要做的，也是一辈子都需要做的就是：终身学习，我也喜欢这个行业带给我终身学习的习惯 Tips:V2ray问题合集Hexo搭建个性化next主题 Share:Hexo和WordPress]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo和wordpress的选择]]></title>
    <url>%2F2019%2F06%2F08%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BD%BF%E7%94%A8Hexo%2F</url>
    <content type="text"><![CDATA[Hexo和wordpress的选择 1. 原来的服务器ip被墙了 因为原来自己的网站是搭建在国外的一台服务器上面，然后最近一段时间网络整顿，然后我的ip被ban了,然后我抢救了4天整,好不容易救活了,但是访问速度极其不友好,所以为了让我的读者能有最后的体验,我必须努力啊,然后我就想到了境内境外分流(其实也是受到一个学长的启发) 2. 因为维护vps太麻烦了 记得自己是最喜欢配置各种生产环境的一个人,前段时间还想过要做一个运维工程师来着,但是最近头铁了4天整,发现维护vps实在是太麻烦了,而且自己还有很多其他的事要处理,所以这种比较吃时间,可以做到的,但做慢了却会影响用户体验而导致自己熬夜也要肝的事情还是尽量少发生比较好一点,所以自己觉得让网站托管在大厂微软的github和腾讯的coding上面 3. Hexo的美化度比较高(个人感觉) 不知道是自己没有认真地看wordpress的主题还是怎么样,我感觉Hexo的美化度是比较高的,然而我看到的比较好看的wordpress的主题都是收费版的更好看,这让暂时没什么钱的我有点难受,而且觉得不太值得 4. 免费 真的,买vps不管国内国外,就连学生机都要至少10RMB/月左右,所以对于这种Hexo的部署分流方式，真是又快又好又便宜又省事,何乐而不为呢? 注: 虽然有些大佬可以薅到谷歌云和亚马逊云的羊毛免费使用一段时间,但是时间是有限的,而且还是有第一二个问题—-网站容易被墙和维护vps困难 感言当然我不是说不能用wordpress，wordpress其实也是有很多好处的，比如 可以云端写文章(因为它是在网页端写作的特性) 可以搭建好了之后让一些没有计算机相关背景的作家使用(就是只要有技术的人定期维护一下就好)(当然这也不一定) 技术历史长，就是很多问题在谷歌百度上都能找到(而Hexo是一个相对来说新一点的东西) 做好真正重要的—————— 学习和创作 这些东西其实都是一些工具，我们最应该做的还是在自己感兴趣的地方多多努力，然后创造价值，再分享给大家，这才是最重要的，也才是我们写作的最主要的目的—&gt;帮助更多的人 2019年6月9日21:07:21 当我今天用着wordpress写文档的时候，想着以后再有不用这个了，心里有说不出的难受，毕竟这真是我亲儿子一样，养了几个月了，难以割舍的情感，而且云端写作的体验也是妙不可言，所以我决定还是wordpress和hexo都使用 然后2019年6月9日21:49:40 发现Hexo是组件化，然后很多都是链接别处的东西，所以很容易挂掉某个组件，很惨的那种，然而WordPress就是只要你的vps不死掉，ip不死掉，基本上是没有任何事情会出大故障的]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
