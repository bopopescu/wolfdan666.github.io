<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CF123D_SAM_算法日常[27/100]]]></title>
    <url>%2F2019%2F09%2F17%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-27-100%2F</url>
    <content type="text"><![CDATA[题目链接VJCF 题意 如果字符串y在字符串x中出现n次，那么F(x,y)=n*(n+1)/2 (可以看做是一个长为n的区间,求滑动区块的总个数) 现在给一个字符串，求所有的F(s,x)的和，x为字符串的所有不相同的子串． 思路 直接SAM right[v]就是SAM上状态表示的所有字符串出现的次数 那么每个状态的答案就是right[v](right[v]+1)/2*(st[v].len-st[st[v].link].len) 前面right[v](right[v]+1)/2是串的组合 后面是 st[v].len - st[st[v].link].len是后缀的前缀长度，是本质不同的串的贡献 也即后缀的前缀每个字母的贡献—-&gt;就是 每个后缀节点t跳父亲节点fa跳掉的那部分t的前缀 中的 以每一个字母开头的串t的后缀 都是和串t所在状态节点出现次数(前面的串的组合数)相同的！ 累加答案完成计算 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;bits/stdc++.h&gt;#define ms(a, x) memset(a, x, sizeof(a))typedef long long LL;using namespace std;const int N = 5e5 + 7;struct SAM &#123;#define MAXALP 30 struct state &#123; int len, link, nxt[MAXALP]; int leftmost; //某个状态的right集合中r值最小的 int rightmost; //某个状态的right集合的r的最大值 int Right; //right集合大小 &#125;; state st[N * 2]; char S[N]; int sz, last, rt; char s[N]; int cnt[2 * N], rk[2 * N]; //for radix sort int idx(char c)&#123; if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') return c - 'a'; return c - 'A' + 26; &#125; void init()&#123; sz = 0; ms(st, 0); last = rt = ++sz; st[1].len = 0; st[1].link = -1; st[1].rightmost = 0; ms(st[1].nxt, -1); &#125; void extend(int c, int head)&#123; int cur = ++sz; st[cur].len = st[last].len + 1; st[cur].leftmost = st[cur].rightmost = head; memset(st[cur].nxt, -1, sizeof(st[cur].nxt)); int p; for (p = last; p != -1 &amp;&amp; st[p].nxt[c] == -1; p = st[p].link) st[p].nxt[c] = cur; if (p == -1) &#123; st[cur].link = rt; &#125; else &#123; int q = st[p].nxt[c]; if (st[p].len + 1 == st[q].len) &#123; st[cur].link = q; &#125; else &#123; int clone = ++sz; st[clone].len = st[p].len + 1; st[clone].link = st[q].link; memcpy(st[clone].nxt, st[q].nxt, sizeof(st[q].nxt)); st[clone].leftmost = st[q].leftmost; st[clone].rightmost = st[q].rightmost; for (; p != -1 &amp;&amp; st[p].nxt[c] == q; p = st[p].link) st[p].nxt[c] = clone; st[q].link = st[cur].link = clone; &#125; &#125; last = cur; &#125; void build()&#123; init(); for (int i = 0, _len = strlen(S); i &lt; _len; i++) &#123; st[sz + 1].Right = 1; extend(idx(S[i]), i); &#125; &#125; void topo()&#123; ms(cnt, 0); for (int i = 1; i &lt;= sz; i++) cnt[st[i].len]++; for (int i = 1; i &lt;= sz; i++) cnt[i] += cnt[i - 1]; //rk[1]是len最小的状态的标号 for (int i = 1; i &lt;= sz; i++) rk[cnt[st[i].len]--] = i; &#125; //跑拓扑序，预处理一些东西 void pre()&#123; for (int i = sz; i &gt;= 2; i--) &#123; int v = rk[i]; int fa = st[v].link; if (fa == -1) continue; st[fa].rightmost = max(st[fa].rightmost, st[v].rightmost); st[fa].Right += st[v].Right; &#125; &#125; void solve()&#123; LL ans = 0; for (int i = sz; i &gt;= 2; i--) &#123; int v = rk[i]; if (st[v].link == -1) continue; // 前面是串的组合 // 后面是 st[v].len - st[st[v].link].len是后缀的前缀，是本质不同的串的贡献 // 每个字母的贡献---&gt;就是每个后缀节点t跳父亲节点fa跳掉的那部分t的前缀中的每一个字母开头的后缀都是和串t出现次数相同的！ ans = ans + 1LL * st[v].Right * (st[v].Right + 1) / 2 * (st[v].len - st[st[v].link].len); // cout&lt;&lt;"TEST: "&lt;&lt;st[v].len - st[st[v].link].len&lt;&lt;endl; &#125; printf("%lld\n", ans); &#125;&#125; A;char B[N];int main()&#123; scanf("%s", A.S); A.build(); A.topo(); A.pre(); A.solve(); return 0;&#125; 参考111qqz 每天一句叨叨路还长，别太狂，以后指不定谁辉煌]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019上海网络赛G-Substring_字符串Hash+自建Hashmap_算法日常[26/100]]]></title>
    <url>%2F2019%2F09%2F16%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-26-100%2F</url>
    <content type="text"><![CDATA[题目链接计蒜客走你(揍你) 题意 定义匹配 : 两个串首尾字母相同,中间整个串相同或者是相同数量的各字符组成的不同排列 给你一个原串S，然后给你m个子串t，求这些子串在原串S中匹配的个数 无关题意的个人吐槽:众所周知，2019最后一场网络赛-上海网络赛是一场让你自闭的计数场 题解 长度种类数是O($\sqrt n$)的 然后就是离线暴力处理—&gt;hash字符串 对hash字符串比较匹配 但是如果使用unordered_map会超时 使用数组会超内存 只有使用自建hash才能过 详见代码注释 代码是借鉴一个大佬同学的 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;=n;++i)#define pre(i,a,n) for(int i=n;i&gt;=a;--i)#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;#ifdef ONLINE_JUDGE const int N = 1e5+50;#else const int N = 1e2+10;#endifchar s[N],p[N];int n, m;const int bas = 1e9+7;ull get(int *a) &#123; ull ret = 0; rep(i,0,27) &#123; ret = ret*bas+a[i]+1; &#125; return ret;&#125;struct node &#123; ull sta; int id;&#125;;vector&lt;node&gt; g[N];int ans[N];ull fac[N];int clk;// 手写的Hash,因为unorder_map&lt;int,int&gt; f[26][26]被卡时间namespace Hash&#123; const int hashmod = 218357; int v[hashmod]; unsigned long long h[hashmod]; int vis[hashmod]; int &amp;get(unsigned long long S) &#123; int t2 = S % hashmod, i; // vis[i]是访问过的(clk恒为1)，所以也要走下一个 // h[i] = S.则发生了hash crash(哈希碰撞)，就要走到下一个，也就是h[i] != S 走下一个 // i = t2-1说明走了一个轮回了，就不用再走了，再走就是重复走t2位置了,所以i!=t2-1 for (i = t2; vis[i]==clk &amp;&amp; h[i] != S &amp;&amp; i != t2 - 1; i = (i + 1) % hashmod); // 从未访问过的要初始化计数值为0 if (vis[i]!=clk) h[i] = S, vis[i] = clk, v[i] = 0; return v[i]; &#125;&#125;;void solve() &#123; scanf("%s",s+1); n = strlen(s+1); rep(i,1,n) g[i].clear(); scanf("%d",&amp;m); rep(i,1,m) &#123; scanf("%s",p+1); int len = strlen(p+1); node ret; ret.id = i; int cnt[28]&#123;&#125;; rep(i,1,len) ++cnt[p[i]-'a']; cnt[26] = p[1]; cnt[27] = p[len]; ret.sta = get(cnt); g[len].pb(ret); &#125; rep(i,1,m) ans[i] = 0; rep(len,1,n) if (g[len].size()) &#123; int cnt[28]&#123;&#125;; // 中间的字母是按照字母顺序来的，所以就是可以的，然后最后两个是按照直接首尾字母来的 rep(i,1,len) ++cnt[s[i]-'a']; cnt[26] = s[1]; cnt[27] = s[len]; ull sta = get(cnt); ++clk; for (int L=1,R=len; R&lt;=n; ++L,++R) &#123; ++Hash::get(sta); // 左边字符基底为一个fac,而右边为fac^0=1 sta = sta+(s[L+1]-s[L])*fac[1]; sta = sta+(ll)(s[R+1]-s[R]); // 下面是右移一位整体的字母表的hash值变化 sta = sta-fac[27-(s[L]-'a')]; sta = sta+fac[27-(s[R+1]-'a')]; &#125; // 这个t长度下,把各次提问的ans更新 // hash是这个头尾相同，中间的串是不同排列的 询问串(key) ————&gt; 原串中的个数(value) for (auto &amp;&amp;t:g[len]) ans[t.id] = Hash::get(t.sta); &#125; rep(i,1,m) printf("%d\n",ans[i]);&#125;int main() &#123; fac[0]=1; rep(i,1,30) fac[i]=fac[i-1]*bas; int t; scanf("%d",&amp;t); while (t--) solve();&#125; 每天一句叨叨所有的胜利，与征服自己的胜利比起来，都是微不足道。所有的失败，与失去自己的失败比起来，更是微不足道]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>思维题</tag>
        <tag>手写HashMap</tag>
        <tag>StringHash</tag>
        <tag>串按长度分类讨论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第21周(21/521)]]></title>
    <url>%2F2019%2F09%2F15%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC21%E5%91%A8-21-521%2F</url>
    <content type="text"><![CDATA[Algorithm2019南昌网络赛Hello 2019(cf 750E)线段树_算法日常[24/100]2019上海网络赛B_Light bulbs_算法日常[25/100] ReviewYou’re Not Meant to Do What You Love是啊，如果你揣测自己喜欢做某件事情，然后没做好，就会产生极大的挫败感，所以不妨先做好你擅长地事情，然后慢慢进化你喜欢的事情 Tips把Ubuntu16.04装进移动硬盘的惨痛实战 Share将Deepin-linux装进移动硬盘到任何其他电脑上使用为什么要wp站停站,专注hexo站]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019上海网络赛B_Light bulbs_算法日常[25/100]]]></title>
    <url>%2F2019%2F09%2F15%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-25-100%2F</url>
    <content type="text"><![CDATA[题目链接计蒜客传送门 题意给你一排N个全灭的灯泡，然后进行M次区间翻转，T组测试 1≤T≤1000 1≤N≤$10^6$ 1≤M≤1000 0≤$L_i$ ≤$R_i$ ≤N−1 题解 因为是多次区间修改，然后求区间的特性，我们可以很自然地想到使用差分+前缀和或者线段树 不过这里发现8192K，N为$10^6$,$10^6$的int是4*$10^6$Byte=4*$10^3$K.然后线段树要开两倍N(节点2*N),而且一般是一个struct结构(一般几个int)，而非一个int，所以线段树否决 然后求前缀和O(T*N)在$10^9$量级，时间限制为1s，所以我们要观察M在1000的量级，所以可以通过离散化来解决 注意，这题超级卡时间，所以使用快读(独立缓冲的cin T了)以及各位置用完及时归0而非使用memset AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int M = 1e6+10;int a[M],T,n,m,l,r,ans,sum;vector&lt;int&gt; b;inline int read() &#123; int x=0,f=1;char ch=getchar();for(;!isdigit(ch);ch=getchar())if(ch=='-')f=-1; for (;isdigit(ch);ch=getchar())x=x*10+ch-'0';return x*f;&#125;int main()&#123; // ios::sync_with_stdio(false);cin.tie(0); T = read(); int kase = 1; while(T--)&#123; n = read(),m = read(); if(!b.empty()) b.clear(); ans = 0,sum = 0; while(m--)&#123; l = read(),r = read(); l++,r++; a[l]--;a[r+1]++; b.push_back(l),b.push_back(r+1); &#125; // 先排序，因为unique只从左到右顺序查重，然后unique得到最后一个被删除的位置，用erase搽除尾部 sort(b.begin(), b.end()); b.erase(unique(b.begin(), b.end()),b.end()); int sz = b.size(); sum+=a[b[0]]; a[b[0]] = 0; for(int i=1;i&lt;sz;i++)&#123; if(sum&amp;1) ans+=b[i]-b[i-1]; sum+=a[b[i]]; a[b[i]] = 0; &#125; if(sum&amp;1) ans+=n+1-b[sz-1]; printf("Case #%d: %d\n",kase++,ans); &#125; return 0;&#125; 每天一句叨叨人生总有很多东西无法挽留，比如走远的时光，比如枯萎的情感;总有很多东西难以割舍，比如追逐的梦想，比如心中的深爱。所以你一定要珍惜眼前。]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>思维题</tag>
        <tag>差分</tag>
        <tag>前缀和</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么要wp站停站,专注hexo站]]></title>
    <url>%2F2019%2F09%2F13%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81wp%E7%AB%99%E5%81%9C%E7%AB%99-%E4%B8%93%E6%B3%A8hexo%E7%AB%99%2F</url>
    <content type="text"><![CDATA[原因 维护两个网站有点耗时间 访问速度慢 wp站由于网站的vps在国外，然后在百度收录方面很差劲 中文内容，加上自己知识有限，所以在谷歌也没什么访问量 wp站有点重 Hexo站可以满足我的写作所有的愿望 展望 少就是多，把时间节省下来，专注做好一件事情 好好刷题，好好学习，好好写作 争取让我的小站能够对大家产生一点帮助 当然也希望自己通过写作成为更好的自己 搬家的一些痛 之前有些老文章是富文本写的…还好有wp-markdown.md，把那些转成html了 图片文件链接要重新搞一下，有点麻烦—-&gt;所以放弃了一些图片 wolfdan.cn域名的安全证书过期了，要多点好几下才能看到内容… 一些hexo不太爽的点解决_posts太多，找文件有点难 先发new draft &quot;文章名&quot;，之后hexo publish &quot;文章名&quot; 分类的话，直接在网站看]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将Deepin-linux装进移动硬盘到任何其他电脑上使用]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%B0%86Deepin-linux%E8%A3%85%E8%BF%9B%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E5%88%B0%E4%BB%BB%E4%BD%95%E5%85%B6%E4%BB%96%E7%94%B5%E8%84%91%E4%B8%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[需求分析最近买了一块480G的移动固态硬盘，天生的折腾性格，我哪闲得住…然后早就听闻有linux装到移动硬盘的操作，然后又听说deepin很牛*，所以我想要把deepin装到移动固态，然后实现系统插在任何电脑都是一样的配方，一样的味道，一样的我的数据和工具(在机房使用就是真香…虽然还没去机房试过)，不过在自己的电脑上跑得很high，然后插在朋友的电脑上成功了,看下图 我的high图 在朋友电脑上点亮 准备材料 电脑一台(环境是windows) 移动硬盘或者大容量的高速U盘一个 普通8G以上大小的U盘一个(用于制作启动盘) 开始安装下载镜像并制作启动盘 官网链接下载镜像,推荐选择一个地区位置离你比较近的地方的iso仓库下载 下载完成将压缩包中的deepin-boot-maker.exe和deepin-boot-maker.zip移动到一个文件夹下，然后运行.exe文件按照提示制作启动盘 压缩SSD磁盘空间右键windows图标，选择 磁盘管理 选择SSD，压缩卷(其实是取出一块的意思)，然后删除卷(其实是把它设置成可分配的意思)达到一定的大小(一定是没有数据的空间，你不要把你有数据的磁盘压缩删除了)，让你的的未分配的空间大小达到你想要的系统空间大小，比如我的设置的是100G，你们看到的20G，80G，300M的那三个就是对应我的deepin系统的/分区,/home分区,efi分区 关闭快速启动右键电源图标，点击电源选项 选择电源功能 禁用快速启动 设置启动项并关闭安全启动进入windows的设置-&gt; 更新和安全 -&gt; 恢复 -&gt; 高级启动 -&gt; 立即重启 重启后会自动进入一个蓝屏的界面，然后选择 疑难解答 -&gt; UEFI固件设置 进入bios界面后找到安全启动，然后disable 然后将Boot设置成 U盘为第一启动项 保存，重启 分区(最重要!)一步步进行到分区,然后选择高级模式，找到自己的移动硬盘，点击右侧的编辑我的分区大小是 efi 300M(一定要有efi!!!uefi安装模式必要的分区，否则可能无法在别的电脑启动) / 20G /home 80G (剩下的全部都行,因为之后用的东西都在这里) 安装安装完就是体验咯，取下U盘，慢慢使用 双显卡导致开机卡logo的解决方案 在grub选择界面按e进入编辑 找到这一行linux /vmlinuz-4.15.0-29deepin-generic root=UUID=************9-466c-bc12-6bb801e45901 ro splash quiet 在quiet后面加上acpi_osi=! acpi=&quot;windows 2009&quot;，然后按F10保存即可.这时会重新开始登录deepin系统，耐心等待进入桌面即可 开机后Ctrl+Alt+T进入打开终端，输入以下代码来打开grub配置文件：sudo vi /boot/grub/grub.cfg /quiet查找quiet位置，回车找到第一个，然后i进行编辑，同样加入acpi_osi=! acpi=&quot;windows 2009&quot; Esc退出编辑，:wq!强制保存退出 高光时刻-跑在别人电脑上在朋友电脑上进入界面按键进入bios选择，选择自己的ssd启动，然后完美进入自己的deepin，看一下，数据都在，完美 自己对于deepin的一些体验优点 界面真好看 命令行界面有好多好多种配色，真好，而且默认的就是我最爱的绿色 比起他的爸爸Ubuntu，他在系统上对微信，qq进行了优化，不用手动去调节wine-qq，wine-微信的一些兼容性问题(虽然还是有时候会出现卡死现象，无可厚非) 截图功能极其强大(弥补了wine-qq，wine-微信不能截图的缺憾) 设置简洁 缺点主要是因为deepin15.11是2019.7.20发布，还存在一些bug 网络自动代理设置不生效(Ubuntu中可以)(新版本对我的致命伤害,所以这个bug不解决，我就用windows去) 双屏中的副屏不能右键呼出菜单 每天一句叨叨万事万物由心生，如果累了，就把不重要的事情都推掉，然后做真正最重要的事情！ 还有，少折腾！比如你这三天就没有好好刷题，搞这个破deepin…然后浪费大把的赛前训练的时间！你已经后悔了…呜呜呜，对不起，我明天一定好好刷题]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>瞎折腾</tag>
        <tag>装系统</tag>
        <tag>Deepin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019南昌网络赛Hello 2019(cf 750E)线段树_算法日常[24/100]]]></title>
    <url>%2F2019%2F09%2F10%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-24-100%2F</url>
    <content type="text"><![CDATA[题目小趣事我在比赛一开场就开始看这题，然后没想出怎么写，12:07我校一个大佬lxc说他拿下了这题的一血，这是一个原题，cf 750E(我只能说:大佬都是移动题库!)然后做完另一个签到题之后，成为第一名，带榜了 赛后发现1Hello 2019 的提交情况如下:通过率：5.66% 正确提交 / 总提交：217 / 3837 达成学校带崩他校节奏的成就 赛后发现2这题tourist(codeforces霸榜第一，ACM world final 4小时ak第一人，被评为全球最厉害的十个程序员之一(和c语言之父这些人在一个榜单！))当年比赛的时候也没有做出来！然后大家说自己竟然尝试了一下当年T神都没有做出来的题目 题目链接计蒜客传送门codeforces 750E 题意给你一个串，然后多次询问左右区间，看删除多少个字符能使得这个区间内有9102，而没有8102的subsequence(codeforces中是有2017而没有2016) 题解 肉眼做法,表层理解,很容易看出只要删除8 因为8放在第一个不好处理，所以改成翻转string，并且翻转l,r,从而变成判断有2019没有2018， 因为每次询问一个区间，所以需要把dp状态扔到某个数据结构上,所以我们考虑线段树 线段树更新的时候是拿两段的信息合并，所以不能像做1~n的dp那样记录状态 考虑2017之间的间隔: | 2 | 0 | 1 | 9 | 0 1 2 3 4 线段树的每个节点存一个矩阵A.$mat_{ij}$表示使原串的子序列包含2019中第i个间隔到第j个间隔组成的子串，但不严格包含它的子序列最少需要删除的数字、 转移是显然的，和区间dp一样。枚举区间，枚举中间点，然后转移就好了。 考虑初值问题，显然的是非2、0、1、9、8的数字对答案不影响，所以令$a_{ii}$=0,$a_{ij}$=N(取不到就行) (i!=j) 考虑当前数字是2的时候，如果我希望只包含子串[0,0]（这里表示两个间隔间的子串），那么就必须删掉这个2，故$a_{00}$=1(可以理解为不想要成为2019是不思进取的行为，所以付出代价—&gt;这样可以在后面处理的时候淘汰掉这些大的状态值),如果希望包含子串[0,1]，那么什么都不用做，所以$a_{01}$=0。对于0、1、7同理。 考虑当前数字是8的时候，那么遇到子串[i,3]希望转移回自己(不想接受8来到达4状态)，那么需要付出1的代价，因为否则会包含子序列”2018”，同样如果遇到子串[i,4]希望转移回自己(不想接受8来到达4状态)，那么也需要付出1的代价(区间如果询问到这里就是真正要删除的数字了，因为4达到状态终点了)。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;const int N=200005;char s[N];struct Node &#123; int mat[5][5]; Node operator + (Node x) &#123; Node ans; for(int i=0;i&lt;5;++i) &#123; for(int j=0;j&lt;5;++j) &#123; ans.mat[i][j]=N; for(int k=0;k&lt;5;++k) &#123; ans.mat[i][j]=min(ans.mat[i][j],mat[i][k]+x.mat[k][j]); &#125; &#125; &#125; return ans; &#125;&#125;a[N&lt;&lt;2];void build(int l,int r,int x) &#123; if(l==r) &#123; for(int i=0;i&lt;5;++i) &#123; for(int j=0;j&lt;5;++j) &#123; a[x].mat[i][j]=(i==j)?0:N; &#125; &#125; if(s[l]=='2') a[x].mat[0][1]=0,a[x].mat[0][0]=1; if(s[l]=='0') a[x].mat[1][2]=0,a[x].mat[1][1]=1; if(s[l]=='1') a[x].mat[2][3]=0,a[x].mat[2][2]=1; if(s[l]=='9') a[x].mat[3][4]=0,a[x].mat[3][3]=1; if(s[l]=='8') a[x].mat[3][3]=1,a[x].mat[4][4]=1; return ; &#125; int m=l+r&gt;&gt;1; build(l,m,x&lt;&lt;1);build(m+1,r,x&lt;&lt;1|1); a[x]=a[x&lt;&lt;1]+a[x&lt;&lt;1|1];&#125;Node query(int l,int r,int L,int R,int x) &#123; if(L&lt;=l&amp;&amp;r&lt;=R) return a[x]; int m=l+r&gt;&gt;1; if(m&lt;L) return query(m+1,r,L,R,x&lt;&lt;1|1); if(m&gt;=R) return query(l,m,L,R,x&lt;&lt;1); return query(l,m,L,R,x&lt;&lt;1)+query(m+1,r,L,R,x&lt;&lt;1|1);&#125;int main() &#123; int n,q; while(~scanf("%d%d%s",&amp;n,&amp;q,s+1)) &#123; for(int i=1;i&lt;=n/2;i++)&#123; swap(s[i],s[n-i+1]); &#125; build(1,n,1); while(q--) &#123; int l,r;int tl,tr; scanf("%d%d",&amp;tl,&amp;tr); r = n-tl+1,l = n - tr + 1; int ans=query(1,n,l,r,1).mat[0][4]; if(ans==N) ans=-1; printf("%d\n",ans); &#125; &#125; return 0;&#125; 参考链接阿波罗2003 每天一句叨叨这个世界，想不想要永远不是最重要的，重要的，是要不要得起。 就像每个人都想成功，但是不是每个人都承担得起成功的代价]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>线段树</tag>
        <tag>算法学习日常</tag>
        <tag>思维题</tag>
        <tag>subsequence</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019南昌网络赛E.Magic Master_算法日常23[23/100]]]></title>
    <url>%2F2019%2F09%2F08%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-23-100%2F</url>
    <content type="text"><![CDATA[题目链接计蒜客传送门 题意魔法洗牌，洗完牌后进行1,2,2,2…2..操作，使得最终在John手上的牌是递减的 题解 看这个题目的数据范围我们可以猜测出这题是一个找规律的题目，那我们要怎么构造这个串呢？ 观察题目给的M=1，发现1,2,3都间隔了一个，然后我们推测是间隔M个放置，然后再继续推测之后得到下面的规律 走M次空格，第M+1次落下，第一个先填1，循环走 举例比如N = 5, M = 4;一开始是 1 _ _ _ _然后走4次空格，第5次落下 变成 1 2 _ _ _之后同理得到 1 2 _ 3 _ ==&gt; 1 2 _ 3 4 ==&gt; 1 2 5 3 4 实现通过模拟链表实现走M次空格(详见代码) 复杂度分析时间复杂度 O(T*N*M) ,接近 O(4*$10^9$) ,6s时间限制，按理1秒 2*$10^8$ 也只够跑 1.2*$10^9$ ,所以要么计蒜客评测机太快，要么数据不够强大,233 写作小收获用转义符\来保持某些符号不成为markdown的标记符，比如我要用多个*,就要防止变成markdown的斜体 AC代码123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 4e7 + 10;int pos[N], nxt[N], pre[N];int main() &#123; int T; scanf("%d", &amp;T); while(T--) &#123; int n, m, q, u, v; scanf("%d%d", &amp;n, &amp;m); for(int i=1;i&lt;=n;i++) nxt[i] = i+1, pre[i] = i-1; nxt[n] = 2; pre[2] = n; pos[1] = 1; int cur = 1; for(int i=2;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m+1;j++) &#123; cur = nxt[cur]; &#125; pos[cur] = i; u = pre[cur]; v = nxt[cur]; nxt[u] = v; pre[v] = u; &#125; scanf("%d", &amp;q); while(q--) &#123; scanf("%d", &amp;u); printf("%d\n", pos[u]); &#125; &#125; return 0;&#125; 每天一句叨叨别人撞了南墙才回头，而我撞了也不回头，我要跨过去]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第20周[20/521]]]></title>
    <url>%2F2019%2F09%2F08%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC20%E5%91%A8-20-521%2F</url>
    <content type="text"><![CDATA[AlgorithmSPOJ-LCS,SPOJ-LCS2-后缀自动机SAM专题训练_算法日常[20/100] spoj_nsubstr_sam后缀自动机_算法日常[21/100] 2019 徐州网络赛 M Longest subsequence_算法日常[22/100] 2019南昌网络赛E.Magic Master_算法日常23[23/100] ReviewHow to Take the Perfect Nap 其实自己之前看过这篇报告的中文版，现在看一遍英文版，又温习了一下，也拯救一下从暑假归来后每天要睡9个小时的自己，让自己能恢复战斗状态，每天6小时+30mins咖啡盹 晚上6小时，正好是4个完整的睡眠周期，完成4次慢波睡眠期处理记忆和信息和4次快速动眼期促进创造力，然后白天再来一个30mins的咖啡盹睡眠恢复精力和警觉(不要进入慢波睡眠，否则在慢波睡眠的时候醒来会很困)就够了，固定下来就好，如果长期不适应4个睡眠周期就加到5个 咖啡盹就是快速喝完咖啡马上睡30mins 固定睡眠时间，让生物钟适应 再附上一篇中文的把怎么睡觉，工作效率最高？ TipsCoding Pages申请SSL/TLS证书错误 ShareHexo-Next-Gemini主题透明化以及背景图片的更改和获取]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 徐州网络赛 M Longest subsequence_算法日常[22/100]]]></title>
    <url>%2F2019%2F09%2F07%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-22-100%2F</url>
    <content type="text"><![CDATA[题目链接计蒜客传送 题意求s中字典序大于t的最长子序列长度 注意sebsequence是子序列，可以不连续，substring才是子串，必须连续 题解对于答案来说，一定是 前i-1个字符和t的前i个一样，然后第i个字符比t的大 前缀为t，然后长度比t长 对于第一种情况，枚举这个 i ，然后找最小的 p 可以使得从(s[1]~s[p]) 中产生($t_1$,$t_2$ 到 $t_{i-1}$) ,然后在(s[p+1,n])中找最左边的比(t[i]) 大的字符，假如 找到了(s[pos])，那么后面的(s[pos+1,n]) 都可以加到答案后面（因为(s[pos] &gt; t[i]) 已经保证答案大于t了) 对于第二种，根据求第一种的方法，不难求出 如何找最小的p？预处理一个(sf[i][c]) 数组，表示(s[i]) 后面第一个字符(c)在哪里即可 如何找pos? 也是用预处理的数组循环最多26次即可 复杂度(O(n*26)) AC代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6+10;int sf[N][26];char s[N],t[N];int n,m;int main()&#123; scanf("%d%d",&amp;n,&amp;m); scanf("%s%s",s+1,t+1); for(int i=0;i&lt;26;i++) sf[n][i] = n+1; // 预处理一个(sf[i][c]) 数组，表示(s[i]) 后面第一个字符(c)在哪里 for(int i=n-1;i&gt;=0;i--)&#123; memcpy(sf[i],sf[i+1],sizeof sf[i]); sf[i][s[i+1]-'a'] = i+1; &#125; int p = 0,res = -1; for(int i=1;i&lt;=m;i++)&#123; int pos = n+1; for(int j=t[i]-'a'+1;j&lt;26;j++)&#123; pos = min(pos,sf[p][j]);//找到最近的那个s[pos] &gt; t[i]; &#125; if(pos != n+1) res = max(res,i+n-pos);//(n-pos)为后面还可以加的长度 // p在s中找到与t相同的"前缀"(不连续子串可以跳跃) p = sf[p][t[i]-'a']; if(p == n+1)break; &#125; // 如果完全相同，那就要严格更大，所以p&lt;n if(p &lt; n) res = max(res,n-p+m); printf("%d\n",res); return 0;&#125; 借鉴https://www.codetd.com/article/7223660 每天一句叨叨有时候不试一下，永远都不知道自己有多垃圾！不过没有关系，至少我永远向上生长，这就是生命！保持乐观，积极生活，因为人相对于宇宙来说是很渺小的，所以静静观察自己的生活，享受生活吧！]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spoj_nsubstr_sam后缀自动机_算法日常[21/100]]]></title>
    <url>%2F2019%2F09%2F06%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-21-100%2F</url>
    <content type="text"><![CDATA[题目链接spojVJ 2019年9月6日22:46:10VJ挂了…只能在spoj(所以注册了一手)上交先了，明天来补这个链接 题意给你一个串,求出出现次数最多的长度为i(属于[1,|S|])的字串,输出它的出现次数 题解 每个节点的endpos集合就是它自己代表的子串在串中出现的次数,然后以这个子串为后缀的更长的串出现的位置通过拓扑排序累加上来了,存到了r[i]中表示这个节点代表的子串在整个串中所有出现的位置总个数！&lt;==&gt;节点i代表的字串的出现次数,所以r[i]和F[len[i]]用max维护就行了 然后拓扑排序可以用基数排序来操作，SAM中常用(不用怕，我注释很多) 因为长度较短的串的F[i]值维护出来之后有可能是比F[i+1]小的，这样的话最优策略是取i+1长的串的后i长的串，这样F[i]值能变大，所以f[i] = max(F[i],F[i+1]) AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;const int N=250010;char s[N];int r[N&lt;&lt;1],id[N&lt;&lt;1],b[N],F[N];struct sam&#123; // 注意N是题目给的n的两倍,因为节点数最多有2*n-1个 int p,q,np,nq,cnt,last,a[N&lt;&lt;1][26],l[N&lt;&lt;1],f[N&lt;&lt;1]; sam()&#123;cnt=0;last=++cnt;&#125; void init()&#123; cnt=0;last=++cnt; memset(a,0,sizeof(a)); memset(l,0,sizeof(l)); memset(f,0,sizeof(f)); &#125; void extend(int c)&#123; p=last;np=last=++cnt;l[np]=l[p]+1; while(!a[p][c]&amp;&amp;p)a[p][c]=np,p=f[p]; if(!p)f[np]=1; else&#123; q=a[p][c]; if(l[p]+1==l[q])f[np]=q; else&#123; nq=++cnt;l[nq]=l[p]+1; memcpy(a[nq],a[q],sizeof(a[q])); f[nq]=f[q]; f[np]=f[q]=nq; while(a[p][c]==q)a[p][c]=nq,p=f[p]; &#125; &#125; &#125; void solve()&#123; init(); scanf("%s",s); int n=strlen(s); for(int i=0;i&lt;n;i++)extend(s[i]-'a'); // 给主链的right值先+1.因为他们都是叶子节点(从构造算法就可以看出来,虽然这个性质我做了这个题才知道) // 源点就是1号节点 for(int p=1,i=0;i&lt;n;i++) p=a[p][s[i]-'a'],r[p]++; // 按照len[x]从小到大基数排序，相当于对SAM图进行拓扑排序(源点也是加入排序的) // 第一for先按照长度计数，然后第二for再对长度赋予排名，最后第三for让节点长度排名对应于节点 // 同长度下，先出现的节点排名大(数值小)--&gt;这个没有多大关系,因为同长度的必定不在同一条拓扑链上 // 因为从源点出发的每一条链的长度都是递增的 for(int i=1;i&lt;=cnt;i++) b[l[i]]++; // 下面的for的i表示的是长度 for(int i=1;i&lt;=n;i++) b[i]+=b[i-1]; for(int i=1;i&lt;=cnt;i++) id[b[l[i]]--]=i; // 从后往前for,自底向上更新parent的right大小 for(int i=cnt;i&gt;=1;i--) r[f[id[i]]]+=r[id[i]]; // 更新答案 // 每个节点的endpos集合就是它自己代表的子串在串中出现的次数 // 然后以这个子串为后缀的更长的串出现的位置通过拓扑排序累加上来了, // 存到了r[i]中表示这个节点代表的子串在整个串中所有出现的位置！&lt;==&gt;出现次数 // 所以r[i]和F[len[i]]用max维护就行了 for (int i=1;i&lt;=cnt;i++) F[l[i]]=max(F[l[i]],r[i]); // 因为长度较短的串的F[i]值有可能是比F[i+1]小的，这样的话最优策略是取i+1长的串的后i长 // 所以f[i] = max(F[i],F[i+1]) for (int i=n;i&gt;=1;i--) F[i]=max(F[i],F[i+1]); for (int i=1;i&lt;=n;i++) printf("%d\n",F[i]); &#125;&#125; sam;int T;int main()&#123; sam.solve(); return 0;&#125; 每天一句叨叨有时候状态差，但你不能放弃，因为算法不经历撕心裂肺的思考和试错，是没有生命力的]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Next-Gemini主题透明化以及背景图片的更改和获取]]></title>
    <url>%2F2019%2F09%2F06%2FHexo-Next-Gemini%E4%B8%BB%E9%A2%98%E9%80%8F%E6%98%8E%E5%8C%96%E4%BB%A5%E5%8F%8A%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E7%9A%84%E6%9B%B4%E6%94%B9%2F</url>
    <content type="text"><![CDATA[背景图片的更改自动变化背景图片或者固定背景图找到路径下的custom.styl文件：hexo/themes/next/source/css/_custom/在该文件中加入如下代码(其实next中有这个代码，只是开发团队默认注释掉了) 自动背景使用的是unsplash.com提供的API链接，感谢 1234567891011121314@media screen and (min-width:1200px) &#123; body &#123; background-image:url(https://source.unsplash.com/random/1600x900); //这一行的括号里填背景图片的路径，将图片重命名为background.jpg放在\themes\next\source\images下 // background-image:url(/images/background.jpg); //这一行的括号里填背景图片的路径，将图片重命名为background.jpg放在\themes\next\source\images下 background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size:100% 100%; &#125; #footer a &#123; coler: #eee; &#125;&#125; 代码注解 background:url为图片路径，也可以直接使用链接 background-repeat：若果背景图片不能全屏，那么是否平铺显示，充满屏幕 background-attachment：背景是否随着网页上下滚动而滚动，fixed为固定 background-position：就是调整图片的位置 background-size：图片展示大小，这里设置100% 100%的意义为：如果背景图片不能全屏，那么是否通过拉伸的方式将背景强制拉伸至全屏显示。(让背景图铺满整个页面，简直就是强迫症的解药啊!!!) 若使用固定图片，那么要将图片重命名为background.jpg放在\themes\next\source\images下(说实话，小编一开始不知道要重命名成background，写文章的时候才发现，写文章还是有用呀) 注意如果很在意网站打开速度的话，不建议使用特别大的背景图片或者是自动变化的背景，因为网站会由于图片太大会拖慢整个网站的载入速度!! Gemini主题透明化预备知识Q:为什么要修改Pisces中的文件？ A:因为Gemini文件导入了Pisces文件夹中的4个文件 内容板块透明 博客根目录 themes\next\source\css_schemes\Pisces_layout.styl 文件 .content-wrap 标签下 background: white修改为：background: rgba(255,255,255,0.7); //0.7是透明度 博客根目录 themes\next\source\css_schemes\Gemini\index.styl文件 .post-block 标签下的 background: white修改为：background: rgba(255,255,255,0.7); //0.7是透明度 分页(主页最下面的那一小块)博客根目录 themes\next\source\css_schemes\Gemini\index.styl 文件 .pagination 标签下的 background: white修改为：background: rgba(255,255,255,0.7); //0.7是透明度 菜单栏背景 博客根目录 themes\next\source\css_schemes\Pisces_layout.styl 文件 .header-inner 标签下 background: white修改为：background: rgba(255,255,255,0.7); //0.7是透明度 博客根目录 themes\next\source\css_schemes\Pisces_sidebar.styl 文件 .sidebar 标签下 增加一行:opacity: 0.7; // 0.7透明度自己选择 站点概况背景 博客根目录 themes\next\source\css_schemes\Pisces_sidebar.styl 文件 .sidebar-inner 标签下 background: white修改为：background: rgba(255,255,255,0.7); //0.7是透明度 然后修改博客根目录 themes\next\source\css_schemes\Pisces_layout.styl 文件 .sidebar 标签下 background: $body-bg-color修改为：background: rgba(255,255,255,0.7); //0.7是透明度 评论区背景 博客根目录 themes\next\source\css_schemes\Gemini\index.styl文件 .comments 标签下的 background: white修改为：background: rgba(255,255,255,0.7); //0.7是透明度 效果图 看到精美背景想要保存？比如我看到了这张背景和我的3D雪花特效的叠加效果简直惊艳 好，我教你啊！ 按F12进入开发者，然后移动开发者模块和页面之间的分隔线让页面宽度变大到显示背景图(因为之前设置中设置了只有达到一定宽度才会显示图片) 在source栏目下找到image.unsplash文件夹下的图id,当然可以立马保存啦(操作详见下图) 参考链接大佬-http://wiki.johnhao.tech大佬-芒果浩明大佬-路人S]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPOJ-LCS,SPOJ-LCS2-后缀自动机SAM专题训练_算法日常[20/100]]]></title>
    <url>%2F2019%2F09%2F05%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-20-100%2F</url>
    <content type="text"><![CDATA[LCS题目链接VJ上的LCSspoj上的LCS 题意给你两个串，求两个串的最长公共字串 解题思路大佬:对A建后缀自动机，然后用B去匹配，若能匹配上就转移到儿子，否则沿着parent树向上跳 我的补充:先看当下B串中新加的字符x是否能通过上次匹配的后缀来转移，如果能转移就直接加，否则就要跳到fa树上去匹配更短endpos为p的后缀(为了找到新加入的字符x的转移)，然后在匹配到之后就是匹配到的长度+1(要加上刚进入的x字符的一个长度) AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;const int N=250010;char s1[N],s2[N];int ans;struct sam&#123; // 注意N是题目给的n的两倍,因为节点数最多有2*n-1个 int p,q,np,nq,cnt,last,a[N&lt;&lt;1][26],l[N&lt;&lt;1],f[N&lt;&lt;1]; sam()&#123;cnt=0;last=++cnt;&#125; void init()&#123; cnt=0;last=++cnt; memset(a,0,sizeof(a)); memset(l,0,sizeof(l)); memset(f,0,sizeof(f)); &#125; void extend(int c)&#123; p=last;np=last=++cnt;l[np]=l[p]+1; while(!a[p][c]&amp;&amp;p)a[p][c]=np,p=f[p]; if(!p)f[np]=1; else&#123; q=a[p][c]; if(l[p]+1==l[q])f[np]=q; else&#123; nq=++cnt;l[nq]=l[p]+1; memcpy(a[nq],a[q],sizeof(a[q])); f[nq]=f[q]; f[np]=f[q]=nq; while(a[p][c]==q)a[p][c]=nq,p=f[p]; &#125; &#125; &#125; void solve()&#123; init(); scanf("%s",s1);scanf("%s",s2); int n=strlen(s1); for(int i=0;i&lt;n;i++)extend(s1[i]-'a'); ans = 0;n=strlen(s2); for(int i=0,p=1,tp=0;i&lt;n;i++)&#123; int x = s2[i] - 'a'; if(a[p][x]) tp++,p = a[p][x]; else&#123; for(;p&amp;&amp;!a[p][x];p=f[p]); if(!p) tp=0,p=1; else tp = l[p] + 1,p = a[p][x]; &#125; ans = max(ans,tp); &#125; printf("%d\n",ans ); &#125;&#125;sam;int T;int main()&#123; sam.solve(); return 0;&#125; LCS2题目链接VJ上的LCS2spoj上的LCS2 题意给你多个串，求他们的最长公共字串 解题思路 超级感谢大佬的博文 大佬的想法(果然就是多种值维护一下,但是我竟然没有勇气想下去…-&gt;弱鸡下次勇敢点): poj2774或者就是LCS那道题，对一个串建立后缀自动机，另一个在上面匹配。 (下面的方法一在代码中有详细注释，建议复制代码后结合起来看) 这道题是对多个串求。那么同样，让每个串在后缀自动机上匹配，然后记录在后缀自动机的每个节点上记录，当前串在这个位置和第一个串的最大匹配数，h数组。 然后mn数组，每次对于这所有的节点的h取小，为从第2个串到现在所有的串，都能在这个节点上匹配的长度。 因为一旦某个节点匹配上了，那么它的父节点（parent树）的父节点都会匹配上（因为父节点是当前点的后缀）， 所以按拓扑倒序，更新父节点的h，为父节点的len，（即最大长度）。 第二种写法是对n-1个字符串建立SAM，然后用最后一个串在n-1个串上匹配，每个自动机上都有一个当前的指针cur，当前答案ans。对最后一个串从头开始扫，求出最后一个串和每个串以当前字符结尾的最大匹配长度，在这里面取小，每次加入一个字符，可以直接判断cur的下一位，不需要从头开始。空间太大。 总结:两种写法大同小异，只枚举举的顺序不同而已。 其实方法更简洁，更容易看懂，比解法一的缺点是多花了很多空间 方法一AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// 方法一 80ms 25.6MB#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int read() &#123; int x=0,f=1;char ch=getchar();for(;!isdigit(ch);ch=getchar())if(ch=='-')f=-1; for (;isdigit(ch);ch=getchar())x=x*10+ch-'0';return x*f;&#125;const int N = 100010;struct Suffix_Automaton&#123; int fa[N&lt;&lt;1], trans[N&lt;&lt;1][26], len[N&lt;&lt;1], Last, Index; int v[N], sa[N&lt;&lt;1], mn[N&lt;&lt;1], h[N&lt;&lt;1]; char s[N]; void extend(int c) &#123; int P = Last,NP = ++Index; len[NP] = len[P] + 1; for (; P&amp;&amp;!trans[P][c]; P=fa[P]) trans[P][c] = NP; if (!P) fa[NP] = 1; //- else &#123; int Q = trans[P][c]; if (len[P] + 1 == len[Q]) fa[NP] = Q; else &#123; int NQ = ++Index; fa[NQ] = fa[Q]; len[NQ] = len[P] + 1; memcpy(trans[NQ], trans[Q], sizeof trans[Q]); fa[Q] = NQ; fa[NP] = NQ; for (; P&amp;&amp;trans[P][c]==Q; P=fa[P]) trans[P][c] = NQ; &#125; &#125; Last = NP; &#125; void build() &#123; Last = Index = 1; scanf("%s",s+1); int n = strlen(s+1); for (int i=1; i&lt;=n; ++i) extend(s[i] - 'a'); // index和第一个串s1的下标大致是对应的，但是中间还有克隆的节点 for (int i=1; i&lt;=Index; ++i) v[len[i]] ++; // 确实是只有n种长度..前缀的后缀--&gt;所有的串--&gt;所以只用n // 这里求前缀和只是为了下面能够求出排名数组,让他们按照深度占比权值(有点像权值线段树的那种) for (int i=1; i&lt;=n; ++i) v[i] += v[i-1]; // sa[i] 排名为i的节点。按深度排名（拓扑用） // i号节点按照它的len在v中前缀和减减---&gt;其实就是排名,按照节点的长度(也就是深度)---&gt;因为越深越长 for (int i=1; i&lt;=Index; ++i) sa[ v[len[i]]-- ] = i; &#125; void calcc() &#123; int n = strlen(s+1), now = 0, p = 1; memset(h, 0, sizeof(h)); for (int i=1; i&lt;=n; ++i) &#123; int c = s[i] - 'a'; if (trans[p][c]) p = trans[p][c], now ++; else &#123; for (; p&amp;&amp;!trans[p][c]; p=fa[p]); if (!p) now = 0, p = 1; else now = len[p] + 1, p = trans[p][c]; &#125; h[p] = max(h[p], now); &#125; // 拓扑倒序，parent树中从深度深的到浅的 for (int i=Index; i&gt;=1; --i) &#123; int t = sa[i]; mn[t] = min(mn[t], h[t]); // t节点有匹配,并且它的父节点(后缀link)不为源点---&gt;那么让它的父节点的匹配值等于父节点的长度 // 因为前面的操作是对最长的适配，所以没有管较短串的匹配,所以这里管一下 // 但是为什么只对父节点，而不对更爷爷节点什么的呢，因为这个拓扑排序从底部向上，所以父节点在之后会出现 // 所以爷爷节点由后面出现的父节点去管理就行了 ====》 太精妙了，amazing！ if (h[t] &amp;&amp; fa[t]) h[fa[t]] = len[fa[t]]; &#125; &#125; void solve() &#123; build(); memset(mn, 0x3f, sizeof(mn)); while (scanf("%s",s+1) != EOF) calcc(); int ans = 0; for (int i=1; i&lt;=Index; ++i) ans = max(ans, mn[i]); printf("%d",ans); &#125;&#125;sam;int main() &#123; sam.solve(); return 0;&#125; 方法二AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 方法二---N-1个自动机 130ms 175.1MB#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int read() &#123; int x=0,f=1;char ch=getchar();for(;!isdigit(ch);ch=getchar())if(ch=='-')f=-1; for (;isdigit(ch);ch=getchar())x=x*10+ch-'0';return x*f;&#125;const int N = 200010;struct SuffixAutomaton&#123; int Last, Index, res, cur, fa[N], trans[N][26], len[N]; SuffixAutomaton() &#123;Last = Index = cur = 1; res = 0;&#125; void extend(int c) &#123; int P = Last, NP = ++Index; len[NP] = len[P] + 1; for (; P&amp;&amp;!trans[P][c]; P=fa[P]) trans[P][c] = NP; if (!P) fa[NP] = 1; else &#123; int Q = trans[P][c]; if (len[P] + 1 == len[Q]) fa[NP] = Q; else &#123; int NQ = ++Index; fa[NQ] = fa[Q]; len[NQ] = len[P] + 1; memcpy(trans[NQ], trans[Q], sizeof trans[Q]); fa[Q] = NQ; fa[NP] = NQ; for (; P&amp;&amp;trans[P][c]==Q; P=fa[P]) trans[P][c] = NQ; &#125; &#125; Last = NP; &#125; int solve(int c) &#123; if (trans[cur][c]) &#123;cur = trans[cur][c]; res++; return res;&#125; for (; cur&amp;&amp;!trans[cur][c]; cur=fa[cur]); if (!cur) res = 0, cur = 1; else res = len[cur] + 1, cur = trans[cur][c]; return res; &#125;&#125;sam[9];char s[N];char str[N&gt;&gt;1];int main() &#123; int n = 0,t = 0,len; scanf("%s",str+1); while (scanf("%s",s+1)!=EOF) &#123; len = strlen(s + 1); for (int i=1; i&lt;=len; ++i) sam[t].extend(s[i] - 'a'); t ++; &#125; int ans = 0; len = strlen(str+1); for (int i=1; i&lt;=len; ++i) &#123; int tmp = 1e9; for (int j=0; j&lt;t; ++j) tmp = min(tmp, sam[j].solve(str[i] - 'a')); ans = max(ans, tmp); &#125; printf("%d",ans); return 0;&#125; 每天一句叨叨没有自闭，何来爆爽！向自闭的日子致敬！]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第19周[19/521]]]></title>
    <url>%2F2019%2F09%2F01%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC19%E5%91%A8-19-521%2F</url>
    <content type="text"><![CDATA[Algorithm这段时间生活有点动荡，刷得题就少了 ReviewThe Huawei Sanction Might Just Pop the Tech Bubble对华为的制裁应该不会引发这个外国科技大佬所说的互联网圈泡沫，但是下跌确实是很可能，所以科技界的朋友们也要赶紧学会华为的危机意识—永远为”冬天”和”黑天鹅事件”做准备 Tips后缀数组学习资料 ShareSAM后缀自动机学习路线]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SAM后缀自动机学习路线_算法日常[19/100]]]></title>
    <url>%2F2019%2F08%2F30%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-19-100%2F</url>
    <content type="text"><![CDATA[学习路径推荐 网上有很多的学习SAM的资料，但是很多资料写得比较全面，导致一开始看可能看不懂(可能只是因为博主自己比较菜)，然后博主自己整理了一个学习路线，希望对大家有点帮助 简介版本的SAM 比较全面的SAM版本 个人感觉这里的后缀链接初次看有点难懂 还有那个算法的思路也会有点懵逼，懵逼的话建议可以先看紧接在下面的算法正确性证明，不然很容易自闭 建议先看简介版本的SAM的后缀链接的介绍先然后再来看这个比较好_大佬请无视 经典题集 2019年9月5日14:21:10 补充，建议参考链接增加以及自己学习历程的一些心得 增加的参考链接: 史上最通俗的后缀自动机详解 学习历程: 我比较菜，所以断断续续地看了5天(主要是看不懂然后就总发呆…(雾))，然后第6天重新看了一遍oi-wiki的教程，发现自己看得懂了！(得益于前几天不断地看简介版和通俗易懂版的，让自己重新看的时候感觉许多都会，然后就有了一个比较全面的认识，然后就终于看懂了SAM算法，自闭6天后要不要这么爽) 学习心得: 找一个安静的环境，让自己能够保持专注 抽出一整块的时间来看SAM专题 一次没有看懂没关系，反复看，找各种不同的资料看 手动笔记，写写画画 最终总结出自己的笔记 避坑提醒: oi-wiki给的板子中用的是map映射的next，建议改成int next[符号集大小]，因为我做题时map，unordered_map都TLE了… 送一个bug_free的注释123456789101112131415161718192021222324252627282930/** * ┏┓ ┏┓+ + * ┏┛┻━━━┛┻┓ + + * ┃ ┃ * ┃ ┃ ++ + + + * ████━████┃+ * ┃ ┃ + * ┃ ┻ ┃ * ┃ ┃ + + * ┗━┓ ┏━┛ * ┃ ┃ * ┃ ┃ + + + + * ┃ ┃ Code is far away from bug with the animal protecting * ┃ ┃ + 神兽保佑,代码无bug * ┃ ┃ * ┃ ┃ + * ┃ ┗━━━┓ + + * ┃ ┣┓ * ┃ ┏┛ * ┗┓┓┏━┳┓┏┛ + + + + * ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛+ + + + */#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; cout&lt;&lt;"厉Hello World哥!"&lt;&lt;endl; return 0;&#125; 每天一句叨叨 生活或许很苦，但我偏要酷 认清生活的残酷然后依旧挣扎着往上爬，致平凡世界里的英雄们！]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>后缀数组</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第18周[18/521]]]></title>
    <url>%2F2019%2F08%2F24%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC18%E5%91%A8-18-521%2F</url>
    <content type="text"><![CDATA[Algorithm后缀数组自学并题目训练 Review13 Things You Should Give Up If You Want To Be Successful Give Up On Saying YES To Things That Don’t Support Your GoalsSuccessful people know that in order to accomplish their goals, they will have to say NO to certain tasks, activities, and demands from their friends, family, and colleagues.In the short-term, you might sacrifice a bit of instant gratification, but when your goals come to fruition, it will all be worth it. 是的，这也是杜月笙先生教给我的事情，成功需要代价 Tips生活很苦，我偏要酷 Share2019杭电多校9题解_算法日常[14/100] 后缀数组学习路径以及后缀数组板子推送_算法日常[15/100] 后缀数组基础题poj1743详解_算法日常[16/100] HDU5008详解_后缀数组_二分_RMQ_算法日常[17/100] 2019CCPC网络预选赛1003题解_算法日常[18/100]]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019CCPC网络预选赛1003 K-th occurrence 题解_算法日常[18/100]]]></title>
    <url>%2F2019%2F08%2F23%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-18-100%2F</url>
    <content type="text"><![CDATA[K-th occurrence题目链接VJ上面HDOJ上面 题解解法一SAM解法 2019年9月4日19:24:25 补充，不好意思，博主太菜了，补SAM补了6天才看懂，现在第7天才看懂SAM的写法，所以补充一下 对于题解中说的倍增数组就是代码中的Fa数组，构造极其精巧，建议看一下解法一注释版的代码 关于权值线段树(就是题解中说的给每种前缀设置一种权值)，其实就是建立线段树的时候，让主席树的每个点都有个权值，这样就可以在询问的时候方便的找到第k大了(具体见代码) 解法二SA解法ST表维护下 后缀排序后的公共长度 的最小值，然后二分找出左右符合的位置，主席树维护下排序后的序列，然后主席树查询第k大即可 2019年8月27日19:23:14 补充(代码也补充为注释版)(发现写blog的时候自己的理解确实有明显加深!所以还是要坚持写blog,推荐大家也可以写点博客啥的) 我们想要找到所有的字串s的第k个，就要找到所有字串出现的位置，用后缀数组去找的方法就是使用后缀的最长公共前缀长度相同来实现寻找，即找到height数组的一段连续区间的最小值都要是s的长度(当然前缀是s),这里可以用二分区间查找st表版本的rmq信息来确定最终的左右区间，然后再用可持久化线段树来找到这个排名区间里的第k个起始位置(之前建立可持久化线段树的时候就通过位置信息让每个rank字串在前一个rank字串所建立的线段树树上(最初为空树)新建一条分支树),rank1字串对应于版本1的主席树(可持久化线段树)，rank2字串对应于版本2的主席树，然后我们询问rank区间[l,r]的时候，就是直接用版本[l,r]的主席树的节点数差来看这里面的字串数是否达到了k个(之前已经保证了前缀相同)，是则继续访问左子树第k大，否则访问右子树第k-左边的个数大(可以注意到我们左右子树和位置的[l,mid],[mid+1,r]在建树的时候是假定了空间映射关系的!),这样就可以找到对应位置了 AC代码解法一SAM解法感谢CSU一个大佬提供代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;iostream&gt;#include&lt;complex&gt;#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;string.h&gt;using namespace std;char s[100010];int T[200010][30],fa[200010],len[200010],cnt,last,n;void build(int v)&#123; int i,p=last,np,q,nq; last=np=++cnt; len[np]=len[p]+1; for(;p&amp;&amp;T[p][v]==0;p=fa[p]) T[p][v]=np; if(p==0) fa[np]=1; else&#123; q=T[p][v]; if(len[q]==len[p]+1) fa[np]=q; else&#123; nq=++cnt; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; for(i=0;i&lt;27;i++) T[nq][i]=T[q][i]; for(;T[p][v]==q;p=fa[p]) T[p][v]=nq; &#125; &#125;&#125;int root[200010],num;struct Q&#123; int L,R,sum;&#125;A[8000000];void update(int &amp;x,int l,int r,int k,int v)&#123; A[++num]=A[x]; x=num; A[x].sum++; if(l==r) return; int mid=(l+r)/2; if(k&lt;=mid) update(A[x].L,l,mid,k,v); else update(A[x].R,mid+1,r,k,v);&#125;int mer(int a,int b,int l,int r)&#123; if(a==0||b==0) return a+b; int z=++num,mid=(l+r)/2; if(l==r)&#123; A[z].sum=A[a].sum|A[b].sum; return z; &#125; A[z].L=mer(A[a].L,A[b].L,l,mid); A[z].R=mer(A[a].R,A[b].R,mid+1,r); A[z].sum=A[A[z].L].sum+A[A[z].R].sum; return z;&#125;int qkth(int x,int l,int r,int k)&#123; if(l==r) return l; int mid=(l+r)/2; if(k&lt;=A[A[x].L].sum) return qkth(A[x].L,l,mid,k); else return qkth(A[x].R,mid+1,r,k-A[A[x].L].sum);&#125;vector&lt;int&gt;g[200010];int Fa[200010][25],pos[200010];void dfs(int u)&#123; int i,v; for(i=1;i&lt;=19;i++) Fa[u][i]=Fa[Fa[u][i-1]][i-1]; for(i=0;i&lt;g[u].size();i++)&#123; v=g[u][i]; Fa[v][0]=u; dfs(v); root[u]=mer(root[u],root[v],1,n); &#125;&#125;int main()&#123; int i,m,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;m); scanf("%s",s+1); cnt=last=1; memset(T,0,sizeof(T)); for(i=0;i&lt;=200000;i++) g[i].clear(); for(i=1;s[i];i++) build(s[i]-'a'); for(i=1;i&lt;=cnt;i++) g[fa[i]].push_back(i); int p=1,v; memset(root,0,sizeof(root)); A[0].L=A[0].R=A[0].sum=num=0; for(i=1;s[i];i++)&#123; v=s[i]-'a'; p=T[p][v]; pos[i]=p; update(root[p],1,n,i,1); &#125; dfs(1); int l,r,k,u,a; while(m--)&#123; scanf("%d%d%d",&amp;l,&amp;r,&amp;a); p=pos[r]; k=r-l+1; for(i=19;i&gt;=0;i--) if(len[Fa[p][i]]&gt;=k) p=Fa[p][i]; if(a&gt;A[root[p]].sum) printf("-1\n"); else&#123; u=qkth(root[p],1,n,a); printf("%d\n",u-k+1); &#125; &#125; &#125; return 0;&#125; SAM解法注释版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177/*2019年9月3日20:44:23 开始看2019年9月4日11:39:03 再看主席树+SAM都是刚刚学了一点点皮毛，然后就要接受这种魔鬼题目训练，真是毒打感觉后缀数组用的是各种后缀的前缀，而后缀自动机则是用前缀的后缀比较多，因为endpos就相当于前缀的感觉后缀数组的LCP(Longest Common Prefix)问题等价于后缀树的最小公共祖先LCA(Least Common Ancestor)问题前者是后缀的共同前缀，后者是前缀endpos的共同后缀(link)---&gt; 也即sam构成的后缀link树的lca有一点点的融会贯通的感觉真他妈的爽啊！题意:T组,N次询问, l,r这个子串的第k次出现*/#include&lt;iostream&gt;#include&lt;complex&gt;#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;string.h&gt;using namespace std;char s[100010];int T[200010][30],fa[200010],len[200010],cnt,last,n;/*这里是建立SAM.大佬的板子真滴简洁..*/void build(int v)&#123; int i,p=last,np,q,nq; last=np=++cnt; len[np]=len[p]+1; for(;p&amp;&amp;T[p][v]==0;p=fa[p]) T[p][v]=np; if(p==0) fa[np]=1; else&#123; q=T[p][v]; if(len[q]==len[p]+1) fa[np]=q; else&#123; nq=++cnt; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; for(i=0;i&lt;27;i++) T[nq][i]=T[q][i]; for(;T[p][v]==q;p=fa[p]) T[p][v]=nq; &#125; &#125;&#125;/*root[i]数组表示的是endpos为i的节点*/int root[200010],num;/*开了40倍的这里是主席树,若只考虑最大的大小和n次修改,每次log(n)的话,那么其实只要2n-1+nlog(n)就行也就是只要19e5===&gt;也可以直接n &lt;&lt; 5 ,即(2^5)*n */struct Q&#123; int L,R,sum;&#125; A[8000000];/*pos[i]=p;---&gt; pos数组就是endpos数组,不懂可以参考[oi-wiki/sam](https://oi-wiki.org/string/sam/)update(root[p],1,n,i,1);*/void update(int &amp;x,int l,int r,int k,int v)&#123; /*下面三句话就是1. 获取之前的节点(之前也可能是空节点)信息 2. 让当前的root[]等于新得到的id(sum)_3.然后在这个id上进行玩耍*/ /*总体上就是记录一条新建的边上的所有信息,最主要的是维护权值--为了求出第k大*/ /*我们从递归的角度看进去,发现每个node左右点都是从1开始一直加的，所以这就是权值主席树*/ A[++num]=A[x]; x=num; A[x].sum++; if(l==r) return; int mid=(l+r)/2; if(k&lt;=mid) update(A[x].L,l,mid,k,v); else update(A[x].R,mid+1,r,k,v);&#125;/*root[u]=mer(root[u],root[v],1,n);*/int mer(int a,int b,int l,int r)&#123; if(a==0||b==0) return a+b; int z=++num,mid=(l+r)/2; if(l==r)&#123; /*因为sum要么一样,要么某一个为0,所以用'或'操作*/ A[z].sum=A[a].sum|A[b].sum; return z; &#125; A[z].L=mer(A[a].L,A[b].L,l,mid); A[z].R=mer(A[a].R,A[b].R,mid+1,r); A[z].sum=A[A[z].L].sum+A[A[z].R].sum; return z;&#125;/*u=qkth(root[p],1,n,a);printf("%d\n",u-k+1);返回的是endpos值...也就是返回的是串的右端点...也就是说答案是u-k+1*/int qkth(int x,int l,int r,int k)&#123; if(l==r) return l; int mid=(l+r)/2; if(k&lt;=A[A[x].L].sum) return qkth(A[x].L,l,mid,k); else return qkth(A[x].R,mid+1,r,k-A[A[x].L].sum);&#125;vector&lt;int&gt;g[200010];int Fa[200010][25],pos[200010];/*dfs(1)*/void dfs(int u)&#123; int i,v; /*这里i为什么是&lt;=19?...---&gt;每次插入主席树一条边需要log(n),这题就是约等18左右,开到19是为了保险 这里的大的Fa不是sam中的fa*/ /*最最开始这里的初始化都是0,后面就是链状的，用i来dp，真是太巧妙了！ 比如Fa[u][0]=0;Fa[v][0]=u;Fa[w][0]=v. 那么Fa[w][1]=Fa[v][0]=u 这就是dp叠层数了===&gt; 所以后面使用的时候就直接用Fa[p][i]就行了*/ for(i=1;i&lt;=19;i++) Fa[u][i]=Fa[Fa[u][i-1]][i-1]; for(i=0;i&lt;g[u].size();i++)&#123; v=g[u][i]; /*v的直接父亲是u...*/ Fa[v][0]=u; dfs(v); root[u]=mer(root[u],root[v],1,n); &#125;&#125;int main()&#123; int i,m,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;m); scanf("%s",s+1); cnt=last=1; memset(T,0,sizeof(T)); for(i=0;i&lt;=200000;i++) g[i].clear(); /*构建SAM*/ for(i=1;s[i];i++) build(s[i]-'a'); /*i的后缀link放入i,也就是g表示源点到终止节点的方向,fa数组的反hash*/ for(i=1;i&lt;=cnt;i++) g[fa[i]].push_back(i); int p=1,v; memset(root,0,sizeof(root)); A[0].L=A[0].R=A[0].sum=num=0; /*插入构建主席树*/ for(i=1;s[i];i++)&#123; v=s[i]-'a'; /*p就是转移之后的节点啊，所以就是说每个节点在主席树上都是一棵新树*/ p=T[p][v]; /*对，pos就是endpos，转移就是转移到下一个状态*/ pos[i]=p; update(root[p],1,n,i,1); &#125; /*前面生成g[]数组的时候,fa[i]最小值就是1,所以dfs(1)就是从源点跑到各个点去,然后合并每个endpos对应的所有后缀...*/ dfs(1); int l,r,k,u,a; while(m--)&#123; scanf("%d%d%d",&amp;l,&amp;r,&amp;a); /*获取endpos为r的状态点*/ p=pos[r]; /*这里的k竟然是长度...*/ k=r-l+1; /*为啥又是19,这个是哪来的数字！==&gt;难道说是一个log(n)的大小！好像是！ 那么这里的意思应该就是: 找出最短的长度大于要求的字串长的后缀 然后如果对应的节点的权值不够a(其实就是题中说的k),那么直接输出-1 否则就去主席树中找出答案，所以dfs(1)应该就是从源点出发找到终止节点之类的操作 可得好好研究一下Fa数组的作用! 这里从它的作用来看就是用在了自成一体的fa树！就是 答案中说的 扒出 parent树 ，然后利用这个来操作...找到这个串位置对应于主席树的位置 因为之前的fa[]是与主席树没有任何联系的，所以我们需要这个Fa来构建联系 */ for(i=19;i&gt;=0;i--) if(len[Fa[p][i]]&gt;=k) p=Fa[p][i]; if(a&gt;A[root[p]].sum) printf("-1\n"); else&#123; u=qkth(root[p],1,n,a); printf("%d\n",u-k+1); &#125; &#125; &#125; return 0;&#125; 解法二SA解法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3fconst int N=100100;int t1[N],t2[N],sum[N],rk[N],ht[N],sa[N],str[N];char s[100100];/*最小19*N,保守(2^5)*N(即N&lt;&lt;5)*/struct node1 &#123; int l, r; int val;&#125; tr[N * 22];int f[N][22];int root[N], tot;void get_sa(int n,int m)&#123; int *x=t1,*y=t2; for(int i=0;i&lt;m;i++) sum[i]=0; for(int i=0;i&lt;n;i++) sum[x[i]=str[i]]++; for(int i=1;i&lt;m;i++) sum[i]+=sum[i-1]; for(int i=n-1;i&gt;=0;i--) sa[--sum[x[i]]]=i; for(int p,j=1;p&lt;=n;j&lt;&lt;=1)&#123; p=0; for(int i=n-j;i&lt;n;i++) y[p++]=i; for(int i=0;i&lt;n;i++) if(sa[i]&gt;=j) y[p++]=sa[i]-j; for(int i=0;i&lt;m;i++) sum[i]=0; for(int i=0;i&lt;n;i++) sum[x[y[i]]]++; for(int i=1;i&lt;m;i++) sum[i]+=sum[i-1]; for(int i=n-1;i&gt;=0;i--) sa[--sum[x[y[i]]]]=y[i]; swap(x,y); p=1; x[sa[0]]=0; for(int i=1;i&lt;n;i++) x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+j]==y[sa[i]+j]?p-1:p++; if(p&gt;=n) break; m=p; &#125; int k=0;n--; for(int i=0;i&lt;=n;i++) rk[sa[i]]=i; for(int i=0;i&lt;n;i++)&#123; if(k)k--;else k=0; int j=sa[rk[i]-1]; while(str[i+k]==str[j+k])k++; ht[rk[i]]=k; &#125;&#125;/*对ht数组建立st表,这样就能取区间LCP*/void build(int n) &#123; for(int i = 1; i &lt;= n; i++) f[i][0] = ht[i]; for(int i = 1; i &lt; 22; i++) &#123; for(int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; j++) f[j][i] = min(f[j][i - 1], f[j + (1 &lt;&lt; (i - 1))][i - 1]); &#125;&#125;int query(int pl, int pr) &#123; int t = log2(pr - pl + 1.0); return min(f[pl][t], f[pr - (1 &lt;&lt; t) + 1][t]);&#125;// root[i] = update1(root[i - 1], 1, n, sa[i] + 1);/*root数组的key是rk,然后值是key对应的值是线段树节点位置(1是主根)root也是tr的键,val记录的是某个rk的在root[rk]号树上的**位置前缀和**然后tr数组就就是记录着主席树上的节点轨迹*/int update1(int pre, int l, int r, int pos) &#123; /*主席树外分支++*/ int cur = ++tot; /*新开轨迹获取之前轨迹的信息,在之前信息上添加*/ tr[cur] = tr[pre]; tr[cur].val++; if(l == r) return cur; int mid = (l + r) &gt;&gt; 1; /*动态开左孩子或者右孩子点*/ if(pos &lt;= mid) tr[cur].l = update1(tr[pre].l, l, mid, pos); else tr[cur].r = update1(tr[pre].r, mid + 1, r, pos); return cur;&#125;// queryk(root[cntl - 1], root[cntr], 1, n, k)/*cntl - 1 的rk也是LCP符合条件的，所以这里需要cntl-1*//*pl.pr是rk区间对应的根区间，他们的val值记录着sa之间的差值，类是于线段树rmq=&gt;可以rkq然后是主席树是同左同右操作的*/int queryk(int pl, int pr, int l, int r, int k) &#123; if(l == r) return l; int mid = (l + r) &gt;&gt; 1; if(tr[tr[pr].l].val - tr[tr[pl].l].val &gt;= k) return queryk(tr[pl].l, tr[pr].l, l, mid, k); else return queryk(tr[pl].r, tr[pr].r, mid + 1, r, k - (tr[tr[pr].l].val - tr[tr[pl].l].val));&#125;int main()&#123; int n, m;int T; int l, r, k; int ll, rr, mid; int tmp; int cntl, cntr;int cnt; scanf("%d",&amp;T); while(T--)&#123; tot = 0; scanf("%d %d", &amp;n, &amp;m); scanf("%s",s); n=strlen(s); for(int i=0;i&lt;n;i++) str[i] = s[i] - 'a' + 1; str[n]=0; get_sa(n+1,30); /*这里是ht的st_rmq*/ build(n); for(int i = 1; i &lt;= n ; i++) &#123; root[i] = update1(root[i - 1], 1, n, sa[i] + 1); &#125; while(m--) &#123; scanf("%d %d %d", &amp;l, &amp;r, &amp;k); tmp = r - l + 1; l = rk[l - 1]; ll = 1, rr = l; while(ll &lt;= rr) &#123; mid = (ll + rr) &gt;&gt; 1; cnt = 100000; if(mid + 1 &lt;= l) cnt = query(mid + 1, l); if(cnt &gt;= tmp) &#123; cntl = mid; rr = mid - 1; &#125; else &#123; ll = mid + 1; &#125; &#125; ll = l, rr = n; while(ll &lt;= rr) &#123; mid = (ll + rr) &gt;&gt; 1; cnt = 100000; if(l + 1 &lt;= mid) cnt = query(l + 1, mid); if(cnt &gt;= tmp) &#123; cntr = mid; ll = mid + 1; &#125; else &#123; rr = mid - 1; &#125; &#125; if(cntr - cntl + 1 &lt; k) printf("-1\n"); else &#123; printf("%d\n", queryk(root[cntl - 1], root[cntr], 1, n, k)); &#125; &#125; &#125; return 0;&#125; 参考大佬链接https://blog.csdn.net/mmk27_word/article/details/100045708 每天一句叨叨世界上总是存在很多的二八定律，不过也应该二八定律，因为总有那么一些人愿意花几倍于人的自律和代价去提高一点点被幸运之神眷顾的机会]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>后缀数组</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU5008详解_后缀数组_二分_RMQ_算法日常[17/100]]]></title>
    <url>%2F2019%2F08%2F22%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-17-100%2F</url>
    <content type="text"><![CDATA[HDU5008题目链接VJ上面hdu上面 题意给一个串，q次查询里面第k大的字串，并且要求输出这个串最早出现的位置的左右下标值 题解Tips:看不懂题解的话可以看题解下面的题解小细节(之所以在前面提示是因为小编经常看到一个东西自己想了半天，然后发现后面竟然有解释…所以感觉有点浪费时间，所以自己的博文应该防止自己陷入同样的坑) 解法一 无RMQ O(case*q*(log_(n)+n))考虑找到第k小的子串，直接拿原串先构造后缀数组，统计一下第i个后缀有多少个不同的前缀num[i]（也就是在原串中有多少个不重复的子串），按sa排序后，这些连续出现的子串的字典序也是相同的，那么对num[i]求前缀和后就可以去二分一个位置，找到字典序第k小的子串出现的位置pos了(到这里解法二也要用)。这里找到的位置不一定是最靠左的(不理解可以看下面的题解分析)，所以还要在原串中找一下最左的位置，其实到了这里，直接向后，暴力遍历后面排名的串(不理解可以看下面的题解分析)，若串的最长的连续的height[i]&gt;=目标子串长度，则维护min(L,l)就可以直接得到最小的答案 解法二 RMQ O(case*(n*log_(n)+q*log_(n)))当然解法一在极限数组（例如10W个a）很可能会TLE的，所以我们来看更快的方法，以应对更高的要求，把平时的节俭(抠门)习惯在计算机上面发挥到极致 先像解法一前面部分一样确定了当前的位置pos，我们要做的就是在pos后面找个R，使得[pos,R]这个区间的height的最小值&gt;=目标子串的长度，那么找R可以直接在[POS,n]中二分，由于我们的height数组并不是有序的，所以我们不能使用lower_bound,但是要应对多次询问，我们不能像解法一一样暴力了，所以可以使用RMQ，在case开始的时候用n*log_(n)进行预处理，然后在多次查询中享受O(1)带来的极致体验(节俭的生活就是如此地惬意),最后我们在[pos,R]区间再RMQ一下就得到最后的答案了。注意这里求区间的RMQ和求答案的RMQ是查询的两个数组，要分别初始化… 题解细节精讲QAQ1: 为什么后面只要找pos后的后缀中的前缀，不用往前找？而且为什么不同的串是那样求出来的？A: 首先是关于一个字符串有多少不同子串的问题，串由小到大排起序来应该是按照sa[i]的顺序排出来的产生的。比如abbacd，排序出来的后缀是这样的rank值i—-对应的后缀sa[i] 1—-abbacd 第一个串产生的6个前缀都是新的子串(a,ab,abb……) 2—-acd 第二个串除了和上一个串的相同的前缀a(长度为1) 3-1=2 产生了2个子串 3—-bacd 4-0=4 4—-bbacd 5-1=4 5—-cd 2－0=0 6—-d 1－0=0 所以所有不同的前缀应该是(len-sa[i])-height[i]的和，即后缀串长(总串长减后缀起始位置)减去与上一个串的最长公共前缀，然后求和。如果你不了解height数组—-&gt;建议看看学习后缀数组的小建议 然后我们可以观察到字串是按照排名过来的a,ab,abb,abba,abbac,abbacd,ac,acd,b,ba,…… 并且也可以观察到第k大的不同的串如果在多个位置出现，那么一定是在后面的串中出现，比如k=3,即abb只能在后面的串出现(在abba，abbac,abbacd中出现)—&gt;所以只要在后面查找主要原因是所有的不同的串都是每个后缀的前缀 Q2: 为什么我们找到的第一个不是最靠左的呢？A:这里可以举一个反例就解决了，而且其实我们在题解二也举了这个例子(10w个a),我们这里为了分析方便就举例给的串是aaa，那么排名rank 对应的后缀串1 a(rank[1]=2,即是后缀2)2 aa3 aaa因此我们就可以看到第一个找到的a不是位置上最左边的，反而是最右边的 AC代码提交都是G++ 解法一123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100010;typedef long long LL;int sa[maxn],height[maxn],rank[maxn],t[maxn],t2[maxn],c[maxn];int n;char str[maxn];int q;LL sum[maxn];void build_sa(int m,int n)&#123; int *x=t,*y=t2; for(int i=0;i&lt;m;i++)c[i]=0; for(int i=0;i&lt;n;i++)c[x[i]=str[i]]++; for(int i=1;i&lt;m;i++)c[i]+=c[i-1]; for(int i=n-1;i&gt;=0;i--)sa[--c[x[i]]]=i; for(int k=1;k&lt;=n;k&lt;&lt;=1)&#123; int p=0; for(int i=n-k;i&lt;n;i++)y[p++]=i; for(int i=0;i&lt;n;i++)if(sa[i]&gt;=k)y[p++]=sa[i]-k; for(int i=0;i&lt;m;i++)c[i]=0; for(int i=0;i&lt;n;i++)c[x[y[i]]]++; for(int i=1;i&lt;m;i++)c[i]+=c[i-1]; for(int i=n-1;i&gt;=0;i--)sa[--c[x[y[i]]]]=y[i]; swap(x,y); x[sa[0]]=0;p=1; for(int i=1;i&lt;n;i++) x[sa[i]]=(y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?p-1:p++); if(p&gt;=n)break; m=p; &#125;&#125;void getheight(int n)&#123; int k=0; for(int i=1;i&lt;=n;i++)::rank[sa[i]]=i; for(int i=0;i&lt;n;i++)&#123; if(k)k--; int j=sa[::rank[i]-1]; while(str[i+k]==str[j+k])k++; height[::rank[i]]=k; &#125;&#125;void process()&#123; memset(sum,0,sizeof(sum)); sum[1]=n-sa[1]; for(int i=2;i&lt;=n;i++) sum[i]=sum[i-1]+n-sa[i]-height[i];&#125;void solve()&#123; scanf("%d",&amp;q); LL l=0,r=0; process(); while(q--)&#123; LL v; scanf("%lld",&amp;v); LL k=(l^r^v)+1; /*获取有第k排名的不同字符的起始位置(sum见process函数)*/ int pos=lower_bound(sum+1,sum+1+n,k)-sum; /*因为每个串都是 后缀 所以sum[pos]-(k-1)就能得到第k个起始的后缀长度！ 然后用n减去,就是k起始的位置！ (字符串下标从0开始,可以用k=1,来模拟理解一遍) */ LL tl=sa[pos],tr=n-(sum[pos]-k+1); l=tl,r=tr; int len=tr-tl+1; while(pos+1&lt;=n&amp;&amp;height[pos+1]&gt;=len)&#123; pos++; tl=sa[pos],tr=tl+len-1; l=min(l,tl),r=min(r,tr); &#125; l++,r++; if(pos&gt;=n+1)l=r=0; cout&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;endl; &#125;&#125;int main()&#123; while(scanf("%s",str)!=EOF)&#123; n=strlen(str); build_sa(123,n+1); getheight(n); solve(); &#125; return 0;&#125; 解法二123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=205000;char str[maxn];int belong[maxn];int s[maxn],rs[maxn];int sa[maxn],t[maxn],t2[maxn],c[maxn];int n,m,tt;int rank[maxn],height[maxn];int d[2][maxn][50];int LOG[maxn];ll num[maxn];int len,l;inline int idx(char c)&#123; return c-'a'+1; &#125;inline char fdx(int x)&#123; return char(x-1+'a'); &#125;void calheight(int n)&#123; int i,k=0; for (i=0; i&lt;=n; i++) ::rank[sa[i]]=i; for (i=0; i&lt;n; i++)&#123; if (k) k--; int j=sa[::rank[i]-1]; while(s[i+k]==s[j+k]) k++; height[::rank[i]]=k; &#125;&#125;void da(int m,int n)&#123; n++; int i,*x=t,*y=t2; for (int i=0; i&lt;m; i++) c[i]=0; for (int i=0; i&lt;n; i++) c[x[i]=s[i]]++; for (int i=1; i&lt;m; i++) c[i]+=c[i-1]; for (int i=n-1; i&gt;=0; i--) sa[--c[x[i]]]=i; for (int k=1; k&lt;=n; k&lt;&lt;=1)&#123; int p=0; for (i=n-k; i&lt;n; i++) y[p++]=i; for (i=0; i&lt;n; i++) if (sa[i]&gt;=k) y[p++]=sa[i]-k; for (i=0; i&lt;m; i++) c[i]=0; for (i=0; i&lt;n; i++) c[x[y[i]]]++; for (i=1; i&lt;m; i++) c[i]+=c[i-1]; for (i=n-1; i&gt;=0; i--) sa[--c[x[y[i]]]] = y[i]; swap(x,y); p=1; x[sa[0]]=0; for (i=1; i&lt;n; i++) x[sa[i]]=(y[sa[i-1]]==y[sa[i]] &amp;&amp; y[sa[i-1]+k]==y[sa[i]+k])? p-1 : p++; if (p&gt;=n) break; m=p; &#125;&#125;int RMQ_init(int x,int A[])&#123; for(int i=1; i&lt;=n; i++) d[x][i][0]=A[i]; for (int j=1; (1&lt;&lt;j)&lt;=n; j++) for (int i=1; i+(1&lt;&lt;j)-1&lt;=n; i++) d[x][i][j]=min(d[x][i][j-1],d[x][i+(1&lt;&lt;(j-1))][j-1]); return 0;&#125;int RMQ(int x,int L,int R)&#123; int k=LOG[R-L+1]; return min(d[x][L][k],d[x][R-(1&lt;&lt;k)+1][k]);&#125;int main()&#123; int k=0; for (int i=0; i&lt;105000; i++)&#123; while((1&lt;&lt;(k+1))&lt;=i) k++; LOG[i]=k; &#125; while(~scanf("%s",str))&#123; int l=strlen(str); for(int i=0; i&lt;l; i++) s[i]=idx(str[i]); n=l; s[n]=0; da(33,n); calheight(n); for (int i=0; i&lt;=n; i++) num[i]=n-sa[i]; for (int i=1; i&lt;=n; i++) num[i]-=height[i]; for (int i=1; i&lt;=n; i++) num[i]+=num[i-1]; ll tot=num[n]; scanf("%d",&amp;m); ll la=0,lb=0; ll k; /*d[0]存着height的rmq,d[1]存着sa的rmq*/ RMQ_init(0,height); RMQ_init(1,sa); while(m--)&#123; scanf("%lld",&amp;k); k=(k^la^lb)+1; if (k&gt;=1 &amp;&amp; k&lt;=tot)&#123; int pos=lower_bound(num+1,num+1+n,k)-num; /*这个len求得很精致,k-(pos-1)位置起始的不同串的个数, 这样就能得到k结束位置距离height结束位置的串长，加上height就是正好len*/ int len=k-num[pos-1]+height[pos]; int l=pos+1,r=n; int mid; int L=pos,R; /*二分右端点使得右边的最需最长公共字串是我们的k长串*/ while(l&lt;r)&#123; mid=(l+r)&gt;&gt;1; if (RMQ(0,pos+1,mid)&gt;=len) l=mid+1; else r=mid; &#125; /*因为上面二分是mid+1,所以这里需要保险一下*/ if (RMQ(0,pos+1,l)&gt;=len) R=l; else R=l-1; /*所有地方求最小的sa*/ la=RMQ(1,L,R); lb=la+len-1;la++;lb++; printf("%lld %lld\n",la,lb); &#125; else la=lb=0,puts("0 0"); &#125; &#125; return 0;&#125; 参考:http://www.voidcn.com/article/p-xboamjdx-bg.htmlhttps://www.cnblogs.com/chanme/p/4000976.html 每天一句叨叨从明天起，做一个幸福的人(每天只玩半个小时的手机,让自己要么大屏高效,要么认真体验生活) 喂马、劈柴，周游世界 从明天起，关心粮食和蔬菜 我有一所房子，面朝大海，春暖花开 从明天起，和每一个亲人通信 告诉他们我的幸福 那幸福的闪电告诉我的 我将告诉每一个人 给每一条河每一座山取一个温暖的名字 陌生人，我也为你祝福 愿你有一个灿烂的前程 愿你有情人终成眷属 愿你在尘世获得幸福 我只愿面朝大海，春暖花开]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>后缀数组</tag>
        <tag>狼胆带你每天头铁一题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组基础题poj1743详解_算法日常[16/100]]]></title>
    <url>%2F2019%2F08%2F21%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-16-100%2F</url>
    <content type="text"><![CDATA[POJ1743题目链接POJ上面 VJ上面 题意给定一个字符串，求最长重复子串，这两个子串不能重叠 解题思路 由于配置不是简单的匹配，有升降调的处理，但是我们无法确定升降的幅度，所以我们首先对输入的数组进行差值处理 可以发现同一个旋律的区段，它们的差值数组是相等的 因为之前我们处理成了差值，所以我们内卷了一个值，我们的差值相当于左右两个值，所以4个值代表着5个值 所以只要找到最长相同串长的长度不小于4的差值区段即可 由于需要求出最长的长度，考虑二分后验证可行性，二分区段的长度x，对差值数组求一遍后缀数组，将最长公共前缀大于等于x的划分成一组，如果存在一组的sa差值大于等于x+1(详见下面的重点解释)，那么就表示x长度的差值数组能够被找到。二分结束即可得到答案。 没学后缀数组？出门左转给你后缀数组学习合集 思路重点为什么c+1,ans+1二分检查的时候，最长公共前缀是x,sa差值却要大于x+1: 因为之前我们处理成了差值，所以我们内卷了一个值，我们的差值相当于左右两个值，所以4个值代表着5个值.所以最长公共字串只要在4的时候就相当于5,然后sa的差值还是要相间隔5才行==&gt;这样真实的5个值也才是真的间隔5个值，所以同理答案也就是c+1(ans+1) 比如:121 2 3 4 5 6 7 8 9 10 1 1 1 1 &apos; 1 1 1 1 中间的&#39;也是1，但是代表的5,6，所以如果从这里开始和前面的4个1构成相同串的话，然后就重叠了一个，所以必须从&#39;后面1开始 我看了别的几个博主对于这题的分析没有谈及，这里，还有些代码没有考虑这里也能AC，说明数据都去卡时间了，没有卡下面这个特例:1291 2 3 4 5 6 7 8 9 为什么da函数的n值要加1而getheight函数不用da要加一个位置的字符,让它比所有的字符都小，所以这个字符起始的后缀是其本身，其排名为0(rank[n]=0,sa[0]=n)然而calheight却不要…因为calheight直接从rank值为1(rank为0的地方是添加的最小字符)的地方记到n，根本不会用到sa[0](排名为0的后缀)，重点还有for中用的是&lt;=..所以只要使用n. for(i=1;i&lt;=n;i++) ::rank[sa[i]]=i; height分组为什么直接遍历下去分就好，不用吧height值相同的放在一起 AC代码1(推荐)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const ll mod=1000000007;const int inf = 0x3f3f3f3f;const int maxn = 20010;int sa[maxn],rank[maxn],height[maxn];int n;int str[maxn];int wa[maxn],wb[maxn],wv[maxn],ws[maxn];int cmp(int *r,int a,int b,int l)&#123;return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;void da(int *r,int *sa,int n,int m)&#123; int i,j,p,*x=wa,*y=wb,*t; for(i=0;i&lt;m;i++) ::ws[i]=0; for(i=0;i&lt;n;i++) ::ws[x[i]=r[i]]++; for(i=1;i&lt;m;i++) ::ws[i]+=::ws[i-1]; for(i=n-1;i&gt;=0;i--) sa[--::ws[x[i]]]=i; for(j=1,p=1;p&lt;n;j*=2,m=p)&#123; for(p=0,i=n-j;i&lt;n;i++) y[p++]=i; for(i=0;i&lt;n;i++) if(sa[i]&gt;=j) y[p++]=sa[i]-j; for(i=0;i&lt;n;i++) wv[i]=x[y[i]]; for(i=0;i&lt;m;i++) ::ws[i]=0; for(i=0;i&lt;n;i++) ::ws[wv[i]]++; for(i=1;i&lt;m;i++) ::ws[i]+=::ws[i-1]; for(i=n-1;i&gt;=0;i--) sa[--::ws[wv[i]]]=y[i]; for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;n;i++) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; &#125; return;&#125;/*r为字符串数组,sa是后缀数组,n为字符串长度*/void calheight(int *r,int *sa,int n)&#123; int i,j,k=0; /*用sa[]得到rank[]*/ for(i=1;i&lt;=n;i++) ::rank[sa[i]]=i; /*j就是后缀i的前一名的后缀位置,然后如果前一个串之间有k,那么就从k--起步*/ for(i=0;i&lt;n;height[::rank[i++]]=k) for(k?k--:0,j=sa[::rank[i]-1];r[i+k]==r[j+k];k++); return;&#125;/*为什么check里面的间隔是c+1: 因为之前我们处理成了差值，所以我们内卷了一个值， 我们的差值相当于左右两个值，所以4个值代表着5个值 所以最长公共字串只要在4的时候就相当于5,然后sa的 差值还是要相间隔5才行==&gt;这样真实的5个值也才是真的 间隔5个值，所以同理答案也就是c+1*/bool check(int c)&#123; int Max=sa[1],Min=sa[1]; for(int i=2;i&lt;=n;i++)&#123; /*这里的for是枚举的排名值，而height就是相邻排名的 最长公共前缀,所以直接分组就行了*/ if(height[i]&gt;=c) Max=max(Max,sa[i]),Min=min(Min,sa[i]); else Max=sa[i],Min=sa[i]; if(Max-Min&gt;=c+1) return true; &#125; return false;&#125;int main()&#123; ios::sync_with_stdio(false);cin.tie(0); while(cin&gt;&gt;n)&#123; if(n==0) break; for(int i=0;i&lt;n;i++) cin&gt;&gt;str[i]; for(int i=0;i&lt;n-1;i++) str[i]=str[i+1]-str[i]+90; /*因为转变差值了，所以少一个值*/ str[n-1]=0;n--; // for(int i=0;i&lt;=n-1;i++) cout&lt;&lt;str[i]&lt;&lt;" "; cout&lt;&lt;endl; /*da要加一个位置的字符,让它比所有的字符都小 然而calheight却不要...因为calheight直接从rank只为1(rank为0的地方是添加的最小字符) 的地方记到n(用的是&lt;=)..所以只要使用n.不需要n+1*/ da(str,sa,n+1,178); calheight(str,sa,n); int l=0,r=n,ans=0; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) l=mid+1,ans=mid; else r=mid-1; &#125; if(ans&lt;4) cout&lt;&lt;0&lt;&lt;endl; else cout&lt;&lt;ans+1&lt;&lt;endl; &#125; return 0;&#125; AC代码2(RMQ版)此AC代码为2019年8月22日做HDU5008(因为那题最好还是用RMQ的后缀数组题)的时候发现的不过这题用RMQ比较鸡肋，为什么? 请看下面的代码头部注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/*今天在第二次研究hdu5008的时候,发现好多题目都是没有用rmq的但是总有大佬不满足于暴力裸sa就完事,于是都加了rmq,然后我有点看不懂,就去逛oi-wiki,发现居然有不重叠重复两次的串也可以用rmq，那不就是我昨天做的poj1743的更优做法吗？是的，然后就在网上搜到了O(test*(nlogn+logn))的做法！之前的写法是O(test*nlogn)的但是实测发现RMQ版的反而还慢了100多ms!好像是因为他的check还是O(n)而非O(1)的因为这里的check是我们自己去寻找一个左右区间，而非输入直接给我们左右区间，所以这里的寻找的复杂度是O(n),所以RMQ无济于补而且RMQ是nlog(n)的预处理... 所以当然会慢啊 ---&gt; 所以在更大一个量级的询问的时候再用比较好----------------上面为简单分析-----下面为用途---------------这里有rmq求排名区间内最远的sa位置差值*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=21000;int dp1[maxn][20],dp2[maxn][20];int mm[maxn];int str[maxn],tmp[maxn];int wa[maxn],wb[maxn],wv[maxn],ws[maxn];int sa[maxn],ranks[maxn],height[maxn];inline bool cmp(int *r,int a,int b,int l)&#123; return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;void da(int *r,int n,int m)&#123; int i,j,p,*x=wa,*y=wb,*t; for(i=0;i&lt;m;i++) ws[i]=0; for(i=0;i&lt;n;i++) ws[x[i]=r[i]]++; for(i=1;i&lt;m;i++) ws[i]+=ws[i-1]; for(i=n-1;i&gt;=0;i--) sa[--ws[x[i]]]=i; for(j=1,p=1;p&lt;n;j*=2,m=p)&#123; for(p=0,i=n-j;i&lt;n;i++) y[p++]=i; for(i=0;i&lt;n;i++) if(sa[i]&gt;=j) y[p++]=sa[i]-j; for(i=0;i&lt;n;i++) wv[i]=x[y[i]]; for(i=0;i&lt;m;i++) ws[i]=0; for(i=0;i&lt;n;i++) ws[wv[i]]++; for(i=1;i&lt;m;i++) ws[i]+=ws[i-1]; for(i=n-1;i&gt;=0;i--) sa[--ws[wv[i]]]=y[i]; for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;n;i++) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; &#125; for(i=0;i&lt;n;i++) ranks[sa[i]]=i; int k=0; for(i=0;i&lt;n-1;i++)&#123; if(k) k--; j=sa[ranks[i]-1]; while(r[i+k]==r[j+k]) k++; height[ranks[i]]=k; &#125; return;&#125;void initRMQ(int n)&#123; /*mm其实是log,这里赋值为-1是为了后面mm[1]=0,也就是2^0=1*/ mm[0]=-1; for(int i=1;i&lt;=n;i++)&#123; /*(i&amp;(i-1))==0表示n==0或者是2的倍数*/ mm[i]=((i&amp;(i-1))==0)?mm[i-1]+1:mm[i-1]; /*这里是预处理sa的rmq*/ dp1[i][0]=dp2[i][0]=sa[i]; &#125; for(int j=1;j&lt;=mm[n];j++) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++)&#123; dp1[i][j]=max(dp1[i][j-1],dp1[i+(1&lt;&lt;(j-1))][j-1]); dp2[i][j]=min(dp2[i][j-1],dp2[i+(1&lt;&lt;(j-1))][j-1]); &#125;&#125;int rmq(int x,int y)&#123; int k=mm[y-x+1]; return max(dp1[x][k],dp1[y-(1&lt;&lt;k)+1][k])-min(dp2[x][k],dp2[y-(1&lt;&lt;k)+1][k]);&#125;bool check(int len,int N)&#123; int s=1,e=1; while(e&lt;N)&#123; if(height[e+1]&gt;=len-1) e++; else&#123; if(rmq(s,e)&gt;=len) return true; s=++e; &#125; &#125; return false;&#125;int main()&#123; int N; while(scanf("%d",&amp;N)&amp;&amp;N)&#123; for(int i=0;i&lt;N;i++) scanf("%d",&amp;str[i]); for(int i=0;i&lt;N-1;i++) tmp[i]=str[i+1]-str[i]+90; tmp[N-1]=0; /*这里没有N--,所以直接使用的N,而RMQ使用的N-1,height封锁掉N号位置*/ da(tmp,N,200); initRMQ(N-1); height[N]=-1; int left=1,right=N/2; while(left&lt;=right)&#123; int mid=(left+right)/2; if(check(mid,N)) left=mid+1; else right=mid-1; &#125; if(right&lt;5) printf("0\n"); else printf("%d\n",right); &#125; return 0;&#125; 每天一句叨叨我不管你是什么垃圾，我只看结果 要达到结果，你应该知道怎么做 I know you have the urge to give up! But you must keep faith! You do make a difference!]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>后缀数组</tag>
        <tag>狼胆带你每天头铁一题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组学习路径以及后缀数组板子推送_算法日常[15/100]]]></title>
    <url>%2F2019%2F08%2F20%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-15-100%2F</url>
    <content type="text"><![CDATA[学习后缀数组的小建议时刻分析数组含义学习后缀数组的核心是时刻分析这到底是排名i的后缀位置还是后缀i的排名值 一般的SA[i]代表着排名第i的后缀位置从哪里开始 然后Rank[i]代表着后缀i的排名 后缀i就从下标i开始一直到字符串末尾的那个后缀s.substr(i) 演算脑子的内存是有限的，所以有时候想不出来，尽量使用草稿纸加以演算，这样才能更高效地学习后缀数组(否则像小编这种脑子不怎么好使的，不演算之前看了一天都没看懂某两行代码) 后缀数组学习材料当然小编也是一个初学者，所以暂时只能说出一些学习的小建议，让我写出来还是不太现实，不过小编可以给你们推荐一些学习的资料 论文下面这篇论文基本上网罗了后缀数组的方方面面，而且写得也十分详细，所以十分推荐后缀数组论文分享 学习网址也挺详细的 OI-wiki上的介绍 题目链接当然是先刷一手kuangbin专题 板子整理推送(LTS)1234567891011121314151617181920212223242526272829303132333435363738394041424344/*板子声明 :1. r从0开始,而非像oi-wiki中的从1开始2. [build使用 n + 1 , calheight 使用 n ](https://www.wolfdan.cn/2019/08/21/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-16-100/)*/int sa[maxn],wa[maxn],wb[maxn],wv[maxn],ws[maxn];/*LCP:最长公共字串部分*/int rank[maxn],height[maxn];/*r为字符串数组,sa是后缀数组,n为字符串长度,m为字符种类数*/void da(int *r,int *sa,int n,int m)&#123; int i,j,p,*x=wa,*y=wb,*t; for(i=0;i&lt;m;i++) ws[i]=0; for(i=0;i&lt;n;i++) ws[x[i]=r[i]]++; for(i=1;i&lt;m;i++) ws[i]+=ws[i-1]; for(i=n-1;i&gt;=0;i--) sa[--ws[x[i]]]=i; for(j=1,p=1;p&lt;n;j*=2,m=p)&#123; for(p=0,i=n-j;i&lt;n;i++) y[p++]=i; for(i=0;i&lt;n;i++) if(sa[i]&gt;=j) y[p++]=sa[i]-j; /*提取第一关键字*/ for(i=0;i&lt;n;i++) wv[i]=x[y[i]]; for(i=0;i&lt;m;i++) ws[i]=0; for(i=0;i&lt;n;i++) ws[wv[i]]++; for(i=1;i&lt;m;i++) ws[i]+=ws[i-1]; for(i=n-1;i&gt;=0;i--) sa[--ws[wv[i]]]=y[i]; for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;n;i++) x[sa[i]]=(y[sa[i-1]]==y[sa[i]]&amp;&amp;r[sa[i-1]+j]==r[sa[i]+j])?p-1:p++; &#125; return;&#125;/*r为字符串数组,sa是后缀数组,n为字符串长度*/void calheight(int *r,int *sa,int n)&#123; int i,j,k=0; /*用sa[]得到rank[]*/ for(i=1;i&lt;=n;i++) rank[sa[i]]=i; /*j就是后缀i的前一名的后缀位置,然后如果前一个串之间有k,那么就从k--起步*/ for(i=0;i&lt;n;height[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];r[i+k]==r[j+k];k++); return;&#125; 每天一句叨叨愿回首岁月之时，你不会后悔]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019杭电多校9题解_算法日常[14/100]]]></title>
    <url>%2F2019%2F08%2F19%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-14-100%2F</url>
    <content type="text"><![CDATA[jls题解因为有些 ddl 要肝.. 把视频题解咕了..大家凑合着看文字题解吧 今年又是 Rikka 和 Yuta 在多校上秀恩爱的一年（说不定也是最后一年了.. sad 1001 Rikka with Quicksort难度：medium 考察了大家对快速排序时间复杂度推导的熟悉程度（当然我是打表推式子的） 如果打表的话可以考虑下面这个式子，它是计算在 $m$ 处增加一个 $1$ 对答案的贡献。 \begin{aligned} h_m(i) &= 0 & i < m\\ h_m(i) &= 1 & i =m \\ h_m(i) &= \frac{1}{i}\sum_{j=1}^{i}\left( h_m(j-1) + h_m(i-j)\right) & i > m \end{aligned}打表之后可以知道 $h_m(m)=1,h_m(n)=\frac{2(n+1)}{(m+1)(m+2)} (n &gt; m)$。应该归纳一下就可以直接证明。所以把对应的贡献求和之后可以得到答案就是： 2(n+1)H(n)-4n-\frac{2(m+2)H(m+1)-4(m+1)-m)(n+1)}{m+2}其中 $H(n)$ 表示调和级数。因为模数确定，可以用分段打表的策略来求调和级数的具体值：即把 $H(kS)$ 的值给打入程序中，这样每一次只需要计算 $kS+1$ 到 $n$ 的逆元就行了。 1002 Rikka with Cake难度：medium easy 用欧拉（欧拉欧拉欧拉）公式 $V-E+F = 2$ 来算蛋糕的块数。 首先考虑点数 $V$，蛋糕的四个角以及射线的端点贡献了 $n+4$ 个顶点（$K$ 太丑了我们用 $n$ 表示射线数），射线和四条边的交点共有 $n$ 个，射线之间的交点有 $c$ 个，因此点数是 $2n+4+c$。 接着考虑边数，对于每一条射线，假设别的射线和他的交点有 $c_i$ 个，那么这条射线被切成了 $c_i+1$ 段，因此所有射线的边数对应的是 $2c+n$（因为每一个交点被用了两次）。同时因为四条边一共和射线交了 $n$ 次，所以四条边界上共有 $4+n$ 条边，所以 $E=2c+2n+4$。 因此总的区域数为 $F=2+c$，因为要去掉最外面的无穷区域，所以答案就是 $1+c$。于是问题就变成了求交点个数 $c$。这是一个经典的问题，分四个方向讨论一下离散化用树状数组求就行。时间复杂度 $O(n \log n)$ 1003 Rikka with Mista难度：medium-easy 在，为什么迫害米斯达？ 可以对每一位分开来计算，和最大不超过 $10^{10}$，因此最多只有 $10$ 位。只要对每一位算出它在多少种情况下是 $4$，全部加起来就可以了。 $40$ 的数据范围指明了可以用 meet in middle 来做，可以先用 $O(2^{\frac{n}{2}})$ 的复杂度分别把前 $\frac{n}{2}$ 个数和后 $\frac{n}{2}$ 个数的所有和求出来，分别存在数组 $A$ 和 $B$ 中，那么对于第 $i$ 位来说，答案就是有多少个数对 $i,j$ 满足 $(A_i+B_j) \text{ mod } 10^{i+1} \in [4 \times 10^i,5 \times 10^i)$。这个问题只要对 $A$ 和 $B$ 按照 $x \text{ mod } 10^{i+1}$ 排序后用 two pointer 扫就可以了。 对每一位分开来做时间复杂度是 $O(2^{\frac{n}{2}}n \log w_i)$，瓶颈在堆每一位排序。不难发现对每一位排序可以用一次归并排序来实现，这样就能省下一个 $\log$，时间复杂度是 $O(2^{\frac{n}{2}}n)$。 1004 Rikka with Geometric Sequence难度：medium 首先长度是 $1$ 的答案就是 $n$，长度为 $2$ 的答案就是 $\frac{n(n-1)}{2}$。我们考虑长度大于等于 $3$ 的情况。 假设公比的最简分数表示是 $\frac{a}{b}(a &gt; b,\gcd(a,b) = 1)$，等比数列长度是 $k$，那么 $x$ 能作为这样的一个等比数列的最后一项的条件就是 $a^{k-1}|x$，因此这样的等比数列一共有 $\left \lfloor \frac{n}{a^{k-1}} \right \rfloor$。而枚举了 $a$，满足小于 $a$ 且与 $a$ 互质的 $b$ 的数量是 $\varphi(a)$，其中 $\varphi$ 表示欧拉函数。 因此我们可以枚举 $a$ 然后对答案求和： \sum_{a=2}^n \varphi(a)\left \lfloor \frac{n}{a^{k-1}} \right \rfloor显然有贡献的 $a$ 必须小于等于 $\sqrt[k-1] n$，因此当 $k&gt;3$ 的时候就能暴力枚举 $a$ 统计答案了，问题就在于 $k=3$ 的时候的处理。这个时候可以证明 $\left \lfloor \frac{n}{a^2} \right \rfloor$ 的取值最多只有 $\sqrt[3] n$ 种：当 $a \leq \sqrt[3]n$ 的时候，只有 $\sqrt[3] n$ 种值，当 $a &gt; \sqrt[3]n$ 的时候，这个商小于等于 $\sqrt[3]n$，因此最多也就只有 $\sqrt[3]n$ 种答案。 所以相当于把 $a$ 的取值分成了 $\sqrt[3]n$ 段，对每一段分别用杜教筛求 $\varphi(n)$ 的前缀和就可以了。这样的时间复杂度比较迷幻，我展开一层积分一下可以得到时间复杂度是 $O(n^{\frac{5}{12}})$。不确定最终的时间复杂度是什么。但是如果预处理前 $5 \times 10^7$ 项的欧拉函数，可以非常轻松的跑过去。 1005 Rikka with Game难度：easy 签到题，随便脑补一下就能知道答案。首先如果第一位是 $a-x$ 的话，先手会直接结束游戏：如果先手增加第一位，那么后手直接结束游戏；如果先手不增加第一位，那么后手增加第一位，此时如果先手还不结束游戏，后手直接选择结束。这三种情况下游戏结束的字典序都要比游戏开始的时候字典序大。 如果第一位是 $y$，那么不管先手还是后手都不会选择修改它：如果先手修改它，后手直接结束游戏；如果后手修改它，先手再选择同一位，然后在下一次轮到先手的时候结束。这样对于修改 $y$ 的那一方都是亏的。 如果第一位是 $z$，那么先手会选择修改它，之后后手也会选择修改它，然后就回到了第一种情况先手直接结束游戏，因此结果就是第一位变成了 $b$. 在上面三种情况下，只有第二种情况游戏不会再只考虑第一位的情况下结束，这时因为大家都不会动第一位，所以相当于不存在，直接考虑后面的情况就可以。 所以最后的结论就是，找到第一位不是 $y$ 的位，如果它是 $z$，则修改成 $b$，否则不变。 时间复杂度 $O(n)$。 1006 Rikka with Coin难度：easy 首先 $10$ 分的硬币最多只会用一个，如果用了两个，直接替换成一个 $10$ 分一个 $20$ 分一定不亏。 $20$ 分的硬币最多只会用三个，如果用了四个，直接替换成一个 $10$ 分两个 $20$ 分一个 $50$ 分一定不亏。 $50$ 分的硬币最多只会用一个，如果用了两个，直接替换成一个 $50$ 分和一个一元一定不亏。 对于任何一种情况，重复使用上述规则一定会达到一个 $10$ 分硬币最多一个，$20$ 分最多三个，$50$ 分最多一个的情况，不会陷入重复甩锅的死循环。 因此枚举这三种硬币分别用了多少个，然后整百的部分直接用一元硬币填，取最少的答案就行了。 1007 Rikka with Travel难度：medium easy 基础直径练习题。 考虑判断 $(x,y)$ 能不能出现。劼论：任意取树上的一条直径，那么如果 $(x,y)$ 能出现，那么一定存在一种方案使得直径的两端都被使用了。证明很简单：假设存在一个端点没有被使用，那么考虑两条直线的四个端点 $a,b,c,d$，一定可以把一个端点给移动到直径的这个端点上，因为直径是树上最长的路径，因此这次移动一定不会减少路径的长度。 考虑对每一个长度 $x$，求可以满足的最长的 $y$，这样所有小于等于 $y$ 的值也都能被满足。考虑在直径上计算这些值：第一种情况，直径的两端分属不同的路径，那么可以枚举直径的一个端点那条路径在直径上的最后一个点，那么这一条路径的最大长度就是这个点到直径端点的距离加上这个点往直径外的最大延伸长度，另一条路径的最大长度也可以类似地求，其中最大延伸长度可以用一个 $O(n)$ 的 DFS 计算出来。第二种情况是有一条路径就是这条直径，那么另一条路径就是这条直径之外的最长路径长度，这个只要把直径上的点都删了再求一遍直径就行。 总的时间复杂度为 $O(n)$。 1008 Rikka with Stable Marriage难度：medium 稳定婚姻真实一个深刻的模型啊..这题明明很简单但是不知道为什么没人做。 考虑把男生和女生分别放到一棵 trie 树里面，然后考虑最高位：首先肯定是让不同子树的男生女生进行匹配，如果左子树里有一队，右子树里有一队，那么交换他们的伴侣肯定一个更好的选择。而因为左右子树的大小可能不均匀，所以在分开来匹配之后，不妨设左子树有一些男生剩下，右子树有一些女生剩下，这个时候就只能让败者组的他们互相舔舐伤口了。 写成代码很简单，下面是一个简单的伪代码： 123456789101112void match(node_b, node_g, depth) &#123; if (node_b.size == 0 || node_g.size == 0) return; if (depth == -1) &#123; marriage(node_b, node_g); return; &#125; match(node_b.l, node_g.r, depth - 1); match(node_b.r, node_g.l, depth - 1); match(node_b.l, node_g.l, depth - 1); match(node_b.r, node_g.r, depth - 1); node_b.update_size(); node_g.update_size();&#125; 其中 node_b 和 node_g 分别表示男孩和女孩对应的 trie 树节点，depth 表示现在考虑的是哪一层。大致的思想就是暴力递归下去然后贪心的匹配就行了。 因为每递归 $O(\log a_i)$ 层一定会有一对新人产生，所以总的时间复杂度是 $O(n \log a_i)$ 的。 1009 Rikka with Traffic Light难度：medium hard 首先可以发现一定存在一个最优方案，所有绿灯区间长度都大于等于 $T_1$，所有红灯区间长度都大于等于 $T_2$。如果如果小于的话，反正这一段时间也没有办法让人过红绿灯，不如就不变了。接着考虑如果灯在第 $t$ 时刻变成了绿灯，最优解中它会在什么时候变成红灯。（对于红灯变成绿灯的分析类似） 第一种可能性是在 $t+T_1$ 时刻变成红灯，在这种情况下，一定有在 $t$ 之前（包括 $t$） 时刻到达且还没有过马路的人，不然这一段没有人能过马路。 第二种可能性是在 $t+T_1$ 时刻之后，考虑在这段绿灯中最后过马路的那个人 $i$，他会在 $t_i+T_1$ 时刻后通过马路。因此这段绿灯在第 $t_i+T_1$ 时刻结束一定不亏。 我们把所有 $t_i+T_1$ 或者 $t_i+T_2$ (取决于 $i$ 的种类) 作为关键点，设 $f_i$ 为在第 $i$ 个人对应的关键切换成另一种灯时的已经能确定过马路时间的人的总等待时间（不妨假设第 $i$ 个人是第一类人）。注意这儿已经能确定过马路时间的人包括在 $t_i$ 时刻之前到达的第一类人和第 $t_i+T_1$ 时刻之前达到的第二类人 (最开始发现的性质保证了他们都能在 t_i+T_1) 时刻过马路。 考虑转移，首先从 $t_i+T1$ 开始，最优方案可能会进行若干段第一种可能性的转移，接着通过一个第二种可能性的转移直接跳到后面的某一个关键点。因为第一种可能性要求必须要有对应的人在等待，因此第一种转移最多进行 $O(n)$ 次。我们可以枚举第一段转移进行的次数，并求出对应的总等待时间（总等待时间的定义和 $f_i$ 一样）。 最后要处理的就是从枚举的这 $O(n)$ 段到后面的某一个关键点之间的转移，这个把式子列出来之后可以发现用斜率优化就能直接优化到 $O(n)$ 了。 总时间复杂度为 $O(n^2)$。数据造的我想吐。 1010 Rikka with Defensive Line难度：medium hard 我九条可怜最喜欢做的一件事，就是出大几何题，对自以为多开就能 AK 的人说“不”。 过气计算几何选手拼尽全力出的计算几何题..然后根本没人帮我验题..偷偷搞了一个 60 核 server 并行用极角排序验了一下.. 发现这个数据范围的 $O(n^2 \log n)$ 的极角排序并行后两三分钟就跑完了.. 感觉有点牛逼 首先可以发现对于一个凸包来说，如果一个直线和它有交，那么一定在直线的两侧（不严格）都有至少一个凸包上的顶点。因此我们对点集剥 $m$ （因为 $K$ 太丑这儿就用 $m$ 代替了）层凸包（重复求凸包，删除凸包上的点这一过程 $m$ 次），只有这些凸包上的点可能作为防御线的两个点之一，其他点都没有用了。 枚举一个点集中的点，把这个点作为坐标系的原点，那么对于任何一个方案，它小于等于 $m$ 的那一边一定覆盖了 $y$ 轴正半轴或者负半轴中的一个。可以先求所有覆盖了 $y$ 轴正半轴的方案，那么另一边只要对称一下再做一遍就行。同时不妨假设另一个端点在 $x$ 轴正方向，逆方向的情况也只要对称一下就行。 考虑这时哪些点可能作为答案：答案是把 $y$ 轴沿着逆时针防线方向旋转碰到的前 $m$ 个点。同时为了判断这些点是否合法还需要求沿着顺时针方向旋转碰到的前 $m$ 个点。如果把这些点求出来，那么就只要对每一个点看一下这 $2m+1$ 个点（包括原点）里是否有超过 $m$ 个点在这一边就行，这是一个非常基础的 two pointer （注意处理共线的情况）。 问题的关键就是如何求逆时针方向（顺时针方向同理）的前 $m$ 个点。因为现在的点集有特殊性：由 $m$ 个相互嵌套的凸包组成，因此我们考虑只有一个凸包的特殊情况。讨论可以发现，$y$ 轴正半轴和凸包的交点以及原点到凸包的切点把凸包分成了若干段，其中每一段从极角上考虑都是有序的。因此 $m$ 个凸包一共分成了 $O(m)$ 段，用一个多路归并把这些段归并起来就行。求交点可以按照 $x$ 轴排序枚举原点，这样就可以分上下凸壳分别扫过去；求割点可以用旋转卡壳预处理，这两部分总的时间复杂度都是 $O(nm)$ 的。 算上 $m$ 路归并的复杂度 $O(m \log m)$，总的时间复杂度为 $O(nm \log m)$。 1011 Rikka with Segment Tree难度：medium 这个题是一个简单的分形题.. 做法也很传统，就是大力递归下去，难点在于比较麻烦。 我们用 $F(N)$ 表示到线段树的区间长度到 $N$ 为止的求和。那么除了 $1$ 的情况直接结束，其他的线段树都会递归左子树和右子树。如果我们假设左右子树都是从 $1$ 开始重新标号的话，那么左右子树都是递归到 $\frac{N}{2}$ 上下取整的子问题，这一部分用一个记忆化的递归就行。 考虑合并左右子树成 $n$ 的情况，首先所有叶子节点的深度都会增加 $1$，这一部分的贡献是 $\sum_{n=2}^N \sum_{i=1}^n i$，可以直接计算。 最后，因为加上左子树之后，右子树的所有点的编号会对应地发生变化，因此需要再算上对应的贡献。令 $g(n)$ 表示对应区间为 $n$ 的线段树所有叶子节点的深度和，设 $m$ 是最大的整数满足 $2^m \leq n$，那么 $g(n) = nm+2(n-2^m)$。而这一部分的贡献就是： \sum_{n=2}^N \left \lceil \frac{N}{2}\right \rceil g\left(\left \lfloor \frac{n}{2}\right \rfloor\right)推一个式子加上一通预处理，就能 $O(1)$ 计算这个和式了。 如果用 map 来进行记忆化的话，时间复杂度为 $O(\log^2 n)$。 每天一句叨叨 jls真牛逼 自己因为浪，导致今天又没学到什么，继续加油吧 你真的有在拼吗？想一想你3个月后的回想，你会后悔吗]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第17周[17/521]]]></title>
    <url>%2F2019%2F08%2F18%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC17%E5%91%A8-17-521%2F</url>
    <content type="text"><![CDATA[Algorithm虽然比赛很自闭，但仍一直在补牛客杭电多校题目，一起加油 ReviewYour Work Is the Only Thing That MattersIf you cease practicing for a second, if you let your mind get wound too tight or simply allowed to drift elsewhere, you will lose that ability. Your bat will stop connecting with the ball, your batting average will drop and soon enough you yourself will be dropped, first from the majors and then the sport altogether. 是啊，我们只要放松一秒，我们的竞技水平就会急剧下滑，所以我们不能放松，否则就是万丈深渊，输掉曾经所有的努力 TipsC++11使用emplace_back代替push_back这个文章好久好在它的泛用性，你可以使用里面的头文件去做其他的时间测试 Share银联挑战赛复赛A,B题_算法日常[8/100] 10进制矩阵快速幂-狼胆带你每天头铁一题-算法日常[9/100] 折半搜索_算法日常[10/521] 2019牛客多校9E题详解_算法日常[11/100] 2019牛客多校10 B题_算法日常[12/100] 2019牛客第十场F题详解_算法日常[13/100]]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客第十场F题详解_算法日常[13/100]]]></title>
    <url>%2F2019%2F08%2F18%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-13-100%2F</url>
    <content type="text"><![CDATA[2019牛客第十场F题详解题目2019牛客第十场F题详解 题解我的分析请看代码 本来以为发现了更快更简单的做法，结果想写成思路给大家看，然后不断想怎么表述这个算法，想着想着发现这是一个假的超快AC算法，然后大家有兴趣的话可以看我的AC代码二的分析(果然写blog做搬运工也是有收获的) AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define pb push_backusing namespace std;const int maxn=6e5+5;const int N=6e5+3;int a[maxn],b[maxn],cnt[maxn],ans,n,r;vector &lt;int&gt; h[maxn];multiset &lt;int&gt; s;void add(int x)&#123; auto p=s.find(cnt[x]); s.erase(p); cnt[x]++; s.insert(cnt[x]);&#125;void del(int x)&#123; auto p=s.find(cnt[x]); s.erase(p); cnt[x]--; s.insert(cnt[x]);&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; r; for (int i=0;i&lt;n;i++)&#123; cin &gt;&gt; a[i] &gt;&gt; b[i]; /* 统一右移2*r */ a[i]+=r*2; b[i]+=r*2; &#125; for (int i=0;i&lt;n;i++)&#123; /*打a[i]的时候,把a[i]-r,a[i]+r也叠加上a[i]上面的值, 这样就能使得a[i]表示打a[i]能获得的总值*/ h[a[i]-r].pb(b[i]); h[a[i]].pb(b[i]); h[aa[i]+r].pb(b[i]); cnt[b[i]]++; cnt[b[i]-r]++; cnt[b[i]+r]++; &#125; for (int i=r;i&lt;=N-r;i++) s.insert(cnt[i]); for (int i=r;i&lt;=N-r;i++)&#123; /*得到中间打这里能够得到的个数*/ int ret=(int)h[i].size(); /*暂时删除相关的所有列值*/ for (auto x:h[i]) del(x),del(x-r),del(x+r); /*然后得到当下最大的3列值*/ auto p=s.rbegin(); ans=max(ans,ret+(*p)); /*再把列值插回去*/ for (auto x:h[i]) add(x),add(x-r),add(x+r); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; 能更快AC的假算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*直接行列序列化排序的做法,真滴是好想法!*//*2019年8月18日20:26:30 发现这是一个假做法！靠着数据水才过的！因为这里只比较了最大的3个行值，就去比较列值了！因为可能有一种情况就是选第4大行，但是取到的列值更多，这应该是有可能出现的，总之这种做法虽然能过 但是是有可能遗漏情况的假算法！必须要枚举到所有的行*/#include&lt;bits/stdc++.h&gt;using namespace std;const int M =1e5 + 10;int num[M *3];int n , r , ans;int cnt[M * 3];struct node&#123; int x , y; int id; bool operator&lt;(node d)const&#123; return x &gt; d.x; &#125;&#125;a[M] , b[M];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n &gt;&gt;r; for(int i =1;i &lt;= n;i++)&#123; cin &gt;&gt; a[i].x &gt;&gt; a[i].y; a[i].x++; a[i].y++; num[a[i].x]++; &#125; /*枚举每个行坐标,相加从上到下3行的值--&gt;二维降到一维*/ for(int i = 1;i &lt;= 100000;i++)&#123; /*之所以放在最左边是因为i是从最左边开始,免去判断*/ b[i].x = num[i] + num[i +r] + num[i +r +r]; b[i].id = i; &#125; /*行值获利大到小排序*/ sort(b + 1 ,b + 100001); for(int i = 1;i &lt;= 3;i++)&#123; memset(cnt , 0 ,sizeof(cnt)); for(int j = 1;j &lt;= n;j++)&#123; /*除去原来的行(3次行值取max)以外的其他列的值的统计*/ if(a[j].x != b[i].id &amp;&amp; a[j].x != b[i].id +r &amp;&amp; a[j].x != b[i].id +r * 2) cnt[a[j].y]++; &#125; int sum = 0; for(int j = 1; j &lt; M;j++) sum = max( sum , cnt[j] + cnt[j +r] +cnt[j + r + r]); ans = max(ans , sum + b[i].x); &#125; cout &lt;&lt; ans &lt;&lt;endl;&#125; 每天叨叨一句天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>狼胆带你每天头铁一题</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客多校10 B题_算法日常[12/100]]]></title>
    <url>%2F2019%2F08%2F17%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-12-100%2F</url>
    <content type="text"><![CDATA[2019牛客多校10 B题题目2019牛客多校10 B题 题解思路 (详见代码注释) C++由于容易数据溢出，所以必须加限制，否则会造成数据溢出的错误，昨晚WA了两个小时的血的教训 k不会到很大的数据范围(限制在了k&lt;10^12) 然后递归的时候是一样的,最终也是递归到x==1,x==2 是按照题中斐波那契递归回去的，所以不会出错 AC代码写了python版之后去写C++版本的，结果一直WA了整整2个多小时，眼睛痛，所以决定明天早起再看看哪里出错了并给出C++版的AC代码(第二天已经更新) Python3版12345678910111213141516171819202122232425# python3lf = [0, 6, 7]# 一千多项的时候远远超过了10^12+7的for _ in range(1000) : lf.append(lf[-2] + lf[-1]) # if _ == 999: # print(If[-1])def f(x, s) : if x == 1 : return "COFFEE"[s] if x == 2 : return "CHICKEN"[s] if s &gt;= lf[x-2] : return f(x - 1, s - lf[x - 2]) else : return f(x - 2, s)for _ in range(eval(input())) : n, s = map(int, input().split()) s -= 1 # 从s到min(s+10,lf[n]), 用中括号括起来生成列表 r = [f(n, t) for t in range(s, min(s + 10, lf[n]))] print(''.join(r)) C++AC代码1_与题解思路相同的1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=1000000007;ll len[505];string ans;int T,n;ll k;char f(int x,ll k)&#123; if(x==1) return "COFFEE"[k]; if(x==2) return "CHICKEN"[k]; if(k&gt;=len[x-2]) return f(x-1,k-len[x-2]); else return f(x-2,k);&#125;int main()&#123; ios::sync_with_stdio(false);cin.tie(0); len[1] = 6,len[2] = 7; ll mx = 1e13; /*这里最好不要break,否则会造成数组的部分是0值，除非先赋值为mx (当然也可以使用C++AC代码二的特殊提前处理去使用break) 但是可以通过min控制数值大小，以免引发数据溢出错误 可以使用min的原因是，k不会到很大的数据范围 然后递归的时候是一样的,最终也是递归到x==1,x==2 是按照题中斐波那契递归回去的，所以不会出错*/ for(int i=3;i&lt;=500;i++)&#123; len[i] = min(len[i-2]+len[i-1],mx); &#125; for(cin&gt;&gt;T;T--;)&#123; cin&gt;&gt;n&gt;&gt;k; k-=1; ans.clear(); ll tn = min(k+10,len[n]); for(ll i=k;i&lt;tn;i++)&#123; ans += f(n,i); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; C++AC代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod = 1e9 + 7;const int inf = 0x3f3f3f3f;const int maxn = 100000 + 5;ll len[505];string str[3];string dfs(int x, ll a, ll b) &#123; /*substr的第二个参数是长度*/ if(x &lt;= 2) return str[x].substr(a-1, b); if(a+b-1 &lt;= len[x-2]) return dfs(x-2, a, b); if(a &gt; len[x-2]) return dfs(x-1, a-len[x-2], b); /*分段后..x-1可以直接从1开始了*/ return dfs(x-2, a, len[x-2]-a+1) + dfs(x-1, 1, b-(len[x-2]-a+1));&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); str[1] = "COFFEE"; str[2] = "CHICKEN"; len[1] = 6, len[2] = 7; ll mx = 1e17; for(int i = 3; i &lt;= 500; i++) &#123; /*前缀和*/ len[i] = len[i-1] + len[i-2]; /* i=80就会跳出*/ if(len[i] &gt; mx) &#123;/*cout&lt;&lt;i&lt;&lt;endl;*/break;&#125; &#125; int T; cin &gt;&gt; T; while(T--) &#123; int n; ll k; cin &gt;&gt; n &gt;&gt; k; int x; /*提前给x降低大小，所以就可以前面使用break，并且减少递归的次数*/ for(x = 1; x &lt;= n; x++) &#123; if(len[x] &gt;= k+10) break; &#125; if(x == n+1) cout &lt;&lt; dfs(x-1, k, min(10ll, len[x]-k+1)) &lt;&lt; endl; else &#123; if((n-x)%2) x++; cout &lt;&lt; dfs(x, k, min(10ll, len[x]-k+1)) &lt;&lt; endl; &#125; &#125; return 0;&#125; 每天一句叨叨不用去刻意讨好谁，因为只有做自己，才配得上最棒的人生]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>狼胆带你每天头铁一题</tag>
        <tag>斐波那契数列</tag>
        <tag>递归</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客多校9E题详解_算法日常[11/100]]]></title>
    <url>%2F2019%2F08%2F16%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-11-100%2F</url>
    <content type="text"><![CDATA[组合数学思维题题目链接2019牛客多校9 E题 题解思路其实解法一二的本质内核是一样的，可以都看一下 解法一当合并这两个集合的时候，应该将这两个集合合并后消失的贡献减去消失的贡献就应该是选择了一个a，选择了一个b，从剩下的众多集合中选择两个(即cd,ce,ef……)那么这个怎么算呢，可以用完全平方公式来推导(a+b+c+d)^2=a^2+b^2+c^2+d^2+2ab+2ac+2bc+2ad+2bd+2cd所以众多集合中选择任意选择两个的情况可以用（和的平方-平方的和）/2来求（最重要的一步） 解法二 AC代码解法一代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using ll = long long;const int MAXN = 100010;int n, m;int f[MAXN], sz[MAXN];ll sum;inline ll sqr(int x) &#123; return 1ll * x * x;&#125;inline int getf(int x) &#123; return f[x] == x ? x : (f[x] = getf(f[x]));&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); ll ans = (__int128) n * (n - 1) * (n - 2) * (n - 3) / 24; printf("%lld\n", ans); for (int i = 1; i &lt;= n; ++i) &#123; f[i] = i; sz[i] = 1; &#125; /*最开始的平方和*/ sum = n; while (m--) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); u = getf(u); v = getf(v); if(ans==0 || u==v) goto END; if (u != v) &#123; /*减掉合并部分的平方和*/ sum -= sqr(sz[u]) + sqr(sz[v]); /*后面的(sqr(n - sz[u] - sz[v]) - sum) / 2;就是`和的平方`-`平方和`=`剩下的所有两两组合`*/ ll tmp = 1ll * sz[u] * sz[v] * (sqr(n - sz[u] - sz[v]) - sum) / 2; f[u] = v; sz[v] += sz[u]; /*新的平方和的维护*/ sum += sqr(sz[v]); /*减去合并减少的贡献值*/ ans -= tmp; &#125; END: printf("%lld\n", ans); &#125; return 0;&#125; 解法二代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod = 1e9 + 7;const int inf = 0x3f3f3f3f;const int maxn = 100000 + 5;ll C[maxn][5];int p[maxn], sz[maxn], cnt[maxn];int n, m;ll ans;set&lt;int&gt; st;inline void init() &#123; for(int i = 0; i &lt; maxn; i++) C[i][0] = 1; for(int i = 1; i &lt; maxn; i++) &#123; for(int j = 1; j &lt; 5; j++) &#123; C[i][j] = C[i-1][j] + C[i-1][j-1]; &#125; &#125;&#125;inline int Find(int x) &#123; return x == p[x] ? x : p[x] = Find(p[x]); &#125;inline void Union(int x, int y) &#123; int fx = Find(x), fy = Find(y); if(fx != fy) &#123; if(fx &gt; fy) swap(fx, fy); p[fx] = fy; ll tp = C[n-sz[fx]-sz[fy]][2]; for(auto i : st) &#123; tp -= C[i][2]*cnt[i]; &#125; tp += C[sz[fx]][2]+C[sz[fy]][2]; if(tp &gt; 0) ans -= 1LL*sz[fx]*sz[fy]*tp; cnt[sz[fx]]--; cnt[sz[fy]]--; if(cnt[sz[fx]] == 0) st.erase(sz[fx]); if(cnt[sz[fy]] == 0) st.erase(sz[fy]); sz[fy] += sz[fx]; cnt[sz[fy]]++; st.insert(sz[fy]); &#125;&#125;int main() &#123; init(); scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; p[i] = i; sz[i] = 1; &#125; cnt[1] = n; st.insert(1); ans = C[n][4]; printf("%lld\n", ans); while(m--) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); Union(u, v); printf("%lld\n", ans); &#125; return 0;&#125; 每天一句叨叨生活总是很奇妙，我们到底该去向何方？ 世俗的成功吗？还是当下的快乐呢？ 珍惜身边的人呢？还是继续寻找？]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>狼胆带你每天头铁一题</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折半搜索_算法日常[10/521]]]></title>
    <url>%2F2019%2F08%2F15%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-10-521%2F</url>
    <content type="text"><![CDATA[题目题目链接2019牛客多校9 D题 题解折半搜索,详见下面的算法推荐和下面的AC的代码 meet-in-middle AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod = 1e9 + 7;const int inf = 0x3f3f3f3f;const int maxn = 1e6;struct node &#123; ll v; int id; bool operator &lt; (const node&amp; r) const &#123; return v &lt; r.v; &#125;&#125;b[maxn];ll arr[40];ll a[maxn], c[maxn];int main() &#123; int n; ll sum; scanf("%d%lld", &amp;n, &amp;sum); for(int i = 0; i &lt; n; i++) scanf("%lld", &amp;arr[i]); int x = n/2, y = n-x; int up1 = (1&lt;&lt;x), up2 = (1&lt;&lt;y); /*全0到全1串的遍历，然后之后是对每个串的逐位遍历，记录此串的和值*/ for(int i = 0; i &lt; up1; i++) &#123; for(int j = 0; j &lt; x; j++) &#123; if(i &amp; (1&lt;&lt;j)) a[i] += arr[j]; &#125; &#125; for(int i = 0; i &lt; up2; i++) &#123; b[i].id = i; b[i].v = 0; for(int j = 0; j &lt; y; j++) &#123; if(i &amp; (1&lt;&lt;j)) b[i].v += arr[x+j]; &#125; &#125; /*让B[i]数组有序，然后使用lower_bound去搜索*/ sort(b, b+up2); for(int i = 0; i &lt; up2; i++) c[i] = b[i].v; /*这里复杂度是2^18*log(2^18) = 4.7*10^6左右*/ for(int i = 0; i &lt; up1; i++) &#123; int p = lower_bound(c, c+up2, sum-a[i])-c; if(c[p]+a[i] == sum) &#123; for(int j = 0; j &lt; x; j++) &#123; if(i &amp; (1&lt;&lt;j)) printf("1"); else printf("0"); &#125; int id = b[p].id; for(int j = 0; j &lt; y; j++) &#123; if(id &amp; (1&lt;&lt;j)) printf("1"); else printf("0"); &#125; break; &#125; &#125; return 0;&#125; 每天叨叨一句“我不同意你， 但我可以支持你”李开复原来是学法律的，但他爱好计算机，后来师从美国卡内基梅隆大学计算机学院院长罗杰·瑞迪。 罗杰非常喜欢李开复，把自己的知识毫无保留地传授给李开复，使得他在编程水平突飞猛进。但随着研究的深入，李开复与导师有了分歧，尤其是在计算机语音识别系统研究时，罗杰主张用传统的方法，可是李开复却想从另一个方向，这悖离了主流，有别于大多数语音技术同行。怎么办？导师给李开复指出来了，让他“悬崖勒马”。可是李开复还是想按照自己的想法做。 有不少关系李开复的好心人提醒他：“你在计算机领域还乳臭未干，人家罗杰是美国国家工程学院和美国艺术与科学学院院士，你听导师的，可以少走弯路。”可是李开复却说：“我想另辟溪径。”“可是这样会得罪导师，如果得不到他的支持，你可能寸步难行。你另搞一套，如果成了，让他多没面子。相反你顺从了他，他是总统特别顾问委员会信息委员会成员、‘图灵奖’获得者，有他的提携，将来前途不可限量。”可是那时的李开复没想那么复杂，还是决定走自己的路。 没想到，尽管导师批评了李开复几次，可是李开复一意孤行。罗杰说：“作为科学家，我也不是全知全能。我不同意你的看法，但我可以支持你。”这让李开复非常意外。 此后，李开复就放开手脚大干起来。不久，罗杰又来问李开复：“有没有什么困难？”“暂时没有。”“如果有什么需要我帮助的，尽管说啊。”李开复反问道：“你不生我的气啊？”“‘不认同’不等于‘不支持’。”罗杰说。 参考链接http://blog.sina.com.cn/s/blog_98acb6e70102w95o.html]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>狼胆带你每天头铁一题</tag>
        <tag>折半搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10进制矩阵快速幂-狼胆带你每天头铁一题-算法日常[9/100]]]></title>
    <url>%2F2019%2F08%2F14%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-9-100%2F</url>
    <content type="text"><![CDATA[头铁来源因为狼胆小编本人比较垃圾，所以只能每天带大家头铁一题简单常识题(大佬眼中的常识，我这个蒟蒻还只能头铁)，希望能帮助到小白，那就很开心了 题目题目链接2019牛客多校5 B题 题解理想中的草稿状态 真实的草稿状态 dreammoon大佬的官方的题解也可以看看 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;typedef unsigned long long ULL;const int SIZE = 3000010;ULL MOD;char s[SIZE];/*矩阵相乘，第一行乘以第一列，第一行乘以第二列……也可以使用for两重循环求*/void mul(ULL* c1, ULL* c2, ULL *res)&#123; res[0] = (c1[0] * c2[0] + c1[1] * c2[2]) % MOD; res[1] = (c1[0] * c2[1] + c1[1] * c2[3]) % MOD; res[2] = (c1[2] * c2[0] + c1[3] * c2[2]) % MOD; res[3] = (c1[3] * c2[3] + c1[2] * c2[1]) % MOD;&#125;int main() &#123; int a,b; int x1,x2; scanf("%d%d%d%d", &amp;x1, &amp;x2, &amp;a, &amp;b); scanf("%s%llu",s, &amp;MOD); int len = 0; /* 统计长度，并且把个位的值(即最后一位的值)减去1 */ for(; s[len]; len++); s[len-1]--; /* 个位减掉了之后向前面借位 */ for(int i = len - 1; i &gt;= 0 &amp;&amp; s[i] &lt; '0'; i--)&#123; s[i] = '9'; s[i-1]--; &#125; ULL now0 = x1, now1 = x2; ULL d[4][4]; d[0][0] = 0; d[0][1] = 1; d[0][2] = b; d[0][3] = a; for(int it = len - 1; it &gt;= 0; it--)&#123; memset(d[1], 0, sizeof(ULL) * 12); /*A "常数"矩阵相乘4次*/ for(int p = 1; p &lt; 4; p++)&#123; mul(d[p-1], d[p-1], d[p]); &#125; s[it] -= '0'; for(int p = 0; p &lt; 4; p++)&#123; if((s[it] &gt;&gt; p) &amp; 1)&#123; ULL* ml = d[p]; std::tie(now0, now1) = std::make_pair((ml[0] * now0 + ml[1] * now1) % MOD,(ml[2] * now0 + ml[3] * now1) % MOD); &#125; &#125; mul(d[1], d[3], d[0]); &#125; printf("%llu\n", now1); return 0;&#125; 少量知识点tie pair是tuple的一个子集 每天一句叨叨今天看到一禅小和尚: 我们尝遍生活的苦，却都只是为了过好平凡的一生 但我觉得如果自己明知道人生是苦，明知道人是基因的机器人(参见算法日常4的叨叨)，却认认认真真地选择好好生活，这就是一种伟大，这就是自由，这就是自己的突破，就是自己的英雄！]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>狼胆带你每天头铁一题</tag>
        <tag>数学</tag>
        <tag>矩阵快速幂</tag>
        <tag>10进制矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[银联挑战赛复赛A,B题_算法日常[8/100]]]></title>
    <url>%2F2019%2F08%2F13%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-8-100%2F</url>
    <content type="text"><![CDATA[缘起8月10号是计算机设计大赛决赛答辩的最后一天，这天下午是牛客多校8，晚上是银联挑战赛复赛，队友出去吃吃喝喝了，我点个外卖，打着比赛，然后第一题就卡住不会做，然后自闭了，果然银联的比赛很重视数学题啊啊啊，是我数学题没怎么练，太菜了—-&gt;所以菜导致既没有吃到好东西，又导致爆零没太多收获，所以还是需要多多努力 A题爱喝「肥宅快乐水」的班长爱喝「肥宅快乐水」的班长 题目解法 看不懂的知识链接隔板法 扩展的隔板法中： 转化前的空盒 == 转化后每个盒子至少放一个 AC代码1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=1000000007;const int inf = 0x3f3f3f3f;const int M = 2e3+7;int C[M][M];int T,n,m;void add(ll &amp;a,ll v)&#123; a += v; if(a &gt;= mod) a-=mod;&#125;void pre()&#123; for(int i=0;i&lt;M;i++)&#123; C[i][0]=1; for(int j=1;j&lt;=i;j++)&#123; C[i][j]=C[i-1][j-1]+C[i-1][j]; if(C[i][j]&gt;=mod) C[i][j]-=mod; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false);cin.tie(0); cin&gt;&gt;T; pre(); while(T--)&#123; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;C[n+m-2][m-1]&lt;&lt;endl; &#125; return 0;&#125; B题整数对整数对 题目解法 AC代码1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll T,n,m,p,ans;int main()&#123; ios::sync_with_stdio(false);cin.tie(0); cin&gt;&gt;T; while(T--)&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;p; ans = 0; ll x = n/p; for(ll r = 0; r &lt; p ; r++ )&#123; /*求出b的种类数*/ ll bn = m/(p/__gcd(r,p)); /*分别对应题解的1,2,3种情况,其实1,3可以合并*/ if(!r) ans+=x*bn; else if(0&lt;r &amp;&amp; r&lt;=n%p) ans+=(x+1)*bn; else ans+=x*bn; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 每天一句叨叨人心的成见如同一座大山，我们总是口上说不能有偏见，其实真正的内心想法却不是这样的… 所以我对别人的偏见，我只能尽量克制，让自己理性对待，然后做之不止，乃成君子 对于别人对自己的偏见不要在意，而是要专注自己的目标 感觉自己生来就有一种追求挑战的血液，在小时候尤为明显，但是感觉在长久的教化过程中削弱了，所以我想要找回本真，生命不息，战斗不止，和天生的不公斗到底，做自己的英雄]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>组合数学</tag>
        <tag>隔板法</tag>
        <tag>数学思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第16周[16/521]]]></title>
    <url>%2F2019%2F08%2F11%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC16%E5%91%A8-16-521%2F</url>
    <content type="text"><![CDATA[Algorithm牛客多校8的签到 ReviewBeing Happy Is Hard Work好多生词啊，所以决定开始背单词Happiness, in other words, is practiced. Tips打算法比赛一定要熟练使用线段树啊，血的教训 Share2019杭电多校1006和1007算法日常[4/100] 后缀数组-算法学习日常[5/100] 2019杭电多校6_1005算法日常[6/100] 2019牛客多校8_B题算法日常[7/100] 每天一句叨叨生活总有太多的美好无法用相机记录下来，所以那就给每一个当下投以最好的微笑吧]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客多校8_B题算法日常[7/100]]]></title>
    <url>%2F2019%2F08%2F11%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-7-100%2F</url>
    <content type="text"><![CDATA[题目题目链接以及描述2019牛客多校8_B题 题意以及思路 AC代码1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100000 + 5;int a[maxn], b[maxn], c[maxn];int main() &#123; int n; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); /*c[i]记录的是a[i]的上一个位置加1的位置*/ c[i] = b[a[i]]+1; b[a[i]] = i; &#125; ll ans = 0; for(int i = 1; i &lt;= n; i++) &#123; ans += 1LL*(n-i+1)*(i-c[i]+1); &#125; printf("%lld\n", ans); return 0;&#125; 每日一句叨叨但求精进,无问西东]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019杭电多校6_1005算法日常[6/100]]]></title>
    <url>%2F2019%2F08%2F07%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-6-100%2F</url>
    <content type="text"><![CDATA[题目题目链接2019杭电多校6_1005_HDU6638 思路自己一开想偏了，想着像以前0,1矩阵那种同权值点一样叠加成为矩形的最大面积来求解，这样子就能让复杂度在O(n^2)的样子 然后并非如此，这里的权值w是一个可正可负的整数…自己隐隐约约地感觉复杂度要达到O(n^2*log(n)),但是没有往下想，虽然想了也不一定会,,,emmmm,继续努力吧 正解 首先将纵坐标离散化到 O(n) 的范围内，方便后续的处理。 将所有点按照横坐标排序，枚举矩形的上边界，然后往后依次加入每个点，这样就确定了矩形的上下边界。 设 v[y] 表示矩形内部纵坐标为 y 的点的权值和，则答案为 v 的最大子段和，用线段树维护带修改的最大子段和即可。 时间复杂度 O(n^2*log(n)) std理解版今天比较晚了，明天要出一趟远门，所以暂时没有手写，对不起自己啊，等回家一定要好好把这个重新写几遍12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int N=2010,M=4100;int Case,n,m,i,j,k,cb,b[N],pos[N];ll pre[M],suf[M],s[M],v[M],ans;struct E&#123;int x,y,z;&#125;e[N];inline bool cmp(const E&amp;a,const E&amp;b)&#123;return a.x&lt;b.x;&#125;/*用纵坐标建的线段树，大佬对于线段树的理解以及如同我对1+1的理解一样了！*/void build(int x,int a,int b)&#123; pre[x]=suf[x]=s[x]=v[x]=0; if(a==b)&#123; pos[a]=x; return; &#125; int mid=(a+b)&gt;&gt;1; build(x&lt;&lt;1,a,mid),build(x&lt;&lt;1|1,mid+1,b);&#125;inline void change(int x,int p)&#123; x=pos[x]; s[x]+=p; if(s[x]&gt;0)pre[x]=suf[x]=v[x]=s[x];else pre[x]=suf[x]=v[x]=0; /*上传的操作精辟,orz*/ for(x&gt;&gt;=1;x;x&gt;&gt;=1)&#123; /*根的左边的 = max(左子树之前的,左子树+右子树之前的)*/ pre[x]=max(pre[x&lt;&lt;1],s[x&lt;&lt;1]+pre[x&lt;&lt;1|1]); /*根的右边的 = max(右子树右边的,右子树+左子树右边的)*/ suf[x]=max(suf[x&lt;&lt;1|1],s[x&lt;&lt;1|1]+suf[x&lt;&lt;1]); /*s是直接叠加的*/ s[x]=s[x&lt;&lt;1]+s[x&lt;&lt;1|1]; /*区间最大值 = max(左子树最大,右子树最大,左子树后面的+左子树前面的)*/ v[x]=max(max(v[x&lt;&lt;1],v[x&lt;&lt;1|1]),suf[x&lt;&lt;1]+pre[x&lt;&lt;1|1]); &#125;&#125;int main()&#123; scanf("%d",&amp;Case); while(Case--)&#123; scanf("%d",&amp;n); for(cb=0,i=1;i&lt;=n;i++)&#123; scanf("%d%d%d",&amp;e[i].x,&amp;e[i].y,&amp;e[i].z); b[++cb]=e[i].y; &#125; /*离散化纵坐标*/ sort(b+1,b+cb+1); for(m=0,i=1;i&lt;=cb;i++)if(i==1||b[i]!=b[m])b[++m]=b[i]; /*给横坐标排序*/ sort(e+1,e+n+1,cmp); ans=0; /*用离散化后的纵坐标覆盖掉原来的纵坐标*/ for(i=1;i&lt;=n;i++)e[i].y=lower_bound(b+1,b+m+1,e[i].y)-b; /*枚举上边界，x是行号，是上边界*/ for(i=1;i&lt;=n;i++)if(i==1||e[i].x!=e[i-1].x)&#123; build(1,1,m); /*加入点确定好下边界，这样上下边界都确定好了*/ for(j=i;j&lt;=n;j=k)&#123; /*又是逐步插入空树维护区间最大值的操作*/ for(k=j;k&lt;=n&amp;&amp;e[j].x==e[k].x;k++)change(e[k].y,e[k].z); if(ans&lt;v[1])ans=v[1]; &#125; &#125; printf("%lld\n",ans); &#125;&#125; 每天一句叨叨今天是情人节，然而…没得女朋友…不过有队友和我一起大杭电多校还是很开心的啦(还是有点点失落) 虽然 但是谁终将声震人间，必长久深自缄默 谁终将点燃闪电，必长久如云漂泊 全力以赴打完这一段时光的退役赛一定会是一个大学乃至人生最珍贵的记忆，所以这段时间先不要让自己被一个体内的激素控制，等时机到了，一定会更加美好！加油吧，少年！]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>线段树</tag>
        <tag>算法学习日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组-算法学习日常[5/100]]]></title>
    <url>%2F2019%2F08%2F06%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8-5-100%2F</url>
    <content type="text"><![CDATA[后缀数组论文分享后缀数组论文分享 每天一句叨叨人一能之，己百之；人十能之，己千之。果能此道矣，虽愚必明，虽柔必强。]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019杭电多校1006和1007算法日常[4/100]]]></title>
    <url>%2F2019%2F08%2F05%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-4-100%2F</url>
    <content type="text"><![CDATA[序 今天是杭电多校第5场，然后1006签到本来应该10mins内写完，然后我菜鸡写了2小时(各种问题不熟练和紧张)，赛后发现有大佬用dc3(一种据说复杂度O(n)的后缀数组算法,发现自己孤陋寡闻) 1007真滴有趣…闪电蛇皮走位，然后自己想复杂了一点点… 题目链接2019杭电多校5 1006解法Ekmp，用s.substr(1)的串来做ekmp函数的原串，s做ekmp函数的匹配串，这样跑一次ekmp就行，然后累加extend ekmp学习教程·我觉得比较好的一个(我也用这个学的) AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;long long ans;// int next[1000000];int nxt[1000000];int extend[1000000];string S, T;int n, m;/* 求解 T 中 next[]，注释参考 GetExtend() */void GetNext(string &amp; T, int &amp; m, int next[])&#123; int a = 0, p = 0; next[0] = m; for (int i = 1; i &lt; m; i++) &#123; if (i &gt;= p || i + next[i - a] &gt;= p) &#123; if (i &gt;= p) p = i; while (p &lt; m &amp;&amp; T[p] == T[p - i]) p++; next[i] = p - i; a = i; &#125; else next[i] = next[i - a]; &#125;&#125;/* 求解 extend[] */void GetExtend(string &amp; S, int &amp; n, string &amp; T, int &amp; m, int extend[], int next[])&#123; int a = 0, p = 0; GetNext(T, m, next); for (int i = 0; i &lt; n; i++) &#123; if (i &gt;= p || i + next[i - a] &gt;= p) // i &gt;= p 的作用：举个典型例子，S 和 T 无一字符相同 &#123; if (i &gt;= p) p = i; while (p &lt; n &amp;&amp; p - i &lt; m &amp;&amp; S[p] == T[p - i]) p++; extend[i] = p - i; a = i; &#125; else extend[i] = next[i - a]; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); int t; cin&gt;&gt;t; while(t--)&#123; ans = 0; cin&gt;&gt;S; n = S.size(); T = S.substr(1); m = n - 1; /*可能程序以为我用了前面的函数声明中的next[],所以说我模棱两可,加个全局的命名空间就行 或者换个变量名也行*/ // GetExtend(T, m, S, n, extend, ::next); GetExtend(T, m, S, n, extend, nxt); for (int j = 0; j &lt; m; j++)&#123; // cout &lt;&lt; extend[j] &lt;&lt; " \n"[j==m-1]; ans += extend[j]+j==n-1 ? extend[j] : extend[j]+1 ; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 1007解法法一a[i] = a[i-1]+a[i-3],就是对于第i项有两种情况，要么是直接往上走要么是闪电 法二dls说暴力打表找规律比较不用动脑子，哭了，臭大佬，好过分 AC代码123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 998244353;const int inf = 0x3f3f3f3f;const int maxn = 100000 + 5;ll a[maxn];int main() &#123; a[1] = a[2] = a[3] = 1; for(int i = 4; i &lt; maxn; i++) a[i] = (a[i-1]+a[i-3])%mod; int T; scanf("%d", &amp;T); while(T--) &#123; int n, l, r; scanf("%d%d%d", &amp;n, &amp;l, &amp;r); if(l &gt; r) swap(l, r); if(l != 1) l++; if(r != n) r--; printf("%lld\n", a[r-l+1]); &#125; return 0;&#125; 注因为今天一直在听dls的直播，尽管后面的题听不懂，想听听dls一般解题思路是啥(其实后面听不懂就容易发呆了),所以今天还没有补很多题，然后就只写了这么一点点,我好弱啊 每天一句叨叨人总得有个目标，才能继续勇敢而坚强地活着，大部分成年人，在三十岁左右已经没了活着的目标，为了不让自己死去，他们制造了一个孩子，有了这个小孩，他们终于找到了努力工作和继续活下去的目标。 不，不是的，那是基因的谎言…让你这个机器人帮忙传递他们的存在 但如果你知道这是谎言，并决定真的要选择它，那才是真正的选择 教育本来就是不平等的，有些人很年轻就是OI金牌了，然而有些人还在发愁下次要怎么骗外公外婆我出去玩了，其实是偷偷跑去了网吧，如饥似渴地享受那几个小时的奥比岛，赛尔号，功夫派，洛克王国，地下城与勇士，英雄联盟…(从小学到高中渐渐变化的是游戏),然而别人早就享受到了算法的美妙，并将来很大程度能因此受到更好的教育，然后享受社会上最好的资源，过上幸福的生活，虽然我不能这样定义幸福，但是不平等确实存在，想要跨越社会阶层的鸿沟，可能要花上很久很久的努力.不过，我认为，跨越社会阶层的鸿沟，才是这个和平时代个人最英雄的挑战.做你自己的英雄，不断超越自己，并同时珍爱身边的人，过好这一生… 今天说的好像有点小多，叨叨叨多了，快滚去运动洗澡睡觉，明天继续来补题]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>ekmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python写字符串模拟真香_算法日常[3/100]]]></title>
    <url>%2F2019%2F08%2F04%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-3-100%2F</url>
    <content type="text"><![CDATA[题目链接2019牛客多校第6场B题 描述 解法解法一把8段中每段都处理成为一个整数,然后找出最长的连续0,相同的长度的话就让0放前面的段(因为0的ASCII码是48,比:的58小),然后进行判断性输出(数字用%x可以实现以16进制输出) 详见代码注释 C++版AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/*"%x"以16进制的形式输出,是我孤陋寡闻了*/#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int a[10];int main()&#123; int T,t; scanf("%d",&amp;T); for(int ii=1;ii&lt;=T;ii++)&#123; int f=0,l=0,nl=0; /*观察下面的代码容易知道,只有最前面为0的时候是f=1, 其他地方为0,f为i-nl(减掉了0的长度即为0开始的地方) 综上: f是最长连续0开始的位置 然后l是保存维护最长连续0的长度 nl是当前的最长连续0的长度*/ for(int i=1;i&lt;=8;i++)&#123; a[i]=0; for(int j=1;j&lt;=16;j++)&#123; scanf("%1d",&amp;t); a[i]=a[i]*2+t; &#125; if(!a[i]) nl++; else&#123; /*判断现在的连续0的数目是否超过之前的连续0的数目*/ if(nl&gt;=l&amp;&amp;nl&gt;1)&#123; f=i-nl;l=nl; &#125; nl=0; &#125; if(i==8&amp;&amp;nl&gt;1)&#123; if(nl&gt;l)&#123; f=i-nl+1;l=nl; &#125; /*末尾有0，但是末尾的连续0和最前面的连续0相同 所以考虑字典序最小，由于'0'-48,':'-58 所以优先让前面输出0,后面就输出':'*/ if(nl==l&amp;&amp;f==1)&#123; f=i-nl+1;l=nl; &#125; &#125; &#125; printf("Case #%d: ",ii); if(f==1)printf(":"); for(int i=1;i&lt;=8;i++)&#123; if(i==f)&#123; printf(":"); i+=l; &#125; if(i&gt;8)puts(""); else printf("%x%c",a[i],":\n"[i==8]); &#125; &#125; return 0;&#125; 解法二通过枚举每种有0的串，然后统一加到一个列表中，之后通过sort(优先长度然后优先字典序)，最后输出 详见我的Python注释代码 Python_AC代码12345678910111213141516171819T=int(input())for t in range(T): b=input() a=[] for i in range(8): # 这个[2:]是去掉'0x' a.append(hex(int(b[i*16:i*16+16],2))[2:]) s=[] s.append(':'.join(a)) for i in range(8): for j in range(i+1,8): # 对每个i中的后缀长a[i:j+1]判断各元素是否都是等于0的 # 是就直接把字符串丢进去,比C++AC版本中的记录长度简单很多 if all(map(lambda x:x=='0',a[i:j+1])): # 用':'分隔的a[i]串 s.append(':'.join(a[:i])+'::'+':'.join(a[j+1:])) # 优先用长度排序,其实是同长度按照字典序排序 s.sort(key=lambda x:(len(x),x)) print('Case #%d:'%(t+1),s[0]) 每天一句叨叨 岁月还漫长总会有人陪你骑马喝酒走四方]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>Python写算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第15周[15/521]]]></title>
    <url>%2F2019%2F08%2F04%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC15%E5%91%A8-15-521%2F</url>
    <content type="text"><![CDATA[Algorithm已经下定决心要努力刷题了，所以每天都有刷 ReviewChina Has Started a Grand Experiment in AI Education. It Could Reshape How the World Learns. 语句摘选 In three hours we understand students more than the three years spent by the best teachers. Three things have fueled China’s AI education boom. The first is tax breaks and other incentives for AI ventures that improve anything from student learning to teacher training to school management. For VCs, this means such ventures are good bets. According to one estimate, China led the way in over $1 billion invested globally last year in AI education. Second, academic competition in China is fierce. Ten million students a year take the college entrance exam, the gaokao. Your score determines whether and where you can study for a degree, and it’s seen as the biggest determinant of success for the rest of your life. Parents willingly pay for tutoring or anything else that helps their children get ahead. Finally, Chinese entrepreneurs have masses of data at their disposal to train and refine their algorithms.The population is vast, people’s views on data privacy are much more lax than in the West (especially if they can get coveted benefits like academic performance in return), and parents are big believers in the potential of technology, having seen how much it has transformed the country in just a few decades. Squirrel’s approach may yield great results on traditional education, but it doesn’t prepare students to be flexible in a changing world, the experts I spoke to say. “There’s a difference between adaptive learning and personalized learning,” says Chris Dede, a professor at Harvard University in the Technology, Innovation, and Education Program. Squirrel is doing adaptive learning, which is about “understanding exactly what students know and don’t know.” But it pays no attention to what they want to know or how they learn best. Personalized learning takes their interests and needs into account to “orchestrate the motivation and time for each student so they are able to make progress.” Much of Squirrel’s philosophy stems from Li’s own experiences as a child. When he was young, he didn’t have very good emotional intelligence, he says, and reading books on the subject didn’t help. So he spent half a year dividing the skill into 27 different components and trained himself on each one. He trained himself to be more observant, for example, and to be an interesting conversationalist (“I spent a lot of time finding 100 topics, so I have a lot of material to talk with others,” he says). He even trained himself to keep smiling when others criticized him. (“After that, in my life, I do not have any enemies.”) The method gave him the results he wanted — along with the firm belief that anything can be taught this way. That’s exactly what China lacks. If you are able to speak multiple languages, you are able to talk to different people; you are able to communicate different ideas感想 估计阅读时间是17mins，然而我抠脚的英语水平加上文章的深度和联想性让我看了整整一个小时 AI教学有很好的数据分析优势，计算机的快速处理数据能力，不分日夜地工作能力，都使得AI教学有很好的前景，只要不断地迭代分析数据的算法，一定可以让计算机拥有快速检测一个学生水平的能力，传统老师与计算机的差距在于经验的积累速度，不过对于单个知识点来说目前可能一个老师可能能给更好的帮助，所以我认为当下如果有AI算法辅助分析一个学生的水平，然后给针对的训练，再在个别的知识点上用上老师，那么可以大大降低对老师经验性的要求。因为我认为一个顶级老师和一个初级老师的区别仅在于对知识系统性的掌握以及对学生知识框架的快速认识能力上面(后者为主)，所以有了AI算法的辅助，将能降低家长花重金请名师的成本，而可以请一个初级老师+AI算法辅助的方式 感叹世界变化之快！ 感觉自己如果要成为认知层的上层人士，必须和世界进行连接，和更多的大师交流，那就必须学好英语，不然看一篇这样简单的文章要花上太久的时间…所以坚持好好学English！ Tips推荐一个OIwiki网站,内容很全面,分享给你们 Share线段树入门-AcWing-245-你能回答这些问题吗 priority-queue和multiset异同以及线段树空树插入维护初见 8数码和15数码算法结论和延展 拓扑排序以及C++读取空行[算法学习日常1/100] 反二分题的做法-算法日常[2/100] Python写字符串模拟真香_算法日常[3/100]]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反二分题的做法-算法日常[2/100]]]></title>
    <url>%2F2019%2F08%2F03%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-2-100%2F</url>
    <content type="text"><![CDATA[序今天是个好日子，开局多校D看起来就是个简单的二分模拟,马上动手写起来啊！然后一直写到了比赛结束(当然中途看了一下其他题,并且给队友提供了j题的解题思路) 反二分的2019牛客多校6D题题目链接 哒哒马蹄终究是错因为这个题目终极不是正规的二分做法！因为答案根本不满足二分算法中的答案单调性，比如如下反例1215 539 39 39 39 39 60 60 60 60 60 100 100 100 100 100 答案是199，而200不能是答案，201也不能是答案 (二分输出答案是216)(因为二分总是在较大数值的时候是满足的可能性极大的,所以二分后整体的结果偏大,其实有更小的答案漏掉了) 不过这题的美丽错误美就美在了它让人有种是二分的错误—(哒哒的马蹄，是个美丽的错误) 如何AC不过因为数据比较弱(其实造一个完美避开二分的数据几乎是不可能在题目数据范围实现的，如果可以，那我把二分后往小的方向开得更远一下枚举，根据上面分析为了避免小概率事件还可以多搞一下向大的方向也枚举)，所以我们现在可以有两种做法 先二分，然后在这个ans下继续向小的方向枚举20项 因为答案的下界和上界相差很小，可以直接枚举 二分再向小方向走1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/*因为数据弱，所以不满足单调性的时候这样这样来凑一手*/#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=1000000007;const int inf = 0x3f3f3f3f;const int M = 1e3+10;int T,n,K,v[M],sum,vis[M];bool check(int x)&#123; if(x*K&lt;sum || x&lt;v[n-1]) return false; if(x&gt;=v[n-1] &amp;&amp; K&gt;=n) return true; for(int i=0;i&lt;n;i++) vis[i]=0; int tmp=0,ts=sum; int i=1; while(ts&gt;0)&#123; int tps = 0; while(i&lt;=n &amp;&amp; vis[n-i]) i++; if(n-i&gt;=0) &#123; tps += v[n-i]; // cout&lt;&lt;"I get you! : "&lt;&lt;v[n-i]&lt;&lt;endl; vis[n-i]=1; &#125; else break; while(tps&lt;x)&#123; int tn = upper_bound(v,v+n-i,x-tps)-v; int j=1; while(j&lt;=tn &amp;&amp; vis[tn-j]) j++; if(tn-j&gt;=0) &#123; tps += v[tn-j]; // cout&lt;&lt;"I get you! : "&lt;&lt;v[tn-j]&lt;&lt;endl; vis[tn-j]=1; &#125; else break; &#125; // cout&lt;&lt;"How much is the tps "&lt;&lt;tps&lt;&lt;endl; ts -= tps; tmp++; &#125; if(tmp&gt;K) return false; return true;&#125;int main()&#123; ios::sync_with_stdio(false);cin.tie(0); cin&gt;&gt;T;int kase=1; while(T--)&#123; cin&gt;&gt;n&gt;&gt;K; sum = 0; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;v[i]; sum+=v[i]; &#125; sort(v,v+n); int l=1,r=1e6; while(l&lt;r) &#123; // cout&lt;&lt;"l: "&lt;&lt;l&lt;&lt;" r: "&lt;&lt;r&lt;&lt;endl; int mid = (l+r)&gt;&gt;1; if(check(mid)) r=mid;else l = mid+1; &#125; int ans = l; for(int i=ans;i&gt;=ans-20;i--) if(check(i)) ans = i; cout&lt;&lt;"Case #"&lt;&lt;kase++&lt;&lt;": "&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 正规做法-从下界开始枚举123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 代码来源--杭电的一个二人小分队 jesus#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N=1086;int v[N],vis[N];int n,k;bool check(int vv)&#123; int num=k; for(int i=0;i&lt;=n;i++)&#123; vis[i]=0; &#125; int left=n; int maxx=n,no=1; while(num)&#123; int sp=vv; for(int i=maxx;i&gt;0;i--)&#123; //如果当前剩余容量比最小的更小，不能继续装，退出循环 if(sp&lt;v[no])break; //如果当前剩余容量足够，并且物品i还没有装过，则装入 if(sp&gt;=v[i]&amp;&amp;!vis[i])&#123; sp=sp-v[i];vis[i]=1;left--; //如果无剩余，直接退出循环 if(!sp)break; &#125; &#125; //压缩下次寻找的范围 while(vis[maxx])maxx--; while(vis[no])no++; num--; &#125; //如果无剩余，则正好输出 if(!left)return 1; return 0;&#125;int main()&#123; int cases; scanf("%d",&amp;cases); for(int ti=1;ti&lt;=cases;ti++)&#123; scanf("%d%d",&amp;n,&amp;k); int sum=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;v[i]); sum+=v[i]; &#125; sort(v+1,v+n+1); int b=sum/k; if(sum%k)b++; int maxx=max(v[n],b); int ans=maxx; int i=maxx; while(i)&#123; if(check(i))&#123; ans=i;break; &#125; i++; &#125; printf("Case #%d: %d\n",ti,ans); &#125; return 0;&#125; 每天一句叨叨人生本来就是一场修行，人的基因把我们当做机器人，然后让我们为他们传递生命，所以给我们制造了很多激素，其中一些情绪激素让我们时而快乐时而悲伤，时而兴奋时而自闭，我们可能无法改变太多，唯有做的就是享受这个当机器人还能发发牢骚的快乐，并享受这一次人生的偶然，尽自己的快乐，去奋斗，去创造，因为平庸更使自己感到乏味…那就成为一个，不断进化，并快乐地享受其中的机器人吧]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>反二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序以及C++读取空行[算法学习日常1/100]]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%86%99%E5%B0%81%E6%83%85%E4%B9%A6%E7%BB%99%E7%AE%97%E6%B3%951%2F</url>
    <content type="text"><![CDATA[算法学习日常第一天2019年8月2日 今天上午，重新认识算法的全貌各种资源及知识点总结 并且还了解到了常见错误写法，当然自己当年也写过很多错误 下午先是补牛客5的多校G题的dp—接着昨天的补都补了90mins(含对着手写第一遍)，还是太菜了 然后补H题，发现自己昨天写了3个小时的这个题目不是字符串插入题…而是一个拓扑排序题..真的自己菜得可怕..写错分类怎么可能做对，然后自己又焦虑了很久，知道2019年8月2日15:48:15才静下来认真地学习拓扑排序 拓扑排序在紫书上学了下，就是把点对关系看成一个图里面的指向关系，即把每一个点对看做小数指向大数的有向边，如果图没有有向环的话，说明是可以的，否则是不行的 记自己头铁处理空行读入，搞了整整一个小时读取空行 拓扑排序以及空行头铁见代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/*2019年8月2日19:25:05拓扑排序bfs拓扑排序算法思想1、在AOV网络中选一个没有直接前驱的顶点, 并输出之;2、从图中删去该顶点, 同时删去所有它发出的有向边;---&gt;(我下面的题目使用stop实现删除)3、重复以上步骤, 直到◆ 全部顶点均已输出，拓扑有序序列形成，拓扑排序完成；◆ 或者图中还有未输出的顶点，但已跳出处理循环。这说明图中还剩下一些顶点，它们都有直接前驱，再也找不到没有前驱的顶点了。这时AOV网络中必定存在有向环。*/#include&lt;bits/stdc++.h&gt;using namespace std;const int M = 1e4+5;int n,m,lentmp;string s[10][10];/*用string本来可以不用下面的len*/int len[10][10];int it[10][10];string ans,t;bool check();bool solve();int main()&#123; ios::sync_with_stdio(false);cin.tie(0); cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m*(m-1)/2;i++)&#123; cin&gt;&gt;t&gt;&gt;lentmp; int x=t[0]-'a',y=t[1]-'a'; if(x&gt;y) swap(x,y); len[x][y] = lentmp; // if(lentmp) cin&gt;&gt;s[x][y]; /*我的头铁(~~比赛因此卡1小时去谷歌~~)写法 先直接用cin.get()吃掉t和lentmp后面的回车 再getline(), 否则getline会吃那个回车而导致少读数据*/ cin.get(); getline(cin,s[x][y]); &#125; if(!solve()) puts("-1"); return 0;&#125;/*暴力检测每队关系是否和整个串中的样子是一样的法二: 也可以每一对关系得到一个ans的tmp串,然后再去==判断 但是效率低*/bool check()&#123; for(int i=0;i&lt;m;i++)&#123; for(int j=i+1;j&lt;m;j++)&#123; int now = 0; for(int k=0;k&lt;n;k++)&#123; if(ans[k]=='a'+i||ans[k]=='a'+j)&#123; if(ans[k]!=s[i][j][now]) return 0; now++; &#125; &#125; if(now!=len[i][j]) return 0; &#125; &#125; return 1;&#125;bool solve()&#123; for(int i=0;i&lt;n;i++)&#123; /* 这里是每个大串的排序关系-通过m次的关系问询确定的 注意前面巧妙地处理出了j小于k---&gt;这就是拓扑排序的思路 1.对没有出现过的关系(即s[j][k]的那一维全为空)stop[j]和stop[k]全都赋值为1 2.对于到最后了的关系(即s[j][k][]='\0')全赋空 因为有m*(m-1)/2 对 关系，也就是每两个都有比较，所以一定能够得出最前面的一个字符..所以就完美了！ 这里每次stop都会清零！*/ bool stop[10] = &#123;&#125;; for(int j=0;j&lt;m;j++)&#123; for(int k=j+1;k&lt;m;k++)&#123; if(!s[j][k][it[j][k]]) stop[j]=stop[k]=1; else if(s[j][k][it[j][k]]=='a'+j) stop[k]=1; else stop[j] = 1; &#125; &#125; bool done = false; for(int j=0;j&lt;m;j++)&#123; if(!stop[j])&#123; ans+='a'+j; for(int k=0;k&lt;m;k++)&#123; if(k&lt;j) it[k][j]++; else if(k&gt;j) it[j][k]++; &#125; done = true; break; &#125; &#125; if(!done) return 0; &#125; if(!check()) return 0; cout&lt;&lt;ans&lt;&lt;endl; return 1;&#125; 晚上成功补完H题和I题，发现好像没有时间补B题了，明天上午来补一下B题 每日一句叨叨杜月笙知道成功需要代价，他想为自己洗白(小时候家里穷只能混黑帮)，为整个帮派洗白，但穿了大半辈子长褂(为了不露出纹身)，让自己的说书先生给自己讲了大半辈子学，也为上海的繁荣安定做了大半辈子贡献，但却最终未被认可(通过人脉被选之为一个参议长，但蒋介石让他自己退位)，但杜月笙却永远被后人被历史铭记 若命运不公，那就和它斗到底！]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>拓扑排序</tag>
        <tag>BFS</tag>
        <tag>读取空行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8数码和15数码算法结论和延展]]></title>
    <url>%2F2019%2F07%2F31%2F8%E6%95%B0%E7%A0%81%E5%92%8C15%E6%95%B0%E7%A0%81%E7%AE%97%E6%B3%95%E7%BB%93%E8%AE%BA%E5%92%8C%E5%BB%B6%E5%B1%95%2F</url>
    <content type="text"><![CDATA[此类问题是否有解定义一个东西先定义此类问题矩阵的逆序数的和值为除去0以外其他数的排列(把二维一行行地读取的循序的排列)的逆序数和 发现一我们可以发现排列中相邻的两个数交换位置会它们两相互之间的逆序数值,而其他部分以及他们各自和其他部分的逆序数值都不变,所以矩阵的逆序数+1或-1,也就是矩阵的逆序数的奇偶性发生了改变 发现二我们还可以发现0左右移动不影响矩阵的逆序数的奇偶性，然而如果是上(下)移动的话，就想到于一个数连续和左(右)边3个数进行了交换位置，所以矩阵的逆序数的奇偶性会变 发现三矩阵的改变只能通过与0变换位置，所以只有在与0上下交换的时候才会产生矩阵的逆序数的奇偶性的变化 结论所以我们知道最终状态逆序数为0,且最后0在最后一行(高中学化学经常讲终态法)，也就是矩阵要有解，最终逆序数的奇偶性为偶，那么就要在初始状态的逆序数上面 加上 0值在初始状态移动到最后一行产生的逆序数奇偶性的变化值仍为偶数则有解 题目有解性题HDU-6620 2019杭电多校4 手写AC代码1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int T,a[16];int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;T; while(T--)&#123; int cnt = 0; for(int i=0;i&lt;16;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;16;i++)&#123; if(!a[i])&#123; cnt+=3-i/4; &#125; else&#123; for(int j=0;j&lt;i;j++)&#123; if(a[j] &amp;&amp; a[j]&gt;a[i]) cnt++; &#125; &#125; &#125; if(cnt&amp;1) cout&lt;&lt;"No"&lt;&lt;endl; else cout&lt;&lt;"Yes"&lt;&lt;endl; &#125; return 0;&#125; 求最少步数如果我们要求解步数的话,我们首先是用逆序数进行判定是否有解，有解才进行搜索 使用曼哈顿距离递减 和 IDA*(迭代层数达到120层就放弃) 的方式曼哈顿是初始排列到目标排列每个数字abs(x1-x2)+abs(y1+y2)的和值 给个板子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/*先用结论判断是否有解呀！不然没解跑这个会死循环，燃烧你的CPU的话我不背锅哦 */#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;//limit全部的曼哈顿距离之和int map[4][4], map2[16], limit;int flag, length;//各个数字应在位置(i,j)对照表,比如0在位置(3,3)int goal[16][2] = &#123;&#123;3,3&#125;,&#123;0,0&#125;,&#123;0,1&#125;,&#123;0,2&#125;, &#123;0,3&#125;,&#123;1,0&#125;,&#123;1,1&#125;,&#123;1,2&#125;, &#123;1,3&#125;,&#123;2,0&#125;,&#123;2,1&#125;,&#123;2,2&#125;, &#123;2,3&#125;,&#123;3,0&#125;,&#123;3,1&#125;,&#123;3,2&#125;&#125;;int nx[4][2] = &#123; &#123; -1, 0 &#125;, &#123; 0, -1 &#125;, &#123; 0, 1 &#125;, &#123; 1, 0 &#125; &#125;;//估价函数,曼哈顿距离,小于等于实际总步数int hv(int a[][4])&#123; int cost = 0; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; int w = map[i][j]; // 不算0 if (w != 0) cost += abs(i - goal[w][0]) + abs(j - goal[w][1]); &#125; &#125; return cost;&#125;/* x,y起始坐标，len是已经走过的长度,pre_move是上次走的方向 */void dfs(int x, int y, int len, int pre_move)&#123; if (flag) return; int dv = hv(map); if (len == limit) &#123; //成功 退出 if (dv == 0)&#123; flag = 1; length = len; return; &#125; else //超过预设长度 回退 return; &#125; for (int i = 0; i &lt; 4; i++) &#123; //不和上一次移动方向相反,对第二步以后而言 if (i + pre_move == 3 &amp;&amp; len &gt; 0) continue; int tx = x + nx[i][0]; int ty = y + nx[i][1]; if (tx &gt;= 0 &amp;&amp; tx &lt; 4 &amp;&amp; ty &gt;= 0 &amp;&amp; ty &lt; 4) &#123; swap(map[x][y], map[tx][ty]); int p = hv(map); if (p + len &lt;= limit &amp;&amp; flag == 0) &#123; dfs(tx, ty, len + 1, i); if (flag) return; &#125; /* 递归回来后恢复现场 */ swap(map[x][y], map[tx][ty]); &#125; &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--) &#123; int x1, y1; //map2一维 map二维 for (int i = 0; i &lt; 16; i++)&#123; scanf("%d", &amp;map2[i]); if (map2[i] == 0) &#123; x1 = i/4; y1 = i%4; map[x1][y1] = 0; &#125; else &#123; map[i/4][i%4] = map2[i]; &#125; &#125; /* 曼哈顿长度要递减的 */ limit = hv(map); flag = 0; length = 0; //要求120步之内到达,其实如果可以的话最多80多步就可以走完 while (flag == 0 &amp;&amp; length &lt;= 90)&#123; //得到的是最小步数 dfs(x1, y1, 0, 0); /* 加大初始额曼哈顿距离的限制，让递归的行走能不曼哈顿距离递减得多试探几步 */ if (flag == 0) limit++; &#125; // if (flag) // printf("%d\n", length); if(flag) cout&lt;&lt;"Yse"&lt;&lt;endl; else cout&lt;&lt;"No"&lt;&lt;endl; &#125; return 0;&#125; 后续不好意思，写完后才发现重复造轮子了，不过应该我写得应该算比较简单，可以立马用上吧]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>逆序数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[priority_queue和multiset异同以及线段树空树插入维护初见]]></title>
    <url>%2F2019%2F07%2F30%2Fpriority-queue%E5%92%8Cmultiset%E5%BC%82%E5%90%8C%E4%BB%A5%E5%8F%8A%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%A9%BA%E6%A0%91%E6%8F%92%E5%85%A5%E7%BB%B4%E6%8A%A4%E5%88%9D%E8%A7%81%2F</url>
    <content type="text"><![CDATA[priority_queue和multiset异同优先级队列只能按照排序顺序访问一个元素 - 即，可以获得最高优先级的项目，想要访问其他的元素，就必须删除顶端元素。 优先级队列还允许重复元素，因此它很像是一个multiset。 但是multiset比priority_queue的好处就在于multiset不用删除掉优先级最高的元素就可以访问其他优先级的元素，就相当于一个动态的有序数组 同为log(n)插入，但是multiset却能访问更多，真香 虽然priority_queue可以通过删除再恢复的方式达到访问其他优先级的元素，但是实现很不优雅，而且让一个log(n)的操作蹩脚地魔改成了接近O(n^2)的操作，并且容易卡时间 比如HDU-6609这一题暴力priority_queue虽然我很不愿意把我很喜欢的一种STL加上暴力的前缀，但是确实是很朴素自然，大道至简但是这里有点过分使用了…所以下面是TLE的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=1000000007;const int inf = 0x3f3f3f3f;const int M = 2e5 + 7 ;int Q, n, m, w[M];ll sum;int k;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pre;priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; q;int main()&#123; ios::sync_with_stdio(false);cin.tie(0); cin&gt;&gt;Q; while(Q--)&#123; /* init */ sum = 0;k=0; while(!q.empty()) q.pop(); while(!pre.empty()) pre.pop(); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i]; for(int i=1;i&lt;=n;i++)&#123; /* 根据题意不能弹出本次加入的 */ /* 根据题意应该不会在空的时候满足条件 */ // int pre=inf; /*每弹出一个k++,所以每回收pre一个k--*/ // while(!pre.empty()) pre.pop(); while(!q.empty()&amp;&amp;sum+w[i]&gt;m)&#123; k++; pre.push(q.top()); sum-=q.top(); q.pop(); &#125; /*输出*/ cout&lt;&lt;k&lt;&lt;" "; if(i==n)&#123; cout&lt;&lt;endl; break; &#125; /*回溯*/ ll tmp = 0; /* = 再想想*/ bool f=0; while(!pre.empty()&amp;&amp;tmp+pre.top()&lt;=w[i])&#123; f=1; tmp += pre.top(); q.push(pre.top()); k--; pre.pop(); &#125; /*能加入一个就无需加本身了,要加回之前的sum值 本身未加入的话就相当于弹出了一个k++*/ /*不对,加回本身,让其在后面的循环中进入pre*/ // if(f) sum += tmp,k++; if(f) sum += tmp; q.push(w[i]); sum += w[i]; &#125; &#125; return 0;&#125; multiset12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;const int maxn = 2e5 + 10;int a[maxn];multiset&lt;int&gt; ss;int main()&#123; int t; scanf("%d", &amp;t); while (t--) &#123; ss.clear(); long long int n, m; scanf("%lld%lld", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;a[i]); &#125; long long int sum = 0; int tem = 0; for (int i = 0; i &lt; n; i++) &#123; long long int suma = sum; int jishu = 0; if (suma + a[i] &gt; m) &#123; auto j = ss.end(); /* 这里用计数jishu记下软删除的数量，由于priority_queue 只能访问第一个值，所以不支持软硬删除操作...所以会用真实删除再 恢复的操作会TLE...因为这样会从O(nlog(n))魔化到O(n^2) */ /* 由题意a[i]&lt;=m，满足下面条件时一定不会出现ss为空 */ while (suma + a[i] &gt; m) &#123; j--; suma -= *j; jishu++; &#125; &#125; /* 第一个铁定是0的 */ printf("%d ", jishu + tem); ss.insert(a[i]); auto j = ss.end(); sum += a[i]; /* 用tem记录下硬删除的数量 */ while (sum &gt; m) &#123; j--; sum -= *j; /* 这里由于find返回的是指针，所以就会只删除一个值 而不是删除数值那样把所有数值都删除掉 */ ss.erase(ss.find(*j)); tem++; &#125; &#125; printf("\n"); &#125;&#125; 线段树树空树插入维护初见这个线段树标程真是魔鬼一般地折磨了我整整7个小时…菜鸡刚学线段树，还没有过插入空树的经历，然后这个std是插入空树…我好菜啊 所以放一发带思考注释的手抄代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;using namespace std;#define mod 1e9+7#define ll long longconst int M = 2e5+7;ll int a[M],number[M&lt;&lt;2],bz[M&lt;&lt;2];int number2[M&lt;&lt;2],bz2[M&lt;&lt;2],to[M];struct node&#123; int id; ll b;&#125; no[M];bool cmp(node a,node b)&#123; return a.b==b.b ? a.id&lt;b.id : a.b&lt;b.b;&#125;/* 自己重写std感觉上推数值好像还是不对，如果不理解的话，下次就算有板子也不能秒掉！所以还是要先理解一下 ，多多重现算法*//* 先写着，等下写完全部看看有没有新的认识 *//* 2019年7月30日16:59:35 还是不懂，维护区间之和难道不是要左右相加吗？2019年7月30日20:34:57 突然灵光一闪！因为你一开始是一棵空树，然后你一个个插入，如果使用的是max，就相当于(to[i],n+1)这个区间以及每个子区间都是你的插入值的和. 因为都是直接到了叶子节点去加和如果使用加法，那么就出错了，就有很多重复计算，所以说[1-&gt;n]区间就是最大的前缀和所以询问的时候就可以直接加和*/void PushUp(int rt)&#123; number[rt] = max(number[rt&lt;&lt;1],number[rt&lt;&lt;1|1]);&#125;/* 其实这里是多组测试的初始化0值 *//* 但是number2不PushUp清零吗？这里好像有问题，但为什么std能AC惊呆的发现竟然放在了pushdown下推标记的时候清零了...感觉线段树的写法真多*/void build(int l,int r,int rt)&#123; bz[rt]=bz2[rt]=number[rt]=0; if(l==r)&#123;number2[rt]=0;return;&#125; int mid = (l+r)&gt;&gt;1; build(l,mid,rt&lt;&lt;1); build(mid+1,r,rt&lt;&lt;1|1); PushUp(rt);&#125;void pushdown(int l,int r,int rt)&#123; if(bz[rt])&#123; bz[rt&lt;&lt;1] += bz[rt]; bz[rt&lt;&lt;1|1] += bz[rt]; number[rt&lt;&lt;1] += bz[rt]; number[rt&lt;&lt;1|1] += bz[rt]; bz[rt] = 0; &#125; if(bz2[rt])&#123; bz2[rt&lt;&lt;1] += bz2[rt]; bz2[rt&lt;&lt;1|1] += bz2[rt]; number2[rt&lt;&lt;1] += bz2[rt]; number2[rt&lt;&lt;1|1] += bz2[rt]; bz2[rt] = 0; &#125;&#125;void change(ll o,int L,int R,int l,int r,int rt)&#123; if(L&gt;R) return; if(l==r)&#123; number[rt]+=o; /* 之前初始化成了0，所以这里可以这样...这个标程写得真随意... */ number2[rt]+=1; return ; &#125; /* 此节点(区段l,r)全被包含在内 */ if(L&lt;=l &amp;&amp; r&lt;=R)&#123; /* 先自己赋值，下推标记就直接给儿子赋值 */ number[rt]+=o; bz[rt]+=o; bz2[rt] += 1; return ; &#125; int mid = (l+r)&gt;&gt;1; /* pushdown和PushUp都只管修改相邻层 */ pushdown(l,r,rt); /* 区段l,r包含L,R,或者有交叠,则访问子节点(子区段) */ if(L&lt;=mid) change(o,L,R,l,mid,rt&lt;&lt;1); if(R&gt;mid) change(o,L,R,mid+1,r,rt&lt;&lt;1|1); PushUp(rt);&#125;ll query(ll k,int l,int r,int rt)&#123; if(l==r) return number2[rt]; int mid = (l+r)&gt;&gt;1; pushdown(l,r,rt); int ans; if(k &lt; number[rt&lt;&lt;1]) ans = query(k,l,mid,rt&lt;&lt;1); else ans = query(k,mid+1,r,rt&lt;&lt;1|1); PushUp(rt); return ans;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); build(1,n+1,1); for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;a[i]); no[i].b = a[i]; no[i].id = i; &#125; sort(no+1,no+n+1,cmp); /* 把与n+1有关的节点都打上number=1e9,number2=1的标记... 只给n+1对应的叶子节点处打上了标记！其他地方没有进去过！ 就相当于在那里插入了一点*/ change(1e9,n+1,n+1,1,n+1,1); for(int i=1;i&lt;=n;i++) to[no[i].id] = i; for(int i=1;i&lt;=n;i++)&#123; /*一个个插入,第一个时还没插入，是空树，所以肯定返回0*/ ll k = query(m-a[i],1,n+1,1); printf("%lld ",i-k); /*按照队友的说法,那这里就是插入第一个*/ /* 给排名在to[i]到n+1的地方都所有区段打上区间数值和number 和此区间个数和number2 */ change(a[i],to[i],n+1,1,n+1,1); &#125; puts(""); &#125; return 0;&#125; 借鉴: C++&amp;STL&amp;multiset&amp;杭电多校第三场 1007 find the answer]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>线段树</tag>
        <tag>STL</tag>
        <tag>优先队列</tag>
        <tag>multiset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AcWing-245.你能回答这些问题吗]]></title>
    <url>%2F2019%2F07%2F30%2FAcWing-245-%E4%BD%A0%E8%83%BD%E5%9B%9E%E7%AD%94%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%E5%90%97%2F</url>
    <content type="text"><![CDATA[背景2019牛客杭电多校都把线段树当做最最最基础的知识点，杭电3甚至把线段树当做签到，所以线段树要多练啊 题目你能回答这些问题吗 算法线段树入门题 O(Mlog(N))一步步思考线段树过程关键点不能简单的对比对比左右子区间的dat和值(区间最大和值)来更新本节点的区间最大和值，还要对比右子树的rmax+左子树的lmax的和值 c.dat=max(max(a.dat,b.dat),a.rmax+b.lmax); 附图可以参考，关键看代码注释 手写AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int SIZE = 5e5+7;struct SegmentTree&#123; int l,r; int lmax,rmax,sum; int dat;&#125; t[SIZE&lt;&lt;2];int a[SIZE],N,M;void pushup(int p)&#123; t[p].sum = t[p*2].sum + t[p*2+1].sum; t[p].lmax = max(t[p*2].lmax,t[p*2].sum+t[p*2+1].lmax); t[p].rmax = max(t[p*2+1].rmax,t[p*2+1].sum+t[p*2].rmax); t[p].dat = max(t[p*2].dat,max(t[p*2+1].dat,t[p*2].rmax+t[p*2+1].lmax));&#125;void build(int p,int l,int r)&#123; t[p].l=l,t[p].r=r; if(l==r)&#123; t[p].sum=t[p].lmax=t[p].rmax=t[p].dat=a[l]; return ; &#125; int mid = (l+r)/2; build(p*2,l,mid); build(p*2+1,mid+1,r); pushup(p);&#125;void change(int p,int x,int v)&#123; if(t[p].l==t[p].r)&#123;t[p].dat=t[p].sum=t[p].lmax=t[p].rmax=v;return ;&#125; int mid = (t[p].l+t[p].r)/2; if(x&lt;=mid) change(p&lt;&lt;1,x,v); else change(p&lt;&lt;1|1,x,v); pushup(p);&#125;// int ask(int p,int l,int r)&#123;// if(l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) return t[p].dat;// int mid = (t[p].l + t[p].r)/2;// int val = -(1&lt;&lt;30);// if(l&lt;=mid) val = max(val,ask(p&lt;&lt;1,l,r));// if(r&gt;mid) val = max(val,ask(p&lt;&lt;1|1,l,r));// return val;// &#125;/* 此处感谢队友帮忙debug */SegmentTree ask(int p,int l,int r)&#123; if (l&lt;=t[p].l &amp;&amp; r&gt;=t[p].r) return t[p]; int mid=(t[p].l+t[p].r)&gt;&gt;1; int val=-(1&lt;&lt;30); SegmentTree a,b,c; a.dat=a.sum=a.lmax=a.rmax=val; b.dat=b.sum=b.lmax=b.rmax=val; c.dat=c.lmax=c.rmax=val; c.sum=0; /* 要么都在最左边，要么都在最右边，要么跨越了左右，跨越了左右就要判断 c.dat=max(max(a.dat,b.dat),a.rmax+b.lmax); 这个点没想到会卡住 --&gt; 我就是从前面的注释的ask函数出错来的*/ if (l&lt;=mid&amp;&amp;r&lt;=mid)&#123; a=ask(p&lt;&lt;1,l,r); c.sum+=a.sum; &#125; /* 还要注意左区间r&lt;=mid,右区间l&gt;mid */ // else if (l&gt;=mid&amp;&amp;r&gt;=mid)&#123; else if (l&gt;mid&amp;&amp;r&gt;mid)&#123; b=ask(p*2+1,l,r); c.sum+=b.sum; &#125; else&#123; a=ask(p&lt;&lt;1,l,r); b=ask(p*2+1,l,r); c.sum+=a.sum+b.sum; &#125; c.dat=max(c.dat,max(max(a.dat,b.dat),a.rmax+b.lmax)); c.lmax=max(c.lmax,max(a.lmax,a.sum+b.lmax)); c.rmax=max(c.rmax,max(b.rmax,b.sum+a.rmax)); return c;&#125;int main()&#123; ios::sync_with_stdio(false);cin.tie(0); cin&gt;&gt;N&gt;&gt;M; for(int i=1;i&lt;=N;i++) cin&gt;&gt;a[i]; build(1,1,N); int i,x,y; while(M--)&#123; cin&gt;&gt;i&gt;&gt;x&gt;&gt;y; if(i==1)&#123; if(x&gt;y) swap(x,y); cout &lt;&lt; ask(1, x, y).dat &lt;&lt; endl; &#125; else change(1,x,y); // for(int i=1;i&lt;=9;i++)&#123; // cout&lt;&lt;"dat: "&lt;&lt;t[i].dat&lt;&lt;" sum: "&lt;&lt;t[i].sum&lt;&lt;" lmax: "&lt;&lt;t[i].lmax&lt;&lt;" rmax: "&lt;&lt;t[i].rmax&lt;&lt;endl; // &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[银联挑战赛初赛第二场B题]]></title>
    <url>%2F2019%2F07%2F28%2F%E9%93%B6%E8%81%94%E6%8C%91%E6%88%98%E8%B5%9B%E5%88%9D%E8%B5%9B%E7%AC%AC%E4%BA%8C%E5%9C%BAB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目题目链接码队弟弟的求和问题 题面 题解思路 数论分块知识点图片截取了大佬的blog 手写AC代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll mod = 1e9+7;ll n,m;ll inv6;ll qpow(ll a,ll b)&#123; ll res = 1; while(b)&#123; if(b&amp;1) res = res*a%mod; a = (a*a)%mod; b&gt;&gt;=1; &#125; return res;&#125;ll f(ll n)&#123; return n*(n+1)%mod*(2*n+1)%mod*inv6%mod;&#125;ll solve(ll n)&#123; ll ans = (n*(n+1)/2%mod)*n; // ll ans = n*n%mod*(n+1)/2%mod; for(int i=1,j;i&lt;=n;i=j+1)&#123; /*i=j+1,以及n/i要加括号*/ j = n/(n/i); /*其实j不会大于n*/ if(j&gt;n) j=n; ans = (ans - (f(j)-f(i-1))*(n/i)%mod + mod)%mod; /*只要保证每次相减时两个都是正数 然后结果再来一次保证正数操作就不会出错*/ &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); inv6 = qpow(6,mod-2); cin&gt;&gt;n&gt;&gt;m; ll ans = solve(n)*solve(m)%mod; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 菜鸡我踩坑坑我35mins123// bug是因为除号必须在mod前！ll ans = (n*(n+1)/2%mod)*n;// ll ans = n*n%mod*(n+1)/2%mod;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第14周-14-521]]></title>
    <url>%2F2019%2F07%2F27%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC14%E5%91%A8-14-521%2F</url>
    <content type="text"><![CDATA[Algorithmgogogo ReviewDo You Really Need Another Computer Monitor? 是啊，对于单一的工作，没有很多要素的工作一个屏幕就够了 但是对于需要很多要素的工作，比如一边看编程视频教学，一边跟着写这种要素很多的工作，有两个屏幕真的能提高自己的效率 Tips线段树从零开始 线段树详解 Share2019牛客多校3 I]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客多校3 I]]></title>
    <url>%2F2019%2F07%2F26%2F2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A13-I%2F</url>
    <content type="text"><![CDATA[题目题目链接Median 题意3个数产生一个中位数，现在给你一串中位数，请还原出一个合理的原串 InputT组,每组给n表示原串的长度,然后是给你中位数串b[1]-&gt;b[n-1] 范围: n的和不超过10^6,每个b不超过10^9 Output有合理的串则输出原串,否则输出-1 题解结论若存在合理的解,那么解的每个位置的最终值一定是它能影响到的3个中位数之一 证明 Dp解法 自己动手写AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;const int M = 1e5+7;bool f[M][3][3];int pre[M][3][3];int v[M][3];int b[M],a[M];int T,n;int mid(int x,int y,int z)&#123; static int tmp[3]; tmp[0]=x,tmp[1]=y,tmp[2]=z; sort(tmp,tmp+3); return tmp[1];&#125;/*回溯构造*/void back(int i,int j,int k)&#123; while(i&gt;=1) &#123; a[i] = v[i][j]; int pr = pre[i][j][k]; j = k; k = pr; i--; &#125;&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); for(int i=2;i&lt;=n-1;i++) scanf("%d",&amp;b[i]); /*init*/ b[0]=b[1]=b[2]; b[n+1]=b[n]=b[n-1]; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;3;j++) for(int k=0;k&lt;3;k++) f[i][j][k]=false; /*注意:我给的手写题解中a[3]对应b[1],b[2],b[3] 我这里为了实现方便是用的对应b[2],b[3],b[4]*/ for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;3;j++)&#123; v[i][j]=b[i-1+j]; &#125; sort(v[i],v[i]+3); &#125; /*边界条件: 前i-2个中位数(此时i=2为0个中位数)是满足条件的 最终f[N][i][j]的时候的是N-2个中位数是否满足条件*/ for(int i=0;i&lt;3;i++) for(int j=0;j&lt;3;j++) f[2][i][j]=true; /*solve*/ bool findans = false; for(int i=3;i&lt;=n;i++)&#123; for(int j=0;j&lt;3;j++)&#123; for(int k=0;k&lt;3;k++)&#123; for(int l=0;l&lt;3;l++)&#123; if(!f[i-1][k][l]) continue; /*判断前面的位置和本位置使用与他们位置相关的 3个中位数的排列中哪些排列能够满足要求 v[i][j]对应的是b[i-1],b[i],b[i+1]中的一个*/ if(mid(v[i-2][l],v[i-1][k],v[i][j])!=b[i-1]) continue; f[i][j][k]=true; /*记录下前面使用的是l大的*/ pre[i][j][k]=l; /*break写完再探索-std中用了break 我认为应该遍历全部情况,所以去掉了break 然后两份代码都AC了,所以可能解唯一或者是按照std 生成的数据吧*/ // break; &#125; if(i==n &amp;&amp; f[i][j][k])&#123; findans = true; back(i,j,k); goto END; &#125; &#125; &#125; &#125; END: if(!findans) printf("%d\n",-1); else&#123; for(int i=2;i&lt;n;i++) &#123; assert(mid(a[i-1],a[i],a[i+1]) == b[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; printf("%d%c",a[i]," \n"[i==n]); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>多校</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第13周-13-521]]></title>
    <url>%2F2019%2F07%2F22%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC13%E5%91%A8-13-521%2F</url>
    <content type="text"><![CDATA[Algorithm牛客多校中一题 ReviewRule of Three: Bad Ideas, Arguments and Brainstorming When you do a brainstorm to solve a problem or generate an idea, you’ll always experience two sides. First you flare to generate as many ideas as possible. Then you focus to decide on the one path that you’re actually going to execute on. 确实,做决定的时候要好好选择,别人批评,自己选择,选择好然后专注做下去,自己负责 Tips我再也不装扮博客了 那我也不装了 Share2019牛客多校第一场补题笔记 2019牛客多校第二场补题笔记]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客多校第二场补题笔记]]></title>
    <url>%2F2019%2F07%2F21%2F2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%8C%E5%9C%BA%E8%A1%A5%E9%A2%98%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[题目链接2019牛客多校第二场 background出题人:sd0061赵轩昂，北京航空航天大学，WorldFinal 2015/2016 Eddy好像就是出题人的电脑用户名 出题评价题目对我这个菜鸡来说较难，题意复杂 讲题评价逻辑清晰，对每一题的讲解由浅入深，对时间复杂度不断优化精细讲解，层层入深，获得大家的一致好评(只是目前我这个菜鸡对于很多浅的地方还没学好甚至还没学过，所以补补补o(╥﹏╥)o) A题意 Eddy大佬走路 先让0-&gt;N-1都有标记 -&gt; 第i天走一圈需要Ni步(每天脚长不一样还行),可以前进和后退,然后收集完所有标记(每个地方都有标记,即0-&gt;N-1处都是标记)就立马感到无聊了就立马回去吃饭睡觉打豆豆(你的记录值中Eddy大佬走到Mi就算是收集完了所有的标记) 你每天观摩大佬走路(giao) 你复查数据的时候，你不确定到底数据是不是对的，然后你想知道这些天的数据正确的可能性(所以很自然的知道后面为什么要你输出前缀积,原来写笔记确实可以加深理解奥) input T组测试(T天的观测) 然后每组测试都是给你Ni和Mi(每天Eddy的走路信息) Output 输出前i天的数据都正确的可能性(也就是每天可能性之积) 思路 Corner Case: 当N=1的时候，也就是1步就可以走完一圈，无论Eddy大佬前进还是后退，肯定是1步走完(这样肯定收集完了所有的标记),所以可能性为1 当M=0的时候，你记录的是Eddy大佬在0处就收集完了所有的标记,这是不可能，因为Eddy大佬一开始从0出发，所以一开始就已经拥有0号标记了,而一旦Eddy收集完所有的标记之后必定会立马回家,所以离开的地方的那个标记一定是最后收集到的,而且是第一次收集到的那个标记，所以你记录值为0显然是错的,所以可能性是0 一般情况(N非1,M非0) 有了上面M=0的理解，这里就好理解了，因为Eddy大佬一开始从0出发,然后Eddy大佬可以前进也可以后退，所以Eddy大佬最后一个到达的点可以是非0的其他任意一个点，所以最后到达每个点的可能性都是等概的，也就是1/(N-1) 对了，输出的是前i的概率积 AC代码(自己再手写一遍收获更多)1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int mod = 1e9+7;int T,n,m;ll ans;ll mul(ll a,ll b)&#123; a *= b; return a&gt;=mod?a%mod:a;&#125;ll qpow(ll a,ll b)&#123; ll ret = 1; while(b)&#123; if(b&amp;1) ret = mul(a,ret); /* b&gt;&gt;1,那么a就要变成a*a */ b&gt;&gt;=1; a = mul(a,a); &#125; return ret;&#125;ll inv(ll a)&#123; return qpow(a,mod-2); &#125;ll solve(ll n,ll m)&#123; if(n==1) return 1; if(m==0) return 0; return inv(n-1);&#125;int main()&#123; ios::sync_with_stdio(false); /*init*/ ans = 1; cin&gt;&gt;T; while(T--)&#123; cin&gt;&gt;n&gt;&gt;m; /*solve*/ ans = mul(ans,solve(n,m)); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; Bemmmm,看懂了一点点题解,但是对于题解中的BM完全不熟悉,所以先留坑 C,D自己太菜了,留坑Eemmmm,看懂了一点点题解,但是还是不太熟悉基础的算法,我先去补基础的算法,留坑 F题意给定2N个人,(N &lt;= 14),两两间有边权,把这2N个人分为2组,每组N个,求两组间的边权和最大 题解朴素法(也称暴力法),在新加入一个人的时候，比如说加入了A组，那么直接将它与B组间已经有的所有人的边权加一遍 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int M = 50;int d[M][M];int a[M],b[M];int cnt1,cnt2;ll ans;int N;void dfs(int cur,ll val)&#123; /*当达到2*N+1的时候,正好已经插入了2*N个人了,所以开始比较*/ if(cur&gt;2*N)&#123; ans = max(ans,val);return ;&#125; if(cnt1&lt;N)&#123; a[cnt1++]=cur; ll tmp = 0; /*每次加入了cnt1之后,就要把左边队伍新加人与对面队伍当下所有人产生的竞争值加入左边队伍*/ for(int i=0;i&lt;cnt2;i++) tmp+=d[cur][b[i]]; dfs(cur+1,val+tmp); /*上面的遍历return之后要恢复现场,即之前产生的影响要消除掉,避免对后面的操作有影响*/ cnt1--; &#125; if(cnt2&lt;N)&#123; b[cnt2++]=cur; ll tmp = 0; /*每次加入了cnt2之后,就要把右边队伍新加人与对面队伍当下所有人产生的竞争值加入右边队伍*/ for(int i=0;i&lt;cnt1;i++) tmp+=d[a[i]][cur]; dfs(cur+1,val+tmp); cnt2--; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;N; for(int i=1;i&lt;=2*N;i++) for(int j=1;j&lt;=2*N;j++) cin&gt;&gt;d[i][j]; ans = 0; /*像一颗树一样遍历下去,然后到达叶子的时候进行比较出最大值再返回*/ dfs(1,0); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; G计算几何,留坑H题意给定一个N*M的01矩阵(1&lt;=N,M&lt;=1000),求第二大全是1的矩阵面积 题解 枚举每一行，以当前行为底，记录每一列往上不间断最多延长多远，那么这样之后就变成了一维的柱状图求最大/次大/k大矩形面积，可用单调栈求解 由于要记录第二大,之前求最大的做法(poj2559)是直接用max维护ans,width合并的做法在这里就要改成把所有解先丢进一个vector(之后排序复杂度 ans个数 * log(ans个数))(或者维护一个k大的小值优先的priority_queue,复杂度算上维护也是ans个数 * log(ans个数)) 但是这里必须把(width-1)*ddz[top]也放入状态级,因为求第二大,所以只要把次大状态加入(详细原因看下面说的坑点) 所以推荐使用把全状态扔进vector，这样还可以求第k大，虽然慢点 坑点图中最后一行样例的dp的单调栈这里是小于也没有用，因为1会占据掉3的宽度，而且仍为高度1，之后就在0到来的时候累加宽度 (宽度直接从4加到了6，跳过了5,因为1之前会占据掉3的宽度)，然后就会无视掉矩阵面积是5的情况！！！ 所以用width会导致状态数减少，这里求第二大可以把width-1的状态也加入，从而达到正确答案并减少了一定状态数 不过还是推荐使用全状态，就是用cnt++，把所有状态放入vector，这样就可以求出第k大 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/*5 1001001011000010110110100001111010001100101111110010*/#include&lt;bits/stdc++.h&gt;using namespace std;const int M = 1e3+5;int dp[M][M];int ddz[M],w[M];vector&lt;int&gt; ans;int n,m;void solve(int *f)&#123; int top = 0; ddz[top] = -1; f[m+1] = -1; for(int i=1;i&lt;=m+1;i++)&#123; /*等于时是否弹出这需要自己注意一下,就是严不严格单调的选择*/ if(ddz[top]&lt;f[i]) ddz[++top]=f[i],w[top]=1; else&#123; int width = 0; /*此处注意要先加宽度*/ while(top&amp;&amp;f[i]&lt;ddz[top])&#123; width+=w[top],ans.push_back(ddz[top]*width),ans.push_back(ddz[top]*(width-1));top--;&#125; /*我的做法是 : 等于是加入,不严格单调*/ ddz[++top]=f[i],w[top]=width+1; &#125; /*推荐下面的方法*/ // if(ddz[top] &lt;= f[i]) ddz[++top] = f[i]; // else &#123; // int cnt = 0; // /*然后这里可以写宽度进行优化*/ // while(top &amp;&amp; ddz[top] &gt; f[i]) &#123; // cnt++; // ans.push_back(ddz[top] * cnt); // top--; // &#125; // while(cnt--) ddz[++top] = f[i]; // ddz[++top] = f[i]; // &#125; &#125;&#125;int main()&#123; char c[M]; while(~scanf("%d%d",&amp;n,&amp;m)) &#123; /*init*/ ans.clear(); for(int i=1;i&lt;=n;i++)&#123; /*对于每一列的每一行进行连续高度扫描*/ scanf("%s",c); /*此行非0,则可以接上上面连续来的高度(可能为0)*/ for(int j=1;j&lt;=m;j++) dp[i][j] = c[j-1] == '0'? 0 : dp[i-1][j]+1; &#125; // for(int i = 1;i&lt;=n;i++) &#123;for(int j=1;j&lt;=m;j++) cout&lt;&lt;dp[i][j]; cout&lt;&lt;endl;&#125; cout&lt;&lt;endl; /*solve*/ /*对每一行进行直方图扫描求解*/ for(int i=1;i&lt;=n;i++) solve(dp[i]); sort(ans.begin(),ans.end()); /*考虑特例*/ int sz = ans.size(); if(sz&lt;=1) printf("0\n"); printf("%d\n", ans[sz-2]); &#125; return 0;&#125; I听Eddy大佬说有7种dp,太难留坑J也太难留坑]]></content>
      <categories>
        <category>算法</category>
        <category>多校</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客多校第一场补题笔记]]></title>
    <url>%2F2019%2F07%2F19%2F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA%E8%A1%A5%E9%A2%98%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[题目链接2019牛客多校第一场 A题题解知道了单调栈，那么第一题就很好解决了，就是两个串到每个位置都比较一下前面的最小值的下标是否相等(用单调栈来实现—后面讲)，如果相等则继续，如果都没有找到就是都是自己最小，也用单调栈处理成为相等，如果遇到不相等，那么i-1就是题目所要求出来的k的值 补充 单调栈单调栈的一大优势就是线性的时间复杂度，所有的元素只会进栈一次，而且一旦出栈后就不会再进来了。 单调递增栈可以找到左起第一个比当前数字小的元素。比如数组 [2 1 4 6 5]，刚开始2入栈，数字1入栈的时候，发现栈顶元素2比较大，将2移出栈，此时1入栈。那么2和1都没左起比自身小的数字。然后数字4入栈的时候，栈顶元素1小于4，于是1就是4左起第一个小的数字。此时栈里有1和4，然后数字6入栈的时候，栈顶元素4小于6，于是4就是6左起第一个小的数字。此时栈里有1，4，6，然后数字5入栈的时候，栈顶元素6大于5，将6移除，此时新的栈顶元素4小于5，那么4就是5左起的第一个小的数字，最终栈内数字为 1，4，5。 1234567891011/* L是输出端，然后s是辅助数组,c是源数组 */void solve(int* c, int* L) &#123; int top = 0; s[0] = node&#123;0, 0&#125;; for(int i = 1; i &lt;= n; i++) &#123; /*找到向左走第一个比它小的数 */ while(top &amp;&amp; s[top].val &gt;= c[i]) top--; L[i] = s[top].id; s[++top] = node&#123;i, c[i]&#125;; &#125;&#125; 参考链接:https://www.cnblogs.com/grandyang/p/8887985.html AC代码代码是队友写的,orz1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int inf = 0x3f3f3f3f;const int maxn = 100000 + 5;struct node &#123; int id; int val; &#125;;int a[maxn], b[maxn];int l1[maxn], l2[maxn];node s[maxn];int n;/* L是输出端，然后s是辅助数组,c是源数组 */void solve(int* c, int* L) &#123; int top = 0; s[0] = node&#123;0, 0&#125;; for(int i = 1; i &lt;= n; i++) &#123; /*找到向左走第一个比它小的数 */ while(top &amp;&amp; s[top].val &gt;= c[i]) top--; L[i] = s[top].id; s[++top] = node&#123;i, c[i]&#125;; &#125;&#125;int main() &#123; while(~scanf("%d", &amp;n)) &#123; for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;b[i]); solve(a, l1); solve(b, l2); int ans = n; for(int i = 1; i &lt;= n; i++) &#123; if(l1[i] != l2[i]) &#123; ans = i-1; // ans = n-1; break; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125; B题看到大佬的分析 C题，D题能力有限，战略计划原因没有补这两题 C题解推荐C题可以看大佬的题解 E题1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;#define MAXN 2000#define MOD 1000000007int n,m;int dp[MAXN+5][MAXN+5];int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; for(int i=0;i&lt;=n+m;i++) for(int j=0;j&lt;=n+m;j++) dp[i][j]=0; dp[0][0]=1; for(int i=0;i&lt;=n+m;i++) for(int j=0;j&lt;=n+m;j++)&#123; if(i+1&lt;=j+n&amp;&amp;j&lt;=i+m) dp[i+1][j]=(dp[i+1][j]+dp[i][j])%MOD; if(i&lt;=j+n&amp;&amp;j+1&lt;=i+m) dp[i][j+1]=(dp[i][j+1]+dp[i][j])%MOD; &#125; printf("%d\n",dp[n+m][n+m]); &#125;&#125; F图片以及思路转载+少量整理+感谢借鉴两位大佬的思路和博文进行整理的，感谢Izayoi_wWAautomaton 题目要求36E，而E = (22/36) S，所以ans = 22 * S 关于三角形的面积，已知三个顶点坐标，我们可以用叉积来求，如ΔABC，S = (1/2) * ( 向量(AB) ✖ 向量(AC) )。 这里要注意，叉积有正有负，最终的答案为11倍叉积的绝对值。 AC代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int inf = 0x3f3f3f3f;const int maxn = 100000 + 5;int main() &#123; ll x1, y1, x2, y2, x3, y3; while(cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3) &#123; ll res = 11*((x1-x2)*(y3-y2)-(y1-y2)*(x3-x2)); if(res &lt; 0) res = -res; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; G,H,I因己太菜先留坑J题解解法一: 直接交叉相乘 解法二: 直接看出题人叉姐的解法 AC代码123456789101112131415#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef __int128 ll;int main() &#123; long long x, a, y, b; while (scanf("%lld %lld %lld %lld", &amp;x, &amp;a, &amp;y, &amp;b) != EOF) &#123; ll p = x; p *= b; ll q = y; q *= a; if (p &gt; q) printf("&gt;\n"); else if (p == q) printf("=\n"); else printf("&lt;\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>多校</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[真的有必要把文章发布到多个平台吗？]]></title>
    <url>%2F2019%2F07%2F16%2F%E7%9C%9F%E7%9A%84%E6%9C%89%E5%BF%85%E8%A6%81%E6%8A%8A%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E5%88%B0%E5%A4%9A%E4%B8%AA%E5%B9%B3%E5%8F%B0%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[如题真的需要把自己的文章发布到多个网站平台吗？比如WordPress，Hexo，CSDN，知乎，简书，博客园，sf，开源中国等等… 说实话，我也不知道具体答案，因为答案总是和个人情况有关的 源起我之前看李自然说的视频，他说自媒体的运营应该全平台覆盖,把公域流量变成自己的私域流量，然后我也就开始了每次写一篇文章就风风火火地把自己的文章发布到自己wordpress，自己的hexo，自己的简书，自己的CSDN，自己的知乎，而且还在自己的关于界面写上了欢迎加我微信，然后一起拉群讨论… 冲突今天，是放暑假的第5天，大家都回家了，当然还有很多巨佬在疯狂地自学，我昨天连续学了3个小时技术，然后做了8个小时的算法，感觉很开心，但是今天上午睡过头，今天下午和晚上因为增强看板娘的事情，以及处理gitee大于上传100M出现了问题导致自己今天到9点都没有刷算法题，然后此时写完一篇博文，准备写算法，然后一想到自己还有4个平台没有上传自己的博文……开始思考自己是不是要把其他的平台停止更新了 取舍 感觉自己并不想通过写个人博客来转化变现，只想自己整理一些东西，然后分享给大家，所以也就不那么想去花太多时间运维什么的了 搞这么多东西其实和我真正要做的人生五件事是完全无关的！所以以后不仅不能花太多时间在这个无关的事情上面，而且还要想见了鬼一样地避开这些事情… 所以以后就用Hexo做笔记的整理与环境搭建的记录，然后值得分享的技术文档就发布到CSDN上面去，因为CSDN越做越好了，而且它的SEO做得最好(怪不得广告多…槽点…不过这也是生命线,无可厚非)，符合我分享给大家的意愿，然后用coding的私人仓库和wordpress小站来做备份… 询问你们怎么取舍的呢？]]></content>
      <categories>
        <category>思索</category>
      </categories>
      <tags>
        <tag>思索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git reset 和 git reset --hard区别]]></title>
    <url>%2F2019%2F07%2F16%2Fgit-reset-%E5%92%8C-git-reset-hard-%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[git reset 和 git reset --hard区别先说知识点 有时候，进行了错误的提交，但是还没有push到远程分支，想要撤销本次提交，可以使用git reset –-soft/hard命令 缺省情况git reset缺省为git reset --soft 二者区别： git reset –-soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可 git reset -–hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容，撤销的commit中所包含的更改被冲掉 我忘了知识点踩坑沙雕认为 当下情况:最新版本的100M压缩包已经在本地删除，但是本地版本库中之前有个版本中还有，所以git push到gitee会被拒收..但是git一定要先传输完前面的版本之后再传后面的修改(所以我要帮git本地仓库手动执行git rm前面版本的文件，或者忘了文件名，通过下面3的复杂的操作，来完成此项操作) 真的不知道怎么去掉本地仓库的4commit，因为去不掉的话就会先向远程库提交超100M文件然后被拒接，所以原地重复… 然后如果git rm 忘了那个压缩包的名字了，所以直接回退版本到昨天的样子，然后再git reflog回来并展示今天的所有修改，git checkout归还所有修改，然后把今天的修改备份，之后再回到昨天的版本库，然后重新提交今天的内容，除了你个超过100M的压缩包 慢慢懂了奇怪，最后一次版本回退又没有删除本地文件，可能是因为恢复过？ 原来是git reset —hard 和 git reset —soft的区别 所以我幸幸苦苦寻找了好久的取消commit而不影响工作区就是git reset —soft 真是汗啊，因为用得少，所以学了又忘了，所以现在踩一遍坑，使得自己更深刻了，也提醒了自己 对于基础知识 还是要多重复，学习多次，不断加深记忆，或者很可能还是会踩坑 参考：https://blog.csdn.net/yangfengjueqi/article/details/61668381]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[makedown写作超方便的图片使用方式]]></title>
    <url>%2F2019%2F07%2F14%2Fmakedown%E5%86%99%E4%BD%9C%E8%B6%85%E6%96%B9%E4%BE%BF%E7%9A%84%E5%9B%BE%E7%89%87%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[序言 写makedown用图片的时候总是在上传图床的时候，以及使用图片链接的时候会感觉有一些麻烦 我以前使用的是，github图床通过手动git上传,然后自己再一个个去打开github的图片的download的页面去获取图片的分享链接—-自己也觉得很麻烦，但是我的小站目标是人在站在，人不在，站希望也还在的战略目标，所以追求的极致的稳定，而不是一时的快速，所以没有使用那些可以直接粘贴上传到免费图床的操作，因为我怕指不定哪一天这种图床没有消息地就倒闭了，那我的数据就这样没了，小站将遭到巨大的打击，所以我还是慢慢使用这种方式用了3个月，知道我听学长说用七牛云太方便了，还能加速网站加载速度，所以我今天也花了许多时间了解七牛云，发现七牛云确实有免费的10G图床和每月10G的加速流量，但是我觉得这样的加速在前期是很好的，不过有个小问题就是你不自定义域名的话到时候可能失效(自定义域名要备案，腾讯云的域名备案又要买腾讯云的服务器…),而且10G对于我的小站战略来说有点不合适，所以就抛弃了，然后无意看到了PicGo+github图床，于是了解了一下，操作了一下，发现是我要找的靓仔啊！ 使用PicGo上传图库下载PicGo在GitHub的最新发布页面下载 博主本人是windows，所以下载的.exe文件直接安装就可以了 配置起来使用官方文档找到GitHub图床配置进行必要的配置 注： 仓库名是用户名/仓库名 指定存储路径是以仓库为根目录的远程仓库存储路径(可以先在本地仓库先创建一个文件夹，然后再文件夹下创建一个readme.md(为什么？看下面的小发现)，然后git push,这样就是设置这个文件夹了) github图床好像是不支持直接自定义域名的,我试过了,如果有朋友知道的希望能告知，谢谢 我的配置 小发现本地文件夹如果没有文件的话，远程仓库对应的这个文件夹是不会生成的，所以以后最好新建文件夹都写一个readme.md 上传图片这个应该大家配置不出问题，这里都会用的 复制链接使用 VScode写makedown使用snippets我发现我的使用了hexo的fancybox3之后，有一个图集的功能，很是炫酷，但是每次图片粘贴要很复杂的输入123&lt;a href=&quot;&quot; data-fancybox=&quot;images&quot;&gt; &lt;img src=&quot;&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/a&gt; 于是我就想到了snippets 预警如果用了除hexo以外的其他平台，请谨慎使用我的snippets代码！因为data-fancybox=&quot;images&quot;这个图集功能只能用在hexo, 但是可以用于其他的snippets啊 配置snippets去官网看配置 贴一下我的配置 12345678910111213"Mypic":&#123; "prefix":[ "pic", "pic-snippets" ], "body": [ "&lt;a href=\"$&#123;1&#125;\" data-fancybox=\"images\"&gt;", "\t&lt;img src=\"$&#123;1&#125;\" width=\"50%\" height=\"50%\" /&gt;", "&lt;/a&gt;", "$0" ], "description": "Use my images fancybox3"&#125;, 开启makedown的snippets使能！其实VScode是默认关掉了makedown的snippets的使能的！但是你却找不到配置，我在网上找了好久，发现一个大神写了出来，可能是他去提交过issue吧,下面开始解决(昨天被这个问题坑了好久) 进入文件-&gt;首选项-&gt;设置-&gt;打开代码配置 进入setting，输入makedown 配置成true，have fun 插曲电脑重启？ 2019年7月14日16:41:04 写了50mins后，电脑自动关机，重启电脑，看着文档白茫茫的一片，内心一万只草泥马在奔腾…去你大爷的本地写作，就连最基本的hexo新建文章后的信息也不给我留，是个狠人！不想写VScode的snippets的写作方式了——&gt; 跑到coding的备份库一看，还有20mins的工作量被保存，还好一点点吧 努力学习，努力赚钱，换一个不会莫名其妙重启的电脑 写作一定要多多保存备份 可以在网站上写makedown，然后把snippets复制粘贴到网上的makedown上面，这样就重分利用了网站的自动及时保存的功能 发现snippets的图集功能不是所有平台的makedown通用的 所以非特殊情况应该以后不会怎么用这个操作 使用PicGo和以前使用git上传的区别上传 picgo 可以直接截图上传，支持重命名 也可以拖动上传 git 只能在全部搞好之后使用命令行一次上传 下载没区别链接 picgo 可以直接复制相册里面的，不用去网页一个个点开 还支持各种格式切换，并且支持自定义 git 只能手动点开网页一个个去找 总结 PicGo确实对自己有帮助，就是链接不用一个个点开网页了 而且上传了的图片也可以按照每次重新设置不同的路径让文件放入不同的路径 git也可以通过先pull的方式继续让本地和远程仓库保持同步 总而言之还是挺好用的]]></content>
      <categories>
        <category>write</category>
      </categories>
      <tags>
        <tag>write</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第12周-12-521]]></title>
    <url>%2F2019%2F07%2F14%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC12%E5%91%A8-12-521%2F</url>
    <content type="text"><![CDATA[Algorithm虽然刷了一些题，写了篇priority_queue入门，但还是太少了呀，下周得好好加油 ReviewHow to define you snippets in VScode? TipsPicGo官方文档 Sharemakedown写作超方便的图片使用方式]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下雪啦(#^.^#)]]></title>
    <url>%2F2019%2F07%2F11%2Ftest%2F</url>
    <content type="text"><![CDATA[下雪啦(#^.^#) The winter is here ,让我们一起超越小姐姐吧 留个纪念 因为比较烧显卡，而且对访问速度影响比较大，所以就关掉了]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[priority_queue使用坑点和题集]]></title>
    <url>%2F2019%2F07%2F09%2Fpriority-queue%E4%BD%BF%E7%94%A8%E5%9D%91%E7%82%B9%E5%92%8C%E9%A2%98%E9%9B%86%2F</url>
    <content type="text"><![CDATA[2019年7月9日23:27:19 更第一波 priority使用pair比较的坑点所以用pair的priority_queue只能使用struct的重载比较，why?! 重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。—-&gt; 所以不能使用node型的priority_queue的函数重载操作符的方法 node可以函数操作符重载 pair不支持重载运算符 priority_queue定义不支持”嵌入式”函数重载的方法，即 priority_queue]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第11周-11-521]]></title>
    <url>%2F2019%2F07%2F07%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC11%E5%91%A8-11-521%2F</url>
    <content type="text"><![CDATA[Algorithm最近难的考试都考完了，整理了一段时间，接下来开始算法刷题冲刺 ReviewVScode remote/ssh#_getting-started 最近下载了VScode Insiders 折腾了一手Remote SSH发现还是有很多坑的 ssh只能密钥连接 ssh只能连接22端口 许多文件都无法打开 许多工作区间都无法建立文件文件夹当然上面3，4也可能是我技术太菜了，对linux的shell管理不太懂，导致自己没有像有些大佬一样建立了命令行的连接,所以最近一直在学linux，等我学完，可能可以捞自己一手 TipsGit学习—&gt;如何通过Shell脚本自动定时将Gitlab备份文件复制到远程服务器?扩展efi分区 Share技术分享git备份wordpress 读书分享怎样成为精力管理的高手-听书有感]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎样成为精力管理的高手-听书有感]]></title>
    <url>%2F2019%2F07%2F07%2F%E6%80%8E%E6%A0%B7%E6%88%90%E4%B8%BA%E7%B2%BE%E5%8A%9B%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E6%89%8B-%E5%90%AC%E4%B9%A6%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[2019年7月2日22:08:39 00 你为什么需要管理精力 各种时间管理 工作法，有一定的改善，但是还是没有根本性的解决问题 时间总是不能扩张的，而时间质量可以扩张，这种就需要精力管理！ 作者发现一个很牛逼的人，就是全职工作者，然后还是学生，还是3个孩子的爸爸！！！然后他就和那个黄同学学习了精力管理！然后就各种人生开挂！！！ 所以学完了前几天的时间管理后，现在开始学习精力管理！那么我也可以成为大佬，成为一个真正的大佬01 精力管理的金字塔模型 精力好不是天分 你只要掌握了方法，你就能锻炼你的精力 金字塔如下 意义感 —&gt; 目标,使命(人为什么活着!)—&gt;&gt;创造美好的生活 注意力 —&gt; 专注,聚焦(很重要,人可控) 情绪 —&gt; 感恩,乐观,兴奋 体能—&gt; 饮食,运动,睡眠,健康 02 怎样设计最佳运动方案 运动是改善体能的最佳方式 —-&gt; 疾病则反之 人有氧运动得越多，这样人的大脑就可以获得更多氧气，这样大脑就反应很快 长期静坐，可能导致死亡 进化论: 好吃懒做的祖先更容易活下来—保留精力 找到喜欢和享受的运动，一周5天，每天30mins-1小时 —- &gt; 脚伤了，可以游泳！ —-&gt; 多多冥想运动的好处 中等强度220-年龄=200*(60-70%)=130 心率达30mins 设定明确的目标，设定具体的时间，运动量的目标 每天走到8000步 反馈！游戏之所以上瘾，是因为反馈快，所以运动一定要反馈 没时间的话，高轻度间歇训练(每天一分钟都可以!) 刷牙可以单腿站立，下蹲 站立的工作 跑步可以了解一个新的城市 放大回来记一下运动量的要求 得到的 高效学习，时间管理，现在又学精力管理，加油，一定可以竞赛，项目，成绩，健康都做好的，加油 2019年7月3日22:45:5503 吃对了，就不会累 睡眠: 昼夜节律 内生平衡节律(睡得久想醒,醒得久想睡) 下午2-3会报警，所以就困 白天多嗮太阳和晚上多睡会,多喝水 想要获得好的精力少吃多餐高碳水化合物，会发饭晕(所以主要控制血糖水平的波动) 少吃多餐 3顿-&gt; 5顿 (早中午少吃主食，多吃蔬菜，间隙可以加水果) 上午补充坚果水果 一天大致安排 早上高蛋白高纤维 上午补充坚果水果 10点-11点 中午6-7分饱,大量蔬菜，或者鸡肉鱼肉高质量蛋白质 下午3-4点 水果坚果，蓝莓草莓等 晚上可以相对多一点碳水化合物，谷物或者杂粮 总结: 少吃多餐，让血糖尽可能保持平衡 吃低糖,营养质量高的食物NQI(食堂营养占比/热量占比)&gt;=1 才好 作者建议 &gt;=2 水果蔬菜 —- 特别是深绿色的蔬菜 加工的 薯片等 + 白米白面都是 NQI&lt;1 的 蛋白质per/碳水化合物percent 约= NQI 多喝水,让身体充分水化缺水带给你疲劳的感觉 —- &gt; 夏困 判断喝水够不够 体重/32 == 55/32 = 1.7 L = 3瓶水 排尿判断—-两小时左右一次,而且尿颜色很浅 咖啡每天4杯内不会死…茶也行但是不要加糖！ 2019年7月4日23:12:1304 睡得好，能提升你的决策水平 1w个小时刻意练习 天才的平均睡眠时间，8小时16mins 和正常人差不多 睡多久合适，成年人7-9小时 如何提高睡眠质量 没事别上床—&gt;建立上床是睡觉的条件反射，醒着躺床上20mins不能入睡就要起床看书，按时起床！每天必须要同一时刻起床，不能赖床 重视白天的活动.日光下的活动更好—可以合成褪黑素(焦虑也会睡不好，就想我那天石膏21天去复查前夜3,4,5,6点都醒过) 睡前做准备:创造入睡的环境和心情(屋子黑暗+睡前别看显示屏),降低身体体温(体温下降过程),加入白噪音(风雨,动物音),让大脑进入睡眠状态(看难的书) 酒精和打鼾,酒精会绕乱深睡眠,呼吸睡眠暂停综合症,打鼾超5s,要去看医生,大脑会缺氧,损伤大脑,高血压等等 2019年7月6日00:41:28 05 击退消磨意志的疾病 坐姿要好 节律饮食 2019年7月7日16:14:03把所有的都学完了，现在直接做总结吧 重温并记住精力管理的金子塔 意义感 —&gt; 目标,使命(人为什么活着!)—&gt;&gt;创造美好的生活 注意力 —&gt; 专注,聚焦(很重要,人可控) 情绪 —&gt; 感恩,乐观,兴奋 体能—&gt; 饮食,运动,睡眠,健康 找到自己的人生意义这要自己不断去尝试，去寻找 注意力和情绪通过呼吸练习和冥想练习来做到[讲真的，我第一练习的时候，我哭了] ==分享给你== 链接：https://pan.baidu.com/s/1wsDsFvFbJNrqIoIYVo-I9Q 提取码：undp]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git备份wordpress]]></title>
    <url>%2F2019%2F07%2F07%2Fgit%E5%A4%87%E4%BB%BDwordpress%2F</url>
    <content type="text"><![CDATA[git备份wordpress登陆网站目录初始化git仓库 并且 与远程仓库对接上传首先使用ssh工具(Xshell或者putty等)登入之后进入到自己wordpress网站的根目录然后初始化仓库git init 在远程coding或gitee上面新建私有仓库上面，土豪可以在在GitHub上面建私有仓库 把自己网站所在的vps的公钥放到coding或gitee的ssh密钥管理里面添加公钥 把本地仓库文件传到远程仓库123456# 一定要把下面的ssh路径改成你的ssh路径啊，然后origin也可以改成其他名字(对应本地对远程的一种称呼)git remote add origin git@git.dev.tencent.com:username/wordpreessbackup.git# git 本地远程推送三连击git add --allgit commit -m "你的注释"git push -u origin master 我们想把数据库也备份怎么办？那就干啊，直接在网站根目录下面执行数据库备份，先来看看数据库备份通用的语句12345678# hostname直接是本机，所以我们不用写# username是我们的数据库的用户名# mypwd是我们的数据库密码# databasename就是要备份的数据名字mysqldump -hhostname -uusername -pmypwd databasename &gt; /path to backup/bakname.sql# 所以我的语句应该是如下，你们也可以看着改动，这些数据的信息可以登陆宝塔面板看，或者找到你以前建网站的时候保存的一些重要信息mysqldump -uwolfdanDB -ppassword wolfdanDB &gt; wolfdanDB2019_7_6.sql 然后就成功了，再次推送到远程即可 如果你出了一些问题可以看这里，否则可以直接看下一步：注: 其实wolfdan我是先犯了下面的错误然后才有上面一条龙正确的，所以下面的这些错误修正意见基本上是说把上面步骤完善好，233 没有生成密钥且不会生成密钥的朋友可以看我以前发的文章，虽然当时写得比较水，但还是能看图解决问题的 更新仓库发现没有访问权限则检查自己有没有做上面 生成密钥 和 添加公钥 上传文件被告知src refspec master does not match any，我们使用git status检查发现是没有git add --all — &gt; 也就是说我们要先本地commit 写bash代码，并且使用crontab定时执行备份 并定时 清理一个月前备份的sql文件(节省内存呀) 如果每次都手动执行，难免会有忘记的时候，而且就算你博闻强识，你不嫌花时间吗？我们的追求当然是全自动化！当然现在不想折腾了可以保存页面下次来继续折腾 写出backup.sh文件—&gt; 当然要把一些变量改成你的 变量值1234567891011121314151617181920212223242526272829303132333435363738#!/bin/bash#this is wherepath=/home/www/wolfdan.cn#数据库名称sqlName=wolfdanDB#用户名称userName=wolfdanDB#用户密码userPasswd=root#当前时间DATE=`date +"%Y-%m-%d"`#Log存放路径LogFile=$path/backupLog/$DATE.log#新建日志文件touch $LogFile#追加日志到日志文件echo "wolfdan.cn git auto backup to coding server, start at $(date +"%Y-%m-%d %H:%M:%S")" &gt;&gt; $LogFileecho "---------------------------------------------------------------------------" &gt;&gt; $LogFile# 原本我以为执行bash会自动把目录切换，直到crond自动检测bash的log文件，并在log文件中告知我没有 .git文件，我才知道要自己手动cdcd $pathmysqldump -u$userName -p$userPasswd $sqlName &gt; wolfdanDB$DATE.sqlgit add --allgit commit -m "`date '+%Y-%m-%d %H:%M:%S'`"git push origin masterecho -e "---Have a nice day in www.wolfdan.cn----welcome to contact me by VX:wolf_dan2--------\n"&gt;&gt; $LogFile 赋予backup.sh执行权限并且测试一下chmod 777 backup.sh sh backup.sh 我自己之前bash没写好出现的一些问题bash变量赋值不能为空 数据库名称和密码什么的不能出错使用crontab定时vim /etc/crontab 没有vim可以sudo apt-get install vim(Debian/Ubuntu用户)-sudo yum install vim(CentOS用户)下载或者暂时用 vi 代替在注释下面添加你要的任务就行1234567891011121314151617181920SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed# 我的wolfdan.cn 每周备份0 3 * * 0 root /home/www/wolfdan.cn/backup.sh# 自动删除一个月前的sql，下周git的时候会同步到云端删除0 4 * * 0 root /home/www/wolfdan.cn/auto_rm.sh 重载配置并启让配置生效1234#重新加载cron配置文件sudo /usr/sbin/service cron reload#重启cron服务sudo /usr/sbin/service cron restart crontab测试和auto_rm.sh放一起了，所以不妨继续往下看写auto_rm.sh文件编码bash文件一定要小心写cpp时的习惯性变量赋值的空格！1234567891011121314151617181920212223#!/bin/bash# 路径Dir=/home/www/wolfdan.cn#当前时间DATE=`date +"%Y-%m-%d"`#Log存放位置LogFile=$Dir/backupLog/$DATE.log#新建日志文件(其实backup的脚本已经建立了，不过建立同名的会直接输出到那里，所以没有关系)touch $LogFile#追加日志信息echo "wolfdan,cn auto_rm .sql file a monoth ago. Start at $(date +"%Y-%m-%d %H:%M:%S")" &gt;&gt; $LogFileecho "------------------------------------------------------------------------------" &gt;&gt; $LogFile# 查找备份路径下，超过30天 且文件后缀为.sql 的 sql备份文件 然后删除find $Dir -type f -mtime +30 -name '*.sql*' -exec rm &#123;&#125; \;echo -e "----Done!Welcome to www.wolfdan.cn and add my VX:wolf_dan2---have a nice day!-------\n" &gt;&gt; $LogFile 赋予权限并且测试执行chmod 777 auto_rm.sh 12345678910# 这里我们先创建1些一个月前的文件touch -t 201905011230 test1.sqltouch -t 201906011230 test2.sqltouch -t 201907011230 test3.sql# 查看目录下文件 当然也可以用 ll 详细查看带时间的文件信息ls# 然后 测试sh auto_rm.sh# 再次查看 当然也可以用 ll 详细查看带时间的文件信息ls crontab定时测试细心用户可能看到我定时文件里面以及写上了auto_rm.sh任务了，没有写上的朋友快去写上吧 先修改crontabe配置vim /etc/contab假设我们现在是11:15,那么我们把日，月，周全打成*号，然后min设置成17，hour设置成11，这样就定时在2mins后了，然后auto_rm设置比backup多1mins 1234567891011121314151617181920SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed# 我的wolfdan.cn 每周备份17 11 * * * root /home/www/wolfdan.cn/backup.sh# 自动删除一个月前的sql，下周git的时候会同步到云端删除18 11 * * root /home/www/wolfdan.cn/auto_rm.sh 当然要重载并重启服务啦啦啦1234#重新加载cron配置文件sudo /usr/sbin/service cron reload#重启cron服务sudo /usr/sbin/service cron restart 当然我们又要创建一个月前的测试文件1234# 这里我们先创建1些一个月前的文件touch -t 201905011230 test1.sqltouch -t 201906011230 test2.sqltouch -t 201907011230 test3.sql 然后在11:18的时候去ls查看是否还有test1.sql 和 test2.sql 以及输出日志 输出日志是以前的，ball ball 你们动手试试给个反馈吧…不妨把你们的结果发到评论区，谢谢你们也可以加微信拉群讨论，我会经常发一些朋友圈 wolf_dan2参考的大佬文章: https://blog.csdn.net/ouyang_peng/article/details/77334215]]></content>
      <categories>
        <category>wordpress</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脚踝韧带拉伤经历分享]]></title>
    <url>%2F2019%2F07%2F06%2F%E8%84%9A%E8%B8%9D%E9%9F%A7%E5%B8%A6%E6%8B%89%E4%BC%A4%E7%BB%8F%E5%8E%86%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[想看经验的同学直接拉到最下面第一天 上午足球踢远考试前训练摔得，我对面那兄弟踢得老远，我去捡球，一时间兴奋，跳起来踩住球,自己却没稳住脚踩在球上面落地摔，脚内侧接近80度内弯，外侧剧痛，手肘擦地出血，屁股处的骨头感觉要断了，(看着我摔的同学没一个人过来？？？良久，还是没有一个人过来？？？excuse me?)然后感觉自己还能动的时候走到了厕所 (感觉良好)，在厕所洗手..然后动一下腿都两眼全黑，差点晕倒在厕所!赶紧老实了不动了，让自己紧紧扶住墙靠着洗漱台，然后用小爱同学打电话给了室友zy，结果zy的手机在寝室 然后等了好久眼睛能模糊看点字的时候打电话给了yzh，结果yzh手机在别人包里面—- &gt; 人间悲剧 好不容易扶着墙跌跌撞撞走到了操作入口处，向一个同学qhz挥手，没有理我…向来上WC的电三同学求助，让他帮我叫一下yzh，他说先上厕所，让一个高高瘦瘦的人叫老师，他说老师在测成绩应该不会过来—-&gt; what’s your problem?你看不到我快要死掉的样子吗？ 感想以上都是我没有体现出自己的受伤情况的严重性,所以他们都视若无睹 —- &gt; 以后我一定要多多关注别人的表情细节,因为很可能别人急需帮助 然后就是叫来了yzh，然后yzh把我背到了校医院，帮我挂号(校医院收款处竟然因为最近大四学长学姐毕业退款导致自己垫了钱啥的然后不能用支付宝了，只能现金)然后也不先急救… mdzz(原来是不会死的情况下就不会先救你，而是按照交钱和挂号排队慢慢来，当然急诊的照片什么的都会提前，然后也会无需挂号)—-&gt;不过我去校医院等待治病，他还在和别人(一个以前的病人)互喷一些钱的东西—-&gt;让我对校医院产生了比较不好的印象… 后面yzh又帮我去买冰棍让我冷敷，然后买了牛奶和面包 然后又体育测试完又背我从校医院到了901，太感谢了，明显感觉他背我很累 中午资询了以前有脚踝扭伤经验的同学xjy，ta详细地和我说各种就诊操作-&gt;现在想想，必须感谢ta 下午zy不上课陪我去看医生，然后还好他带了身份证，全程用他的身份来就医的(在医院遇到的很多人的情况都比我严重,心疼他们)然后zy陪着我打石膏，细心地带我去厕所帮我询问什么的 回来后感谢xjy和bh的看望，我叫xj帮忙带饭，xj的叫bb帮带饭，bb和kcn的慰问，然后中途碰到 zy学长 的细心慰问，感觉世上还是很多爱的 自己装B不用轮椅回寝室，结果累死，然后叫zy来帮我，zy叫孙崇山来帮忙，然后孙把我背了上楼，感谢 晚上大家教我如何单腿上床，如何单腿下床 尴尬: 被yzh背着自己不好意思看前面，感觉自己好没尊严 下午坐着轮椅很尴尬 下午因为不好意思出去上厕所，憋了好久的尿的尴尬 晚上发现想上大厕，发现要单脚蹲大然后憋着的尴尬 晚上想洗澡却只能擦一擦的尴尬 晚上回去因为到时候没人给我抬轮椅而直接用拐杖回去的尴尬 晚上要没有贴止血贴，手肘满是血，然后脚上是石膏睡觉的尴尬 明天要考电磁场电磁波了，自己6章只复习了前3章的部分的的尴尬,但是晚上复习的时候又老想着这几天怎么过的尴尬 认为没有什么比活着更重要，然后又想要记下此篇生活，所以就干脆不复习了 2019年6月13日23:24:49 回去吧，大家都在准备明天的考试，所以不能最后一个走，不然可能又要麻烦别人了，所以自己回去吧 不想告诉家里人我腿受伤了的强忍，以及自己感到孤独和无助的尴尬(其实自己是很想很想要一个人来帮助我的,但是又不想打扰身边同学的生活,也不好意思让他们帮我但又想他们帮我的尴尬)(更不想让家里人知道了担心，虽然我觉得可以轻易接收家里人的爱，但我也爱他们，我不想让他们为我太担心，所以我还时是不能告诉他们) 感想:以后一定多多帮助身边的人以后一定多多观察身边的人是否需要真的帮助以后一定多多观察身边的人是否需要帮助但又不好意思，学会假装碰巧去帮助别人第二天 感谢zy早起去帮我去901门口拿轮椅回到寝室楼下接我 感谢zy把我推到考场 感谢xj给我带午饭(以后对任何身边的人都当亲人一样地给予帮助，因为不这样做的话，说不定你那天就腿瘸了，然后大家都不帮你是最恐怖的，而且你平常不对别人好的话，在你为难的时候你也不好意思向别人寻求帮助，比如你想要xj给你带饭，但你又想到前段时间你拒绝了帮xj装内存条！所以你会无比愧疚，所以将心比心原来不是这么容易学会的，而是要经历生活的磨炼才能学会的，感谢生活) 以后一定要多多关注别人的难处，帮助别人 今天第一次成功单脚蹲厕(右腿小麻) 然后zy晚上带我会寝室 今天擦澡，洗身体，洗头发，换衣服，结果一屁股坐下去，直接右膝盖关节直接抽筋，现在每次膝盖收缩性略弯都会痛，一个人在厕所里面坐立不安地换衣服，真的好难，没想到残障人士生活这么难，这么苦，我才发现四肢健全的生活是多么难能可贵 妈妈突然打电话过来了，吓死我了，我还以为导员告诉我妈我咋了呢，还好没告诉，当妈妈问我最近怎么样，让我注意个人卫生，等等的时候，我差点没忍住，差点哭出来…因为我没办法洗澡，只能搽澡😭，然后有那么一瞬间好想告诉妈妈我受伤了，我好想妈妈给我安慰，但是我不能，不能让妈妈担心，对不起，妈妈，我不能让你知道，之后也不能让你知道，否则你以后一定会总觉得我有事没有告诉你，对不起，妈妈，我爱你(忍住泪水) 第三天 感谢zy推我去实验室 2019年6月15日08:15:01发现自己过来实验没有带电脑，然后发现自己上次CV好久的数字钟的代码在电脑里面，算了，腿伤了不方便，所以直接再搞一次吧(xj本来说要回寝室所以不帮我带饭，结果还是来了901，可能东西在这边吧，不怪她) 感谢gpc主动帮我带饭 2019年6月15日15:56:42 下午拉肚子了然后回来时拐杖蹦蹦蹦声音太响，门口那几个都看着我，尤其是jmq学长(那个有188的博士生学长)然后我和他对视了一会，轻声念叨:绝了下次记得微笑回视！ 不要总想着尝试走，一周后再尝试走，遵从医嘱！ 因为我差劲的社交，导致我现在要别人带个饭都这么困难(因为大家今天考完英语6级了，都直接出去浪了，所以也不好要别人给带饭…)，有些时候，真的很无奈，很伤心，很无助…只能少吃几顿……….但其实病了不能少吃…哎，算了，忍受3周吧 [ 现在才过了22 天,都有点感受不太到当时的感觉，不行，保持原汁原味的记录 ] 不要这么没有出息，谁都会有无助的时候，在自己被自己之前的愚蠢导致一手烂牌的时候只能努力恢复，然后吸取教训，以后避免风险 —&gt; 不准哭,杀不死只会让你更加坚强 受伤之后还敢爱————&gt;做自己的真正的英雄(不要把精力浪费在这里了!花了30mins发呆了,这样毫无意义) (如果你不保持经历苦难,新的苦难出现的可能性就越来越大)所以等痊愈之后坚持健身锻炼，坚持看书，坚持写项目，坚持社交和口才锻炼 2019年6月15日18:25:33庆幸自己没有死掉，我一定要好好活着，等到痊愈之后更加要好好活着，上帝一定会让勤奋的人站在他面前！ what is dead may never die,but rises again harder and stronger.逝者不死，必将再起，其势更烈 第四天一天呆在寝室，中午晚上wdc都给我送饭，然后就是晚上wdc还帮我锁大锁，真好，这是我腿受伤以来最开心的一天 第五天 今天又是待在寝室的一天，然后10点吃了zy给我带的早餐…为啥他不带中餐呢他也很尴尬 下午饿了吃了多包辣条 然后晚上让zy给我带了一个酸菜肉堡 想到明天周二突然陷入了极度痛苦不愿 面对 “明天下雨，中午饭不怎么好让别人带，上三楼上课的尴尬境地之中”—-&gt; 算了，办法一定比苦难多，只有不可预测的一些因素才让生命更加丰富多彩 下午吃的辣条在空调的袭击下导致肚子很痛了，然后就等晚点人少再去拉屎，先洗头吧 然后又折腾了许久，不过比上次好多了，加油，别人四肢全断都在认真生活 第六天 由于室友大家没有早起，导致没有吃早餐，2019年6月18日10:44:45 饿了，难受 2019年6月18日12:42:41 今天中午xj帮我带饭，然后自己也直接带饭到了9楼，她出去吃的，很抱歉…… 所以以后除了周二和周四,都直接待在寝室…因为跑腿腿可以直接送到寝室门口 [之后因为羞愧再也没有要xj带过饭了…—-&gt; 以后如果真心帮助别人也要尽量不动声色得帮助，别让别人难堪，导致别人下次再也不敢找你帮助了 ] 多了一种视角，你是否会麻烦别人却没有给与相应的价值(比如让xj带饭，麻烦了别人)，所以还是尽量使用服务业提供的服务 我的包—&gt;5本大书-&gt;knotex电脑 感谢下午lky给我带饭，帮我带包上3楼 感谢超哥吃完饭理完发推我从C座到寝室并且帮我带包上6楼感谢啊感谢 第七天 睡了10小时，emmmm第一次把腿垫高睡，有点不适应，然后梦到自己腿好了，石膏都被自己撑坏了，梦醒之后，石膏依旧 就不该看《胡广生》的MV，导致自己哭的稀里糊涂，不成样子 刚刚想在寝室上个厕所，结果蹦蹦蹦，右脚踩入茅坑，不过还好只是轻微砸了一下关节骨，没有其他伤害，左脚还好有石膏，所以只是震了一下，还好 试了一下，左脚能够比较好的动了，只是不能承重，所以还得一段时间静养—-&gt;结果今天折腾过了头，反而造成了一定损伤。mdzz 又看了40mins脚踝如何恢复，佛了，然后认真做实验(EDA实验) 真是疯狂折腾受伤的韧带！小心后遗症！所以每次去厕所都小心点!好吧 —-&gt; 1、 伤情被自己整到恶化 2. 然后大家这段时间都很忙很累，心情很烦，所以还是最好自力更生吧，天将降大任于斯人也！ 晚上我没有问清楚就让zy和wdc带饭，结果可能他们因为忙都来不及去吃饭，所以还锁他妈的大锁，所以他们就没有回来，没有给我带饭，理解别人的难处，别人都已经仁至义尽了，谢谢，真的谢谢 2019年6月19日20:27:25 留寝被查，真好，生活再难，也能活过去，脚伤期间，各种事情的重要性会变的，让我变成最差的学生吧，I don’t care！ 太浪了，花了太多精力去抱怨生活不公！第八天 昨天瞎折腾，导致伤愈情况表得糟糕了，艹，犯错难免，以后警惕 习主席说的对，只有经历了大风大浪还不倒的才是大海，才能看淡其他风雨，才不会想一个小池塘，遇到大风浪是会倒下，所以接受脚伤现状，努力改善，积极变得更好，我治愈之后会更加强大(就像高考前的一段慢性肠炎，然后运动了好长一段时间，这次，我将运动到我不在的那一天，文明精神，野蛮体魄) 放下手机，认真生活 暴雨，然后VHDL课后孙先没走，先问我要不要帮忙，我说等雨小，你们先去吃饭，别管我 然后下雨被困11教，发现11教很多教室不开，沃日，于是先在一个人少的楼梯那里等雨停，看书，之后小雨再回去 后面楼道开始有蚊子…日 感谢一个阿姨提建议让我 和学校反应让我去申请住一楼 [ 当然我没有去申请 ] 成长 今天成长还是很大的，首先是在zy帮忙打伞的作用下，在中雨中从寝室走到英语课教室 然后晚上在11教等雨停了，自己又拄着拐杖慢吞吞地走回了寝室，其实自己还是很叼的哦 第九天 拄拐去打水泡咖啡，自己爱护自己的身体，然后才能为全人类贡献80年！(100岁退休，工作过程也可以享受生活) —-&gt; change the world , make some difference! 2019年6月21日12:50:59，我问zy还回来吗，然后zy说他在星达，以后自己不要把鸡蛋放在同一个篮子，风险太大，早上他答应我给我带饭，于是就一直等他，结果我笑了，算了吧，别人帮你，你得感谢，别人不帮你，那是理所应当… 从来不想给别人造成麻烦，可是现在自己腿伤了只能给别人造成麻烦，难受 喝完那碗胡辣汤[是跑腿腿送餐到寝买的,我的整个思想是 朋友不会永远帮你，但是有钱可以一直买到服务 , 当时的思想也很有趣]，我整个的思维全被 跨越阶层 所占据，我一定要成为一个高阶层人士，实现财务自动增长，看遍世界各地的各种世间百态，成为一个独立，自律，无往不利的我(不要幼稚，活成一个普通人在很多方面都会受到巨大的限制，你永远无法获取更多更好的资源，你永远要忍受别人的压迫，每一天接受残忍社会的教育，在你现在还有机会的时候，努力跨越出你的阶层，成为自己的英雄，然后再去改变你想要改变的世界) 发现自己前天的折腾导致脚踝肿起来了，今天才发现，我服了，下次再也不折腾了！慢慢养吧，一个暑假，不急，到时候人就少了，而且没有关系，慢慢养 然后查资料发现是脚下垂太久，血液不流通导致的，而且绑带有点紧，所以晚上抬高会勒住，所以也会有影响，把腿架起来就好多了 15点开始又认真学习如何治疗韧带拉伤 学了1小时如何恢复，zy回来了，让他教我AD，然后zy20mins解决了我可能几天都解决不了的问题，真好 发现抬腿坐着屁股剧痛，然后不抬腿脚又浮肿，自闭了，所以今天先早点躺着吧 第十天 感谢炒饭阿姨把饭端到桌子上去给我吃[当时10点我去错峰吃饭] 感谢一个微胖小姐姐看到我出一食堂马上快步过来给我拉帘子 WC是我避开密集人流的避难所，所以感谢学校的厕所多[终于理解为什么厕所是社会的包容发泄所避免所了] 回9楼的时候遇到了hsj老师，他好像才知道我伤了 想着不要去看复查干什么，但是身体却很诚实地去干了…看了一个小时，基本上都是看过的，算了，不看了，认真学习，晚上吃鸡后睡觉，明天养足精神去复查 今天拄拐正常生后一整天，然后上帝都奖励我的乐观和勤劳，让我到楼下想掏出手机时正好快递电话来了，这快递比预计时间早20mins，真好，大吉大利，今晚吃鸡，庆祝脚伤但坚挺到了第10天 吃了一个小时的晚饭，然后直接上床休息，看视频，看书，争取明天复查有个好状态 晚上偷偷拆开一点点脚内测石膏，发现一片紫色，绝了，才发现，再撑拐杖10天吧，然后发现屁股那块骨头也没太好，还是痛—不过那应该只是轻微摔伤骨头，应该没有大碍，主要是脚 讲真的,自己当时每次复查前都极度渴望复查时能卸掉石膏,是石膏生活的不便以及麻烦别人的尴尬让我有了这种超强的欲望第十一天 凌晨涂了本草精华液，结果没想到药效如此猛烈，直接吸血一般，导致我左边大腿的血管都有明显地感觉到左脚关节处在抢血！！！左脚关节更是风起云涌！ 5点50梦醒，6点50起床 感谢司机看我不方便开到校门接我后倒车，7点35在车上 第一个就诊，结果去打石膏搞了好久好久，真TM慢 脚部抬高好像真有用，因为脚有时候好烦一阵一阵的翻涌 那个医生说让我加固石膏，下周继续复查。然后那个帮我拆石膏的人说让我走一下，我愣了半天，他说，你怕啥，我才走，发现竟然可以走，就是有点小痛，我惊了，然后那打石膏的医生让我多躺着 先学习吧，晚上再想吃饭的事[基本上每到饭点必定发愁] 发现脚抬高过久也不行，因为脚后跟会有痛感 感谢zy带的酸辣粉，不过一吃肚子就有反应了，我去WC 第十二天(含巨量的腿伤的日志及感想)摔伤日志 我会告诉你我跑到双子楼11去请假再去综合楼盖章，再去食堂买饭，再爬6楼回寝室吗？我会告诉你途中我去二食堂上个电梯摔了一下伤腿吗？我买14块的饭菜不好在那吃而错过好喝的酸梅汤吗？ 不，我不会！我只会在人多的时候走快点，在没人的时候先停下来休息一会继续上路，我只会在没站稳后立马调整，只会在摔倒后立马起来，之后在悲伤的时候劝说自己积极乐观，勤奋坚强，只会每天偷偷扯开一点点绷带偷偷看自己的恢复情况，只会每天梦到自己腿好了，又变回了那个走路像一阵风的骚年，只会…… 虽然有时候也会在心里诉苦， 啊，我的酸梅汤没喝，亏了！ 啊，为啥用剪刀剪掉绷带的所谓石膏拆除费要27块？下次我带把剪刀过去自己拆好不好啊？ 啊，别人不帮你是理所应当，别人帮你你得感激涕零，是啊，世态炎凉啊，还好还有那么几个好朋友愿意在他们方便的情况下帮帮我，感谢了… 懂得: 别人不帮你是理所应当，别人帮你你得感激涕零 努力赚钱，因为别人不能帮你的，你可以通过用钱去买到送饭到寝的服务 那些不愿在你痛苦时给你施以援手的朋友都是所谓的朋友而已，不要太较真 以前发现妈妈只会通过分数对你严管或者松管，总结出的”价值决定一切”其实用在这个现实的社会更加合适不过，所以，我要努力创造价值，make a difference，让绝大多数人都希望我健康地活着，不管是真诚的还是价值捆绑的 珍惜那些真正的朋友，努力报答他们，耐心帮助那些真正需要帮助的人 不要把太多时间浪费在抱怨上面，真的没用 表现得越强大，获取的帮助就越少，但之后你会成为真的强大！ ？？？ 说来有点奇怪，第一次叠完衣服，不放柜子，放床上，竟然是为了:垫高脚 :-) 第十三天 感谢中午余镇榜给我带饭到实验室 [当时在做模电课设] 第十四天 下午吃饭到1点半，然后看别人伤病恢复记录，发现别人恢复了好久好久，莫名害怕，还说软骨损伤不可再生，哭了，还好及时制动，2点33开始认真写完硬件作业，然后上床复习模电吧 第十五天[2019.6.27] 伤腿告诉我，我没必要花时间做不必要的社交，比如寝室去K歌，很蠢，因为大家都很个人化，所以你也无需牺牲自己去迎合大家，你就是你 老师让我过来，结果大家踢比赛，老师做裁判，我在这看着，老师还没理我，emmmm，算了，先坐着看书吧 [ 后面老师看在我平时成绩还不错的份上，但是又不能让我分数高过其他人，所以折中给我了80，感谢 ] 背电脑回寝室… 第十八天 7点21拼命走快点，4号楼6楼到3教302拼死用了21mins，你真棒！ [去考大物实验笔试] 再撑3天3夜就可以洗澡了，身上好多地方可以戳出生推瞪眼丸 [尽管有搽澡] 在厕所躲避人流20mins回寝室，不想去食堂了，很累，回去吃面吧 然后花了1小时回寝室(走得路长了，右脚关节痛…)休息，浪，吃面(大脑都缺氧了，才吃早午餐，下不为例) 感谢晚上zxb帮我带板子送归实验楼，并且帮我带饭 [后面才知道他先去吃饭，然后带饭回6楼给我，然后再去实验楼] 第二十天 考完模电提前40mins交卷，实在写不出了，和翟老师说明情况，她让我再看会，我说有点地方没复习，实在写不出了，就走了 [ 其实当时还有一个很重要的原因是自己需要去错峰吃饭…] 第二十一天(第二次复查之日,也是医生说的3周之日) 凌晨3点，3:00噩梦醒，噩梦是医生说不做拆线检查，应该是多余的担心，继续睡 [ 没想到当天真的没让我做核磁共振检查 ] 艹，4点28又以为7点了 5点14天亮了，6点，6点半 都醒了 日 还没7点 绝了，看来积攒了21天的期望值，情绪有点激动啊 5:59逼我设置6点半闹钟 7点25在校门口遇到vhdl老师，叫他没听见，就一直看着他没叫第二次，他戴着墨镜.. 等了接近20mins，然后自闭了，然后一个识货的知道学生腿伤都是踢球导致的私家车司机过来说10元，比出租车多2元，等到自闭的我管不了这么多了就做了，和他交流，他说这个点大家都上班，本来就很难打车 唯一不爽是他抽烟了… 然后这人看我好像不识货8元给他10元(要不是打不到车，我会多给你2元？)..想让我在对面下，我拒绝了，还好我没有继续傻 8点16苟到了等候就诊区 那老医生一脸不屑，让他的小助理给我开单……就问我骨折没，多少天，然后肿不肿，片也只看了一小会，我说我左边也痛，要不要核磁共振，他看着我不说话，我去，20块，就这样没了… 然后我回家自己拆掉，牛逼！温水泡脚，再拄拐两三个星期 完成了小时候长期不洗澡的梦想，也完成了这21天的梦想，我要洗澡，回来的路上，每走一步就在心里默念一下我要洗澡我要洗澡(受够了搽澡) 今天洗了可能有生之年最快乐，最充满期待的一次澡今天解锁:先左脚下一节台阶楼(伤腿)，后右脚跟上[上楼其实比下楼简单，因为不要比较大的关节弯曲，终于理解为什么这么都伤腿分享的小伙伴都说下楼痛了] 第二十二天(拆石膏第二天)解锁踱步下楼(左下一，右不用跟左脚，可以下下一节台阶，但是有点痛)之后2019年7月6日11:10:34今天是拆石膏第4天，也就是第24天 就是每天做康复训练，网上找的 热水泡脚 搽活血的药物 总结以及学到的 伤腿的日子里面自己也看各大平台的经验贴，基本上每天都看，有些贴子都看了好多遍了，分享一个写得比较搞笑的贴子截图—-以及对单腿蹲厕的网友体验 以后设计产品一定要尽可能多的考虑一下是否有少量人士使用我的产品会产生不便 学会了换位思考 更珍惜健康和时间(生命) 更加珍惜那些在困难中帮助我的朋友们(yzh,zy,wdc,yzb,zxb等) 经验 尽量多休息，把脚抬高 不要轻易尝试走动 过程大概是:红肿-&gt; 消肿(打着石膏容易产生已经好了的心理,此时千万别做出过激的尝试) -&gt; 微肿,脚面发紫(就是很多毛细血管损伤的那种) -&gt; 肿越来越少，然后发紫也变少 -&gt; 小腿肌肉恢复 -&gt; 能够单腿平衡很久 康复训练多锻炼小腿，这样才能早日走路 祝愿 伤病的时间确实有点难熬，不妨利用此段时间多多看书，提升自己，加油，祝愿你们能够早日恢复到日常走路带风的样子!]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第十周(10-521)]]></title>
    <url>%2F2019%2F06%2F30%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC%E5%8D%81%E5%91%A8-10-521%2F</url>
    <content type="text"><![CDATA[Algorithm最近考试加腿伤,刷题太少,惭愧 ReviewDecrypting Blockchain最近facebook发行了Libra币的白皮书，这是一件世界级的大事，因为它可能影响全世界的货币格局，也可能是美国想用新的技术手段来巩固他们的美元地位，而且可能造成货币垄断，所以这周给大家分享区块链的科普，更深入的可以自行搜索Libra然后多多关注 TipsLIBRA, EXPLAINED 最近一直在极客时间学linux，所以Tips本应该是极客时间的文章，但是想到你们看不了，所以放了对Libra币的讨论文章 Share最近一直在极客时间和得到学习，而且也在忙考试，和腿伤休息，所以这周的分享比IT技术分享高一个维度，是人生管理分享如何快乐生活,忙而不碌]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎么成为时间管理的高手-听书有感]]></title>
    <url>%2F2019%2F06%2F29%2F%E6%80%8E%E4%B9%88%E6%88%90%E4%B8%BA%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E6%89%8B-%E5%90%AC%E4%B9%A6%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[第一讲 规划与备忘1. 项目管理表 做计划，细分计划，不重不漏，然后头脑中要有想象，设置截止日期！(不要不设置截止日期) deadline可以用来反馈，若此次没做完，下次做相同任务量任务可以更好设置截止日期————主要目的是让自己对时间有个概念 设置进度提示:进展不顺的子项目要标红 ， 正常进行的标绿 2. 所以要有日历表,日程表日历表 先做重要的事情，先放石头，再放沙子—-&gt;长期投资的事情，巨大红利(技术长期积淀) 好的日历计划不是填满每个小时，而是留有20%缓冲，截止日期也是20%缓冲 日程表 每天事项划掉是感觉很爽的 第二讲 行动:把时间变成产出1. 把事项改成动作把事项改成动作,而非一个大任务,若是大任务,就分解成小动作,让每个当下只有一个动作 2. 干扰多，事情杂怎么办? 悬而未决会让你受羁绊—-所以4板斧解决 1.转让别人帮忙做，若这件事情有人比你做的更好，而且不是必须需要你在场，那么就可以让别人帮忙做，让这个任务更好地被完成 2.做 虽然说要事优先，但如果一个动作只要2-3mins，那就马上做掉，防止占据大脑内存 比如: 一个实验之后，马上和别人探讨写完报告总结。因为这时候印象最深，效率最高，就算当时很累，也很值得 3.存存起来(马上放日程表)，以后做—注意不要放在大脑里面,否则会影响自己全情投入 4.扔不重要的，可以直接扔掉 总结： 不要让自己的大脑被占据担心自己做不好而拖延怎么办? 面对大人物做报告，也把对方当做自己的学生，因为你是专家 反正要做，不如找个积极的心理暗示 和别人交流，听取别人的建议 2019年6月29日 学完上面并做笔记 2019年6月30日15:38:22 开始下面的学习 第三讲 敏捷工作法:让计划赶上变化不要把时间浪费在努力工作中完美主义的时间浪费完美有代价，把一件80分的事做到了100分，导致其他很多应该做到60分的事情没有做 范围蔓延别人要求帮不是你要做的事情的时候,不断让步,结果自己帮别人做了好多事情 返工没有沟通好，需求没有谈好 敏捷工作法最小可交付,持续迭代把自己的每个输入，处理，要想做自己的输出，自己要干什么 最小可交付，就是做一个小demo，然后大家提出反馈，让你可以调整，这样就不用大的返工 别人给你任务，你给别人的deadline为第一次交付的时间 交互一个小交付后，你就可以做下一个任务了 如果多个项目重要的事情多迭代，紧急的事情先迭代 敏捷工作法， 不要进行多个任务，让手里只有一个项目 第四讲 管理合作者的时间透明的沟通习惯 做决策的时候就拉大家过来一起决策 同步站会，让大家站着开会同步进度 让自己的任务进度能被看见 尽量当面沟通！能见面就别打电话…能打电话就别发邮件… 敢于和上级沟通时间 管理者只会记得上面的任务,不记得给下属的任务 主动给上级反馈你的进度，让其对你的任务进行重要度排序，这个也很受上级欢迎 团队领导如何管理上级 不要把下属的事情自己做,不要所有事都亲力亲为 下属不是因为成长而能做事情，而是因为做事情而能力成长 下属让你帮忙做，你要思考最终责任人是你还是他 担心下属能力，就从小的任务开始训练他，比如给讲PPT，一次给他3mins等等，然后慢慢渐渐增加 第五讲 如何与忙碌相处 忙碌的人完成事情更快，而且不容易错过deadline，闲的人反之 我们要避免内卷化忙碌就是被自己忙死，但是恶性循环，没有时间提升自己 改善:要做到自驱模式的忙碌确定计划确定自己的人生计划 这种计划一般是除了本来要做的事情外 开创新领域 自己想做的 这种事情会让自己很快乐的，会产生积极的情绪，然后良性循环也会让自己做本职工作的时候效率更高想象自己定的目标是给未来的简历 给学习留出足够的投入 在学习上，投入自己心痛的钱(可以自我提升的比肩自己每天工作赚取的钱)这样自己就会非常地重视，并且努力学习，并且会积极主动地学以致用 最后发现人生最大的成本其实是时间 跑出自己的良性循环让自己的技能提升，然后马上使用自己提升的技能 对于制定人生计划:自己10年想要什么是想不明白的或者说很难想明白，要做的是不断迭代自己，在自己本职工作上面，尝试自己的兴趣点的一个小任务的迭代，每次如果都有好的结果，那么就多迭代一次，多多探索，直到自己发现自己学习到了有能力胜任新的职位的时候就可以对自己的人生进行一次大的迭代，就是找到本职工作和新技能工作的能力交叉的工作，然后就这样持续地迭代自己的人生 注: 当然如果你一开始就有一个人生目标，然后你的每一次小的迭代都是往这方面进行的小迭代，小进步，这样就更好了，有目标地探索，能让你走得更有方向感，离成功更加容易到达，因为一直在向着目标走啊！ 总结 管理时间就是管理人生时间就是生命，管理好时间就是管理好人生 让时间服务于你，而不是你服务于时间，这样你就能过上自驱的快乐忙而不碌的生活，然后就能有充沛的精力去陪伴家人，去享受生活 最后祝愿大家能幸福健康，职场节节高升!过出自己想要的人生! 单林敏(wolfdan) 2019年6月 于合肥]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第九周(9-521)]]></title>
    <url>%2F2019%2F06%2F23%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC%E4%B9%9D%E5%91%A8-9-521%2F</url>
    <content type="text"><![CDATA[Algorithm最近踢球脚扭了，不能走路，要休息，所以刷题较少 ReviewThe Internet is changing your brainWe can remember the things that we need to remember but, forget the things that we rarely use. That is not a problem, it is entirely sensible and should be expected.我们要在变化快速适应，要积极求变，不断进步，终身学习 Tips 当然要推荐且必须要放耗子叔最近新发的文章啦 如何超过大多数人 就是不管干啥都要多多访问官网，比如配置next，官网才是最新的资讯因为自己对busuanzi统计的折腾，发现还是官网好啊 NexT 使用文档 Share在另一个终端上同步写HEXO AD14.2如何安装各种库 安装破解Altium Designer14.2]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AD14.2如何安装各种库]]></title>
    <url>%2F2019%2F06%2F17%2FAD14-2%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E5%90%84%E7%A7%8D%E5%BA%93%2F</url>
    <content type="text"><![CDATA[AD14.2如何安装各种库我们先以安装NSC Amplifier.IntLib为例子安装文件由于我不知道NSC Amplifier.IntLib在哪,所以我直接搜索找到了这个官方网站的一直文档分支链接进入之后看图操作下载吧下载 使AD软件链接路径 开心食用 下载各种库？当然是找官网啦啦啦官网老库 注意:你清楚你要的库是哪个大文件包—&gt;否则1.谷歌搞清楚2.自己下载整个库解压后搜索 最后注好像又是重复造轮子，搬运工，所以大家多多了解这种解决方案的思路啦，以后多多触类旁通啦 谢谢大家的浏览啦]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>总有一些事情值得</tag>
        <tag>hardware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在另一个终端上同步写Hexo]]></title>
    <url>%2F2019%2F06%2F17%2F%E5%9C%A8could-studio%E5%90%8C%E6%AD%A5%E5%86%99Hexo%2F</url>
    <content type="text"><![CDATA[在另一个终端上同步写Hexo用Cloud Studio做示范,其他非linux可以适当借鉴 2019年6月17日20:49:03发现Cloud Studio发布的环境也没有保存npm！所以只能每次都重新安装，所以小编将会加急写个脚本出来—&gt;结果发现在cloudstudio运行脚本各种奇葩bug，所以大家要用cloudstudio写hexo的话可以每次粘贴一下下面的程序段，当然建议直接在本地装吧，这种免费但不怎么稳定的东西用着心累1234567echo "-------CloudStudioWriteHexoOnce-------"curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | shwget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | shexport NVM_DIR="$HOME/.nvm" &amp;&amp; [ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh" # This loads nvmnvm install stablenpm install -g hexo-clinpm install 1. 添加密钥并且Git pull你自己的仓库由于本着不重复造轮子的心态,所以不会云备份Hexo的朋友们可以看某大佬写的文章 2. 安装node.js安装 Node.js 的最佳方式是使用 nvm cURL: $ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh Wget: $ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh 配置nvm环境 export NVM_DIR=&quot;$HOME/.nvm&quot; &amp;&amp;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 安装完成后，重启终端并执行下列命令即可安装 Node.js $ nvm install stable 3. 在blog的根目录安装依赖 注意:blog的根目录就是你之前hexo init &lt;folder&gt;的这个foldernpm i 然后测试hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 4. 写新文章测试 5. 发布自己的环境 这一步十分重要！！！ 博主就是由于之前这一步没做，导致了环境重置 因为cloud studio的工作目录和环境是分离的！ 丢失环境只能重建 发布自己的环境 谢谢大家的浏览啦]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装破解Altium Designer14.2]]></title>
    <url>%2F2019%2F06%2F16%2F%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3Altium-Designer14-2%2F</url>
    <content type="text"><![CDATA[安装破解Altium Designer 14.2.3 http://pandownload.com/ 百度云盘第三方不限速版软件(小单推荐) 欢迎访问wolfdan.cn AD软件链接：https://pan.baidu.com/s/1m6mNk_uqHGb3q6Moc1zqQA 提取码：eqyo 2.1用1打开这个链接，然后下载，只下载两个压缩包就行了， 2.2然后一起解压到当前目录 2.3看视频安装 个人分享链接:https://pan.baidu.com/s/1EHtVTZWtefQwVn6GVleE6g 提取码：zhf1(防止上面失效用的) 注:不好意思，好像重复造轮子了,dbq,但希望能帮到你…用完即走就好(毕竟是工具性质,分享性质的网站)]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>总有一些事情值得</tag>
        <tag>hardware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第八周(8-521)]]></title>
    <url>%2F2019%2F06%2F16%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC%E5%85%AB%E5%91%A8-8-521%2F</url>
    <content type="text"><![CDATA[ARST打卡第八周(8/521)探险就要做好面对乌云密布的准备注·最近因为踢球脚韧带拉伤了,所以最近喜欢看比较悲壮的图片,希望大家多多注意身体健康 AlgorithmARST第八周的刷题 ReviewDevOps: Tools vs. MindsetAnd it is so true: without developing a collaborative environment within the teams, and a culture to adapt to continuous change, no organization can claim to have achieved DevOps implementation success, no matter what tools or technologies you use.对的，通力合作才是最棒的DevOps Tips一个大佬的求职逆袭 Share如何使用一个域名同时构建Hexo和WordPress]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用一个域名同时构建Hexo和WordPress]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%9F%9F%E5%90%8D%E5%90%8C%E6%97%B6%E6%9E%84%E5%BB%BAHexo%E5%92%8CWordPress%2F</url>
    <content type="text"><![CDATA[两把椅子，看见同一片美景 wolfdan blog主本人的配置:其他配置可以灵活参考 BT面板管理的WordPress 腾讯云管理域名 Hexo分布在github page和coding.me pages上面 使用的wolfdan.cn做WordPress的域名，www.wolfdan.cn做Hexo的域名（主要是因为之前我的WordPress就是用的wolfdan.cn的域名,所以如果我想要反过来操作的话—&gt;那么1. 数据库里面不太好改的，2. 容易出一些文章链接不正常，3. 网站SEO会很奇怪—&gt;好奇的朋友可以自己尝试一下） 操作一.给coding重新绑定域名 我的是绑定www.wolfdan.cn，你们参考一下 去腾讯云解析,把github的pages解析关闭掉，然后www.wolfdan.cn只留下pages.coding.me的CNAME的解析(详细操作请看图)这样做是为了顺利申请www.wolfdan.cn的域名的SSL，因为如果还开着github的那个解析会申请失败(可以解决问题:coding申请SSL失败) pages解析 二.绑定好其他域名 去github.io仓库的setting设置custom domain的域名绑定 Hexo的你的博客根目录下的source根目录下新建一个CNAME文件，里面写上你刚刚绑定的域名，这样是为了防止每次发布后重新绑定github的域名 用@记录绑定自己vps的地址最后解析的画面 在bt面板添加网站并申请ssl添加网站申请ssl 修改wp-config（看情况是否需要操作） 开始测试玩耍收工咯注： 测试效果的时候，谷歌浏览器要输入网址的话，域名最后一定要加/,比如blog主的https://www.wolfdan.cn/，否则很可能出现谷歌智能跳转到以前访问过的https://wolfdan.cn上面去(我就在上面花了好久时间…) 提前谷歌了一下，发现自己应该没有重复造轮子，才写下此篇，2019年6月15日19:03:53应该没有重复造轮子，感谢大家浏览 由于自己是5天后才写的，所以难免会有很多纰漏，如果大家有哪里看不懂的可以给我评论留言，谢谢大家的浏览和支持]]></content>
      <categories>
        <category>域名</category>
      </categories>
      <tags>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[许岑老师的《如何成为有效学习的高手》读书有感]]></title>
    <url>%2F2019%2F06%2F12%2F%E8%AE%B8%E5%B2%91%E8%80%81%E5%B8%88%E7%9A%84%E3%80%8A%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E6%9C%89%E6%95%88%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%AB%98%E6%89%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[高效学习关关键词适合自己、学习方法、短时间、注意力、解决难题、设定目标，以及名师 找到适合你的学习方法 自然主义核心在于模仿，结构主义为的是创造 模仿类的学习—比如语言等,就是不断地模仿,不要花过多的时间去死扣结构 而学习创造性的学科时，比如艺术类，设计类，那么就要学好基础结构，这样才能有效创造 练习不必顾全大局，练习的时候就可以把练习的东西先拆解反复练习，之后在组合练习的时候再顾全大局 不要收藏，而是多碎片化学习(没有整块学习时间的情况下)，当然碎片化学习的前提是你要有一定的知识体系(比如你要会1+1=2吧) 不谈兴趣,用任务驱动学习 生活驱动,工作驱动,以教为学 生活工作中的一些事情推动你学习,那种就是很强的驱动 每次学习都要有教别人的任务心态去学习,比如写分享文章等,这样就能使得自己的学习变成一个强的任务驱动的学习过程，进而让自己成为一个高效的学习者 你99.999999999%没有拖延症 事情的重要程度决定了你的行动力,所以给自己要学习的任务的重要性加码 精致地对待自己的生活 买贵的学习工具(贵到让你心痛),那么你就会刻意学习了,因为这么贵,怎么舍得不好好利用,不每天都用几下,感觉少用一下都是亵渎钱财 平时生活中要有仪式感,比如好好吃饭 使用射灯,让自己有一种在舞台表演的感觉 进入高质量的睡眠,白天累到自己,比如超认真工作一天,睡前几小时锻炼身体,或者超级专注地玩游戏 设定有效的目标 首先要有足够明确的目标，强烈的任务驱动欲望，而不是自己的白日梦那种偶尔幻想级别的任务，否则太容易半途而废了，比如你要出国留学,你现在迫在眉睫地需要练习好口语,还比如你下学期要打ICPC比赛了,你要急速提升你的算法竞赛能力 直奔大师 在明确了自己的目标也就是自己要去到哪里之后，然后先来一次直奔你要去的地方的模仿(因为这里涵盖了兴趣和任务驱动),然后再是扎实地练习基础功，然后就不断地向着真正意义的大师慢慢进发 怯场是最糟糕的自觉。一个人他胆子变得比之前的大一点，能走的路可能就长一点 制造反馈 当学东西的时候，一定要想办法把学习的成功展示出来，应用出来 比如文字类的，写个总结(就是自己看着文章用自己的话来表述) 口语类的就给自己录音反复练习 动作类的就给自己拍视频然后看自己的动作是否规范，然后反复练习 突破瓶颈 解决自己的心态问题,在排除了技术问题后,要足够地自信 扩大涉猎范围,在你的专业里面,你要不断地积累 更加专注,请教名师 结语 如果自信来自于自律，那就是扎扎实实的自信。如果自信来源于幻想，那就是盲目的自信]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于认知,财富,阶层的听书blog记]]></title>
    <url>%2F2019%2F06%2F10%2F%E5%85%B3%E4%BA%8E%E8%AE%A4%E7%9F%A5-%E8%B4%A2%E5%AF%8C-%E9%98%B6%E5%B1%82%E7%9A%84%E5%90%AC%E4%B9%A6blog%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[洛克菲勒行事准则: 绝对不要把精力发在不可逆转的事情上面！(所以不要花时间去抱怨) 记录读书笔记以及学习技术的blog，让自己忘了详细细节的时候能够快速查找到，也让自己加深理解—-&gt;然后想想怎么让人们能够轻松地给语音知识做笔记，这可能是一个爆点(脑电波？) 我们必须面对现实，现实就是没有那么多时间让你搞清楚一切，你必须做出当前限制下的选择！所以我们一般情况下是定好目标，选好方法，合适取舍！而非一直死磕！因为一般你不会一直做嗑盐，除非你是科学家，但你的梦想是伟大的工程师啊，所以你必须学会转变思维方式，确立目标，选好方法，合适取舍！ 虽然你喜欢一直搞通全部，但这是不可能的，你要接受现实，但你必须努力去达成目标，目标域内关键的东西必须搞清楚 围棋智慧，两只眼活，所以让自己算法能力练习到前25%，演讲沟通管理写作技能练习到前25%，那你就可以成为伟大的工程师，好的就是这样 多只眼更爽 自己需要表达+算法+思维不断强化 中国族群给哈佛这些私立学校捐款才能提高我们中国族群的哈佛入学率，而中国大学国家资助，所以只要多多纳税就好 美国自由，福利到，导致穷人不自控不自制，然后穷人很找就乱性生了孩子又容易单亲然后教育就不好，并且天天和穷人待在一起，思维觉得这样也好，然后穷人循环，然而富人反之，中国却可以让你有机会接触富人，让你在没有很强自制力前强制压迫你学习的机制，所以反而贫富流动性很好 中国也有分层，各处都有分层，但是分层的本质来自于思维方式导致的分层！你的思维是否就只是一个中产阶级的思维？ 底层用技术教育，中层用素质教育，精英层用决策教育(你说1+1=3，那其他人同意吗？) 顶级精英，培养你自行决策，让你学会选择，中产是提供作业，让你多样化完成 所以多练习自己的决策能力！！！选择去改变世界，永远不按套路出牌，成为英雄，超越自己的命运 跨阶层的人才是英雄 不知道自己知道是经验！是认知最高境界 人和人唯一差别是认知 提升认知1.自我否定(不能对任何事确定地说我知道)2.行动(知行合一，认知到重要的马上行动)(早死早超生)3.和认知比你高的人待在一起！！(找职业就找认知比你高的老板或同事)(腾讯开放各平台就可以和各大佬交流认知！！！) 风险投资人 == 用概率算法，是一种精密算法的概率游戏，富人思维，好的亲友环境可以给你这种思维]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第七周(7/521)]]></title>
    <url>%2F2019%2F06%2F09%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC%E4%B8%83%E5%91%A8-7-521%2F</url>
    <content type="text"><![CDATA[AlgorithmAlgorithm ReviewLearning Containers In addition to all the traditional work of a DBA, I’ll be adding a bunch of information on containers as I learn it. For good or for ill, a lot of stuff like query tuning, backups, HA/DR, and more, is NOT going away. 我认为:是的，容器化改变了运维现状，以后的运维师将会变少，但不会消失，极度优秀的运维师反而还会出现新的供不应求—-从古至今，市场从而不缺技术人员，只缺技术人才，所以我相信对于运维职业消失的担忧其实和当下的CV程序员对于自己是否会被裁掉的担忧是一样的,因此，我们面对技术变革，唯一需要做的，也是一辈子都需要做的就是：终身学习，我也喜欢这个行业带给我终身学习的习惯 Tips:V2ray问题合集Hexo搭建个性化next主题 Share:Hexo和WordPress]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo和wordpress的选择]]></title>
    <url>%2F2019%2F06%2F08%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BD%BF%E7%94%A8Hexo%2F</url>
    <content type="text"><![CDATA[Hexo和wordpress的选择 1. 原来的服务器ip被墙了 因为原来自己的网站是搭建在国外的一台服务器上面，然后最近一段时间网络整顿，然后我的ip被ban了,然后我抢救了4天整,好不容易救活了,但是访问速度极其不友好,所以为了让我的读者能有最后的体验,我必须努力啊,然后我就想到了境内境外分流(其实也是受到一个学长的启发) 2. 因为维护vps太麻烦了 记得自己是最喜欢配置各种生产环境的一个人,前段时间还想过要做一个运维工程师来着,但是最近头铁了4天整,发现维护vps实在是太麻烦了,而且自己还有很多其他的事要处理,所以这种比较吃时间,可以做到的,但做慢了却会影响用户体验而导致自己熬夜也要肝的事情还是尽量少发生比较好一点,所以自己觉得让网站托管在大厂微软的github和腾讯的coding上面 3. Hexo的美化度比较高(个人感觉) 不知道是自己没有认真地看wordpress的主题还是怎么样,我感觉Hexo的美化度是比较高的,然而我看到的比较好看的wordpress的主题都是收费版的更好看,这让暂时没什么钱的我有点难受,而且觉得不太值得 4. 免费 真的,买vps不管国内国外,就连学生机都要至少10RMB/月左右,所以对于这种Hexo的部署分流方式，真是又快又好又便宜又省事,何乐而不为呢? 注: 虽然有些大佬可以薅到谷歌云和亚马逊云的羊毛免费使用一段时间,但是时间是有限的,而且还是有第一二个问题—-网站容易被墙和维护vps困难 感言当然我不是说不能用wordpress，wordpress其实也是有很多好处的，比如 可以云端写文章(因为它是在网页端写作的特性) 可以搭建好了之后让一些没有计算机相关背景的作家使用(就是只要有技术的人定期维护一下就好)(当然这也不一定) 技术历史长，就是很多问题在谷歌百度上都能找到(而Hexo是一个相对来说新一点的东西) 做好真正重要的—————— 学习和创作 这些东西其实都是一些工具，我们最应该做的还是在自己感兴趣的地方多多努力，然后创造价值，再分享给大家，这才是最重要的，也才是我们写作的最主要的目的—&gt;帮助更多的人 2019年6月9日21:07:21 当我今天用着wordpress写文档的时候，想着以后再有不用这个了，心里有说不出的难受，毕竟这真是我亲儿子一样，养了几个月了，难以割舍的情感，而且云端写作的体验也是妙不可言，所以我决定还是wordpress和hexo都使用 然后2019年6月9日21:49:40 发现Hexo是组件化，然后很多都是链接别处的东西，所以很容易挂掉某个组件，很惨的那种，然而WordPress就是只要你的vps不死掉，ip不死掉，基本上是没有任何事情会出大故障的]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第六周(6/521)]]></title>
    <url>%2F2019%2F06%2F01%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC%E5%85%AD%E5%91%A8-6-521%2F</url>
    <content type="text"><![CDATA[Algorithm第六周算法打卡 ReviewThe Modern Data EstateYou need to be able to access past and present data and predict the future using data. What I think? Yes,I think that there must be a big chance in big data.And we should use it well. 鲁迅说过:要用历史的眼光看问题，借鉴历史，因为历史总是惊人的相似 鲁迅又说:我没有说过 其实是根据我高中历史老师教我的，以及看桥水公司创始人很早就用电脑来分析过去的股票数据来预测将来的股票走势(我觉得这可能是最早的量化交易)和《杠杆说服力》看的一个尿不湿和啤酒的故事，所以我觉得现在应该是： 结合AI来分析挖去泛数据中的价值，并且好好利用这些价值的时候了 Tips：socket programming in cpp Share:SUBLIME插件包无法安装问题解决]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime插件包无法安装问题解决]]></title>
    <url>%2F2019%2F05%2F30%2FSublime%E6%8F%92%E4%BB%B6%E5%8C%85%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[Sublime插件包无法安装了？背景 前段时间一直发现sublime使用过程中各种包报错说无法更新什么的，起初还以为是那些插件包出问题了，后面发现自己竟然根本无法访问Package Control！ 当时我很震惊，然后一直忙到最近才有时间来解决这个bug 我不会告诉你我觉得写ACM题目用VScode写起来那个编译运行那里还是有点不爽，所以我又回归了用sublime写ACM题目 正文遇到问题打开终端1ctrl + ` 查看错误 实践分析发现（访问sublime提醒的官网解决方案）: 这个网址被墙了，而且网站使用的子匿名域名(看不到)也被墙了 解决方案一:通过一些学习资源(比如校园网，科学上网)开启全局访问一下解决方案二:手动下载一个package control管理员在github上维护的包：package control管理员在github上维护的包 打开链接后，右侧点击Download ZIP：把下载下来的包解压，将解压后的文件夹重命名为Package Control, 拷贝到sublime的packages目录下，直接菜单栏Perferences—&gt;Browse Packages. 然后将 Package Control文件夹拷贝进去 然后重新点击菜单栏Perferences，会发现多了Package Settings 和Package Control 这两个菜单，这就说明 Package Control安装成功了。 打开Package Settings—&gt;Package Control —&gt; Settings User 添加&quot;channels&quot;:&quot;http://cst.stu.126.net/u/json/cms/channel_v3.json&quot;,前面的行尾记得加逗号(这里是使用的镜像索引网站)2.5 然后就是熟悉的操作Ctrl+Shift+P—&gt;install—&gt;选包 若遇到了新的问题：package版本过旧，也可使用2中的解决方案二来解决问题 再次访问官网(发现是版本过旧)解决: Have fun就是熟悉的操作Ctrl+Shift+P—&gt;install—&gt;选包然后我装了个golang build来测试，发现成功了 参考：https://packagecontrol.io/docs/troubleshootinghttps://blog.csdn.net/wcc27857285/article/details/88368866]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>Sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第五周(5/521)]]></title>
    <url>%2F2019%2F05%2F26%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC%E4%BA%94%E5%91%A8-5-521%2F</url>
    <content type="text"><![CDATA[Algorithm 这一周天天在准备计算机设计的国赛作品，所以比较忙，没有什么时间写算法代码，偷偷挤了点时间在上课的时候刷算法书，然后做了一小会题目，等下周项目提交之后就认真刷题，多刷题，疯狂刷题 呜呜呜，我也想好好刷题，可是时间都被项目压榨了，坐下来写blog的时候队友还叫我过去调代码，然后我说我现在有一件大事要做，就是写blog呀，因为521周打卡是不能断的！ (2019年5月26日14:33:36发现昨天寝室的电脑最终版忘记git push了，所以先粘出链接，到时候再push完善一下)poj1845分治 Review一下自动化工具 我相信未来是很智能很自动化的，我也喜欢让我的工作自动化，所以喜欢折腾各种提高效率的工具，由于这周一直在忙，于是没有看什么比较深度的英文，其实也有看Android开发的英文技术文档啦：》 Tips：2019年5月19日15:53:33 突然发现自己的网站访问不了了，以为封ip和域名了，害怕，后面发现是网络连接问题，吓死，不过还是深入了解了一下相关的内容什么是域名被墙？域名被墙了如何解决？ Share：用github当做图床 &amp;&amp; 用sublime或者VScode写markdown 再忙也不能不信守诺言，所以上周blog里面说过要给大家分享的东西，这周一定会写出来的，也会坚持521ARST打卡的 用github当做图床 生成本地git仓库 如何找到图片的真正链接 真正的链接使用感言 我承认确实没有直接粘贴使用默认图床方便快捷，但是我需要我的小站存在的时间是我的整个有生之年，甚至奢望想它存在到永久，因为我想要帮助更多的人到永久(当然这不是很现实，所以是个奢望，不过我也还是会继续进行这样的努力，因为: 不试试怎么知道不行呢？),所以我需要一个能存在很久很久的云端存储，所以我选择了github，我觉得github如果要倒闭也会给我们时间转移资源，更何况现在看来它背后是微软，现在又贴出人性化的打赏全收益，所以我觉得它不会凉，呵呵呵，所以麻烦点只是为了更稳定长久 用sublime或者VScode写markdown VScode下载Markdown All in One插件 VScode的markdown展示建立一个.md结尾的文件 sublime写markdown 使用感言 感觉有些主题的色彩高亮不够完美，所以我觉得还是直接用wordpress上的markdown编辑器比较舒服，因为这个markdown编辑器真的是我用过最好的一个:色彩高亮合适，编辑器所有的快捷键几乎都支持，版本控制，自定义等等，唯一美中不足就是实时预览对于有图片的时候不太友好，不过这是实时预览的一个通病，也无可厚非，所以有网的时候还是用wordpress写吧，真香 小插曲git图片同名不替换?其实只有本地缓存的原因啦 A joke 本来想现在预报我下周给你们分享什么的，但是感觉这样万一没做到岂不是鸽了大家，而且留下了不守信用的骂名，所以我决定保持稳重，避免风险，但… 这不会让我懈怠的，我会努力地尽量每周都给你们惊喜的，嘿嘿]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第四周(4/521)]]></title>
    <url>%2F2019%2F05%2F18%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC%E5%9B%9B%E5%91%A8-4-521%2F</url>
    <content type="text"><![CDATA[这个小房间就像我的小站，我会让这里面住着一个美人 Algorithm: 第四周的LeetCode题目 View:Always Squash and Rebase your Git CommitsAlways Squash and Rebase your Git CommitsI propose a clean history is more valuable than one that is hard to understand. Tips:破解安装Quartus 15破解安装Quartus 15VS code 中的各种变量 ${file},${fileBasename}廖雪峰前辈的git教程 Share：wordpress使用markdown教程前言 之前因为每次启动这个markdown编辑器就会把我整个文章都搞乱，就是它自动把我原来写的东西都按照html的格式展示出来，后面想了想，可能也是应该的，因为原来的文章虽然采用的是富文本的模式写的，但是原生的wordpress在保存的时候还是使用了html保存，所以这也不能怪这个wordpress，所以现在我在新的文章上面直接改用markdown来写作，然后就可以直接同步到简书和自己的个人网站和大部分支持markdown的地方，所以这是很好的，所以今天的分享就是关于使用markdown在wordpress12345678#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; cout&lt;&lt;"Hello markdown in wordpress"&lt;&lt;endl; cout&lt;&lt;"不得不说，直接用markdown写，代码高亮真滴赞那，\ 所以我觉得以后可以多粘点代码给你们看了，嘿嘿"&lt;&lt;endl; return 0;&#125; 为了blog存在100年，所以我决定不用我不熟悉的图床，不然很容易导致时间久了我的图片就看不了了，所以我得找一个稳固的图床中心：github 但是自己这周得打程序设计比赛的省赛，所以下周再和大家分享如何使用github当做自己的图床 效果图 方法正文 先登入wordpress 进入插件安装界面 搜索 WP Editor.MD 安装 通过插件Editor.MD点击进入启用设置，如下图 &lt;/center&gt; 然后就可以像效果图那样开心地写Blog了使用感言 表示这个直接在上面写的感觉也是十分好的，1. 各不同类型的颜色高亮处理的相当出色，2. 然后就是他的预览也比较好看(不过插了图片之后就有点左右显示不太合理了,自己用一下就知道了) 3. 竟然还有版本控制，和简书一样，真的很赞(虽然我不用，但是还是要点赞，因为指不定我哪天就用了呢，多一层安全总是好的) 如果你们想用sublime或者vscode作为写blog的工具，然后再之间粘贴到自己Blog的话，那么请关注收藏我的小站，我下周告诉你们 总结 小站终于可以用MarkDown了，而且效果还这么好，我兴奋啊，所以最近的产量肯定会变高的，嘻嘻嘻，大家一起进步呀…对了，我向队友坦言我刷题慢，向队友求取刷题方法了，所以我下一段时间可能会有关于刷算法的一些分享 改进 一开始本文采用了20M的图片，以及markdown评论，导致加载速度极其地慢 所以我把pic改成了 home 这个小房间就像我的小站，我会让这里面住着一个美人 然后还去除了评论使用markdown（这个主题好像有点不兼容） 然后还测试了手机端的访问以及易读性]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第三周(3/521)]]></title>
    <url>%2F2019%2F05%2F12%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC%E4%B8%89%E5%91%A8-3-521%2F</url>
    <content type="text"><![CDATA[ARST打卡第三周(3/521) Algorithm:https://github.com/wolfdan666/WolfEat3moreMeatEveryday/tree/master/2019.5/2019.5.9 Review:https://medium.com/s/freakonomicsradio/the-1-5-trillion-question-how-to-fix-student-loan-debt-39125449af44?FGa=true 美国大学生确实有很高的债务，怪不得他们大学拼命学习我们国家大学学费真的很良心了，所以得好好珍惜啊不过自己的青春时光也很珍贵，所以也要在大学拼命学习 Tips: 制作了一个番茄时钟https://blog.csdn.net/qq_38190111/article/details/89044299#commentsedit Share： #CentOS开启Ftp 注意：我是在CentOS6操作的，CentOS7的重启操作是 systemctl restart vsftpd.service 分析：（很急的观众老爷可以直接看最后面的操作） Linux服务器上安装ftp提供用户上传下载，是很方便的事情，但是如果你的服务器开启了iptables防火墙，就要对ftp端口做一些设置。 ftp端口真的比较特殊，并不像80，22这些端口。它分为连接用的端口，还有当你上传下载文件的传输数据用的端口。netstat -tnl 命令可以看到，我们现在运行了ftp服务。tcp 0 0 0.0.0.0:21 0.0.0.0:* LISTEN 现在我开始对ftp端口的设置，按照我们以前的视频，添加需要开放的端口ftp连接端口有 21 和 20 端口，21端口用于连接，20端口用于传输数据，我现在添加对应的规则。[root@localhost root]# iptables -A INPUT -p tcp --dport 21 -j ACCEPT[root@localhost root]# iptables -A INPUT -p tcp --dport 20 -j ACCEPT[root@localhost root]# iptables -A OUTPUT -p tcp --sport 21 -j ACCEPT[root@localhost root]# iptables -A OUTPUT -p tcp --sport 20 -j ACCEPT 好，这样就添加完了，我们用浏览器访问一下ftp,出现超时。 所以我刚才说 ftp 是比较特殊的端口，它还有一些端口是 数据传输端口，例如目录列表， 上传 ，下载 文件都要用到这些端口。 而这些端口是 任意 端口。。。 这个 任意 真的比较特殊。 如果不指定什么一个端口范围， iptables 很难对任意端口开放的，如果iptables允许任意端口访问， 那和不设置防火墙没什么区别，所以不现实的。 那么我们的解决办法就是 指定这个数据传输端口的一个范围。下面我们修改一下ftp配置文件。 我这里使用vsftpd来修改演示，其他ftp我不知道哪里修改，大家可以找找资料。[root@localhost root]# vi /etc/vsftpd/vsftpd.conf在配置文件的最下面添加pasv_min_port=30001pasv_max_port=31000 然后保存退出。 这两句话的意思告诉vsftpd, 要传输数据的端口范围就在30001到31000 这个范围内传送。 这样我们使用 iptables 就好办多了，我们就打开 30001到31000 这些端口。[root@localhost root]# iptables -A INPUT -p tcp --dport 30001:31000 -j ACCEPT[root@localhost root]# iptables -A OUTPUT -p tcp --sport 30001:31000 -j ACCEPT[root@localhost root]# service iptables save最后进行保存， 然后我们再用浏览器范围下 ftp。可以正常访问 vi /etc/vsftpd/vsftpd.confservice vsftp restart vi /etc/sysconfig/iptables service iptables restart 操作： 先对vsftpd服务配置进行操作：vi /etc/vsftpd/vsftpd.conf在文末添加 pasv_min_port=30001pasv_max_port=31000 重启服务CentOS6：service vsftp restart 重启服务CentOS7： systemctl restart vsftpd.service 再对iptables进行配置：vi /etc/sysconfig/iptables找到一个位置，然后粘贴配置： #easy ftp -A INPUT -p tcp -m tcp --dport 21 -j ACCEPT -A INPUT -p tcp -m tcp --dport 20 -j ACCEPT -A INPUT -p tcp --dport 30001:31000 -j ACCEPT -A OUTPUT -p tcp --sport 30001:31000 -j ACCEPT#下面是bloger尝试但失败的配置，可以不用管，不用复制# hard ftp,safer but failed# allow all ftp incoming connections #-A INPUT -p tcp --dport 21 -m state --state ESTABLISHED -j ACCEPT# -A OUTPUT -p tcp --sport 21 -m state --state NEW,ESTABLISHED -j ACCEPT #Enable active ftp transfers #-A INPUT -p tcp --dport 20 -m state --state ESTABLISHED,RELATED -j ACCEPT #-A OUTPUT -p tcp --sport 20 -m state --state ESTABLISHED -j ACCEPT# Enable passive ftp transfers# -A INPUT -p tcp --sport 1024:65535 --dport 1024:65535 -m state --state ESTABLISHED -j ACCEPT# -A OUTPUT -p tcp --sport 1024:65535 --dport 1024:65535 -m state --state ESTABLISHED,RELATED -j ACCEPT 重启服务CentOS6： service iptables restart 重启服务CentOS7：systemctl restart iptables]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第二周(2/521)]]></title>
    <url>%2F2019%2F05%2F05%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC%E4%BA%8C%E5%91%A8-2-521%2F</url>
    <content type="text"><![CDATA[ARST第二周(2/521) Algorithm: 第二周LeetCode Review:(为了学习英文) Consider how our digital content consumption works today. Some people consume free music and TV shows daily via pirated files, illegal streams. Some consume digital content via legal, publicly-funded radio and TV station streams. Others pay for the privilege to access highly curated and secure services like Spotify, Pandora, Netflix, Hulu, and others. AR clouds will be no different.So how will we choose? I think the answer is security and convenience. 我也认为将来全面上云之后盗版资源的安全隐患会变得极其巨大，所以必须做好安全防范，最好购买服务，但是同时也最好要照顾世界上的弱势群体 Don't Be Evil！ The Future of the AR Cloud — a Thousand Walled Gardens Bloom Tip:(主要是为了总结和归纳你在是常工作中所遇到的知识点) 安装VMware15Pro，在上面安装CentOS7，并设置NAT联网(以及kexue就不说了，自行学习) 安装VMware15Pro VMware15上安装CentOS7 设置NAT联网 Share： 1.基于上下文的自适应算术编码代码实现 设信源可能输出的符号是a, b, c 三个字母，构成一个二阶Markov信源，且各阶条件概率如下，试编写程序可以对任意字母序列（如abbcabcb）进行基于上下文的自适应算术编码，并进行相应的译码。思路:建立合适的映射表，然后对一个字符和两个字符的时候进行特殊讨论. // 设信源可能输出的符号是a, b, c 三个字母，构成一个二阶Markov信源，且各阶条件概率如下，// 试编写程序可以对任意字母序列（如abbcabcb）进行基于上下文的自适应算术编码，并进行相应的译码。/// 经过研究发现，长度变长的时候会出现不相等的情况，分析得知，是因为算法本身的概率选取的调整问题double tp = 0.01be + 0.99*end;// 选取时应该把tp调整到大区间段(个人猜测，不会证明，但可以写一个循环自动化调参训练…当在某个长度(input)上面达到某个精度的时候输出参数)// input : length 先建立 length 长的全 a 序列, length重循环 最后一个从 a+0到+1到+2(最内层),每个外层一变化都要变化一次,O(3^length)指数爆炸for(double i=0.01;i]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[儒家修身之道 - 2019春期中考试答案]]></title>
    <url>%2F2019%2F05%2F03%2F%E5%84%92%E5%AE%B6%E4%BF%AE%E8%BA%AB%E4%B9%8B%E9%81%93-2019%E6%98%A5%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95%E7%AD%94%E6%A1%88%2F</url>
    <content type="text"><![CDATA[儒家修身之道 - 2019春期中考试答案 我自己找资料写了两个半小时左右，希望这些答案能帮到你们节约时间以及拿到满分 合肥工业大学慕课平台_学生端_files下载 合肥工业大学慕课平台_学生端下载 下载之后再打开体验更佳 使用说明： 1. 可以直接网页浏览第二个文件，体验很差2. 下载两个文件放到同一个目录下面，解压缩第一个文件到当前目录，然后用谷歌打开html文件即可]]></content>
      <categories>
        <category>总有一些事值得</category>
      </categories>
      <tags>
        <tag>总有一些事值得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第一周(1/521)]]></title>
    <url>%2F2019%2F04%2F27%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC%E4%B8%80%E5%91%A8-1-521%2F</url>
    <content type="text"><![CDATA[ARST打卡第一周(1/521) Algorithm: 自己在github上面打卡，LeetCode还是第一次做，和以前在其他平台做的题不太一样，它只要提交一个cpp的solve类就行： 第一题LeetCode​github.com 除了LeetCode的刷题，自己也有坚持字符串等的刷题，只是本周前段时间忙着做一个比赛的项目导致自己前几天都没有时间刷题(emmmm). Review: 平常不怎么关注英文技术文章，所以第一次还找了很多个网站进行尝试（最终看了群里小伙伴的打卡的review文章），所以第一次是读简单一点的文章，以后慢慢把难度提升上去 The Key To Accelerating Your Coding Skills http://blog.thefirehoseproject.com/posts/learn-to-code-and-be-self-reliant/ 1.Become self-reliant. Having the ability to learn new coding skills without structured guidance means you no longer need to wait for anyone to help you out. This means that for the majority of what you need to learn, you can simply search the internet and read the various material on what you need to know. This doesn’t mean you immediately “know” everything, but just that everything is now “figure-out-able,” so in essence, you are unstoppable. 2.Work consistently, but don’t overwork yourself. At this phase of the game, know that you can only be productive for around 6 hours a day at the most. Working in an exhausted state will only prolong the time you spend building up to the inflection point. 自己感触很深的两个点在摘抄在上面了 1.其实有时候遇到了技术问题是很好找前辈帮忙解决的，因为有很多坑前辈们都是一步步走过来的，所以就能很快的看出你的错误并且帮你纠正，但是我个人觉得有些必须自己去亲身体验，自己去努力查资料，自己努力去想的，不到迫不得已不去打扰大神，因为这样自己才能对自己遇到的问题有清析的认识，并且在以后一般不会再出现这种问题，而且自己也能在相似的事件处理上做的更好，从而锻炼了自己真正的解决问题的能力。 2.对于第二点自己有切身的体会，因为自己经常进行算法训练，有时候状态很好，一下子就能写出思路和代码，有时候很累的时候，半天想不出思路，而且就算想出了一些常规的思路，但是在很累的时候写出来的基本上都是bug，等到状态好一点的时候再把bug改回来，或者彻底推翻重写，真的是浪费了时间，又没有好好休息，从而延长了自己积累到拐点的时间。 Tip：(学习一个技术技巧) 如何在Debian 9上安装和使用Docker​https://www.howtoing.com/how-to-install-and-use-docker-on-debian-9 Share： Android开发---如何在assets文件下只播放一首歌 环境：项目需要嵌入多个音频文件 问题: 1.使用assets播放音频的时候用固定的套路会把整个文件播放完， 2.用R.raw.MusicName无法在某些类中使用(应该是我Java太菜了，所以在要调用的那个类中不能用R.raw.MusicName) 解决方案：对着函数按ctrl+左键查看setDataSource函数 可以看到length参数，如果按照一般使用setDataSource的方法，我们会使用fileDescriptor.getStartOffset()用来赋值给length，那么这样就会在语音播报的时候播报整个assets文件夹下面的音乐 &lt;p&gt;而且看@param说明可以知道length的单位是字节，所以我采用了一个笨办法，就是依次查看每一首歌的长度，从而得到了参数值，然后写成selectSong()函数(耗子叔说要利用自己的计算机思维，多做自动化工作)，然后完成调用。巧妙地解决了自己的项目需求。&lt;/p&gt; // 按ctrl+左键查看setDataSource函数 /** * Sets the data source (FileDescriptor) to use. The FileDescriptor must be * seekable (N.B. a LocalSocket is not seekable). It is the caller&#39;s responsibility * to close the file descriptor. It is safe to do so as soon as this call returns. * * @param fd the FileDescriptor for the file you want to play * @param offset the offset into the file where the data to be played starts, in bytes * @param length the length in bytes of the data to be played * @throws IllegalStateException if it is called in an invalid state * @throws IllegalArgumentException if fd is not a valid FileDescriptor * @throws IOException if fd can not be read */ public void setDataSource(FileDescriptor fd, long offset, long length) throws IOException, IllegalArgumentException, IllegalStateException { _setDataSource(fd, offset, length); } // 调用的地方AssetManager assetManager;MediaPlayer player = null;player = new MediaPlayer();assetManager = getResources().getAssets();try { String song = “”; int [] k={0}; song += selectSong(flag,k); AssetFileDescriptor fileDescriptor = assetManager.openFd(song);// player.setDataSource(fileDescriptor.getFileDescriptor(), fileDescriptor.getStartOffset(), fileDescriptor.getStartOffset()); player.setDataSource(fileDescriptor.getFileDescriptor(), fileDescriptor.getStartOffset(),k[0]); player.prepare(); player.start();} catch (IOException e) { e.printStackTrace();} // 支持函数private String selectSong(char c,int[] k) { String song = “”; if(c==’a’) { song += “不要露出您的牙齿哟.mp3”;//6408 k[0] = 6408; } else if(c==’b’) { song += “嘴角微微上扬O.mp3”;//5616 k[0] = 5616; } else if(c==’c’) { song += “恭喜你成功习得笑不露齿.mp3”; k[0]=5976; } else if(c==’d’) { song +=”咧开嘴巴开心大笑.mp3”;//4464 k[0] = 4464; } else if(c==’e’) { song +=”不妨笑的更快乐一点.mp3”;//6624 k[0] = 6624; } else if(c==’f’) { song +=”今天的大笑完成了哦.mp3”;//4752 k[0] = 4752; } else if(c==’g’) { song +=”左眼闭紧哟.mp3”;//3528 k[0] = 3528; } else if(c==’h’) { song +=”右眼瞪大点.mp3”;//3384 k[0] = 3384; } else if(c==’i’) { song +=”太好了，得到了一张俏皮图.mp3”;//6624 k[0] = 6624; } else if(c==’j’) { song +=”右眼闭紧哟.mp3”;//3024 k[0] = 3024; } else if(c==’k’) { song +=”左眼瞪大点.mp3”;//3528 k[0] = 3528; } else if(c==’l’) { song +=”哟，我有被你电到哦.mp3”;//4896 k[0] = 4896; } else if(c==’m’) { song +=”张大嘴巴“O”一声.mp3”;//5616 k[0] = 5616; } else if(c==’n’) { song +=”眼睛瞪圆圆.mp3”;//3384 k[0] = 3384; } else if(c==’o’) { song +=”惊讶表情图获取了哟.mp3”;//5472 k[0] = 5472; } return song; }&lt;/pre&gt; 项目图片 查看属性，得到字节大小 感想： 1. 感觉在知乎写文章的体验十分好(对比以前自己在简书和CSDN的写作体验) 2. Review读文章感觉自己英语水平很差劲，然后读久了感觉有点累，所以得多练习 3. 自己都20多的人了，还只是学了计算机领域的一点点皮毛，而且感觉这个ARST打卡很锻炼自己，也符合自己要成为一个技术专家(将来解决计算界的一些难题)的理想，所以决定把这个每周打卡进行10年，也就是365/7*10=521周，现在是第一周(猛地发现原来十年是个如此浪漫的数字)]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年如何注册谷歌账号]]></title>
    <url>%2F2019%2F03%2F24%2F2019%E5%B9%B4%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E8%B0%B7%E6%AD%8C%E8%B4%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[2019年如何注册谷歌账号 现在谷歌账号注册对中国区用户很不友好，你如果用电脑端去网页注册，那么你的手机号不管注册过没有，你很大几率得到的是下图 无法验证 小编在各大网站平台摸爬滚打2个小时，终于找到了解决方案： 通过手机连上vpn，然后用APKPure下载Gmail 1.vpn：使用superVPN等，自行下载吧(因为这里不能传apk文件啊) （自行网上下载） 2.有了VPN肯定能下载APKPure和Gmail，所以go on下一步---注册的大正题 进入Gmail，然后依次 点击添加用户 Google 等待核对信息 然后点创建账号 然后就可以正常用刚刚在网页端报错的手机号 创建Google账号了 之后就可以开心地用 网页端登入谷歌账号了啊 happy 结语：现在很多人用卖谷歌账号赚钱，更有甚者给出错误教程，然后说别人操作不对，让别人给他转100块再帮别人创建账号，我觉得这是真的黑啊 所以想避免以后“搞机”（软硬件等）路上不被黑， 就收藏小编的网站：wolfdan.cn]]></content>
      <categories>
        <category>有些事情总是值得</category>
      </categories>
      <tags>
        <tag>有些事情总是值得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑手机端同步的电子阅读器]]></title>
    <url>%2F2019%2F02%2F14%2F%E7%94%B5%E8%84%91%E6%89%8B%E6%9C%BA%E7%AB%AF%E5%90%8C%E6%AD%A5%E7%9A%84%E7%94%B5%E5%AD%90%E9%98%85%E8%AF%BB%E5%99%A8%2F</url>
    <content type="text"><![CDATA[此文由来和自我想法（可跳过） 今天给大家推荐一个自己找了比较久的的电子阅读器，为什么我要推荐一个电脑手机端同步的阅读器呢？ 手机端移动使用 和 电脑端长时间护眼+快速笔记+浏览使用流行的 掌阅 和 网易蜗牛阅读 都是我用得比较久的两款阅读器，但是无奈没有多端同步，加上自己想用电脑看书，找了很久才找到，觉得一定有人和我有相同需求，于是分享给大家 进入分享正文 这款软件就是 京东阅读 然后 上图说话 声明：本人非京东员工，仅一个热心分享 京东读书 2.云同步演示（实现京东读书手机端电脑端书籍同步（此软件比起友商的稀有之处）） 上传 于是乎 成功 nice 兄弟，来愉快地阅读吧]]></content>
      <categories>
        <category>总有一些事值得</category>
      </categories>
      <tags>
        <tag>总有一些事值得</tag>
      </tags>
  </entry>
</search>
