<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法日常[11/100]]]></title>
    <url>%2F2019%2F08%2F16%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-11-100%2F</url>
    <content type="text"><![CDATA[组合数学思维题题目链接2019牛客多校9 E题 题解思路其实解法一二的本质内核是一样的，可以都看一下 解法一当合并这两个集合的时候，应该将这两个集合合并后消失的贡献减去消失的贡献就应该是选择了一个a，选择了一个b，从剩下的众多集合中选择两个(即cd,ce,ef……)那么这个怎么算呢，可以用完全平方公式来推导(a+b+c+d)^2=a^2+b^2+c^2+d^2+2ab+2ac+2bc+2ad+2bd+2cd所以众多集合中选择任意选择两个的情况可以用（和的平方-平方的和）/2来求（最重要的一步） 解法二 AC代码解法一代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using ll = long long;const int MAXN = 100010;int n, m;int f[MAXN], sz[MAXN];ll sum;inline ll sqr(int x) &#123; return 1ll * x * x;&#125;inline int getf(int x) &#123; return f[x] == x ? x : (f[x] = getf(f[x]));&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); ll ans = (__int128) n * (n - 1) * (n - 2) * (n - 3) / 24; printf("%lld\n", ans); for (int i = 1; i &lt;= n; ++i) &#123; f[i] = i; sz[i] = 1; &#125; /*最开始的平方和*/ sum = n; while (m--) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); u = getf(u); v = getf(v); if(ans==0 || u==v) goto END; if (u != v) &#123; /*减掉合并部分的平方和*/ sum -= sqr(sz[u]) + sqr(sz[v]); /*后面的(sqr(n - sz[u] - sz[v]) - sum) / 2;就是`和的平方`-`平方和`=`剩下的所有两两组合`*/ ll tmp = 1ll * sz[u] * sz[v] * (sqr(n - sz[u] - sz[v]) - sum) / 2; f[u] = v; sz[v] += sz[u]; /*新的平方和的维护*/ sum += sqr(sz[v]); /*减去合并减少的贡献值*/ ans -= tmp; &#125; END: printf("%lld\n", ans); &#125; return 0;&#125; 解法二代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod = 1e9 + 7;const int inf = 0x3f3f3f3f;const int maxn = 100000 + 5;ll C[maxn][5];int p[maxn], sz[maxn], cnt[maxn];int n, m;ll ans;set&lt;int&gt; st;inline void init() &#123; for(int i = 0; i &lt; maxn; i++) C[i][0] = 1; for(int i = 1; i &lt; maxn; i++) &#123; for(int j = 1; j &lt; 5; j++) &#123; C[i][j] = C[i-1][j] + C[i-1][j-1]; &#125; &#125;&#125;inline int Find(int x) &#123; return x == p[x] ? x : p[x] = Find(p[x]); &#125;inline void Union(int x, int y) &#123; int fx = Find(x), fy = Find(y); if(fx != fy) &#123; if(fx &gt; fy) swap(fx, fy); p[fx] = fy; ll tp = C[n-sz[fx]-sz[fy]][2]; for(auto i : st) &#123; tp -= C[i][2]*cnt[i]; &#125; tp += C[sz[fx]][2]+C[sz[fy]][2]; if(tp &gt; 0) ans -= 1LL*sz[fx]*sz[fy]*tp; cnt[sz[fx]]--; cnt[sz[fy]]--; if(cnt[sz[fx]] == 0) st.erase(sz[fx]); if(cnt[sz[fy]] == 0) st.erase(sz[fy]); sz[fy] += sz[fx]; cnt[sz[fy]]++; st.insert(sz[fy]); &#125;&#125;int main() &#123; init(); scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; p[i] = i; sz[i] = 1; &#125; cnt[1] = n; st.insert(1); ans = C[n][4]; printf("%lld\n", ans); while(m--) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); Union(u, v); printf("%lld\n", ans); &#125; return 0;&#125; 每天一句叨叨生活总是很奇妙，我们到底该去向何方？ 世俗的成功吗？还是当下的快乐呢？ 珍惜身边的人呢？还是继续寻找？]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>狼胆带你每天头铁一题</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折半搜索_算法日常[10/521]]]></title>
    <url>%2F2019%2F08%2F15%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-10-521%2F</url>
    <content type="text"><![CDATA[题目题目链接2019牛客多校9 D题 题解折半搜索,详见下面的算法推荐和下面的AC的代码 meet-in-middle AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod = 1e9 + 7;const int inf = 0x3f3f3f3f;const int maxn = 1e6;struct node &#123; ll v; int id; bool operator &lt; (const node&amp; r) const &#123; return v &lt; r.v; &#125;&#125;b[maxn];ll arr[40];ll a[maxn], c[maxn];int main() &#123; int n; ll sum; scanf("%d%lld", &amp;n, &amp;sum); for(int i = 0; i &lt; n; i++) scanf("%lld", &amp;arr[i]); int x = n/2, y = n-x; int up1 = (1&lt;&lt;x), up2 = (1&lt;&lt;y); /*全0到全1串的遍历，然后之后是对每个串的逐位遍历，记录此串的和值*/ for(int i = 0; i &lt; up1; i++) &#123; for(int j = 0; j &lt; x; j++) &#123; if(i &amp; (1&lt;&lt;j)) a[i] += arr[j]; &#125; &#125; for(int i = 0; i &lt; up2; i++) &#123; b[i].id = i; b[i].v = 0; for(int j = 0; j &lt; y; j++) &#123; if(i &amp; (1&lt;&lt;j)) b[i].v += arr[x+j]; &#125; &#125; /*让B[i]数组有序，然后使用lower_bound去搜索*/ sort(b, b+up2); for(int i = 0; i &lt; up2; i++) c[i] = b[i].v; /*这里复杂度是2^18*log(2^18) = 4.7*10^6左右*/ for(int i = 0; i &lt; up1; i++) &#123; int p = lower_bound(c, c+up2, sum-a[i])-c; if(c[p]+a[i] == sum) &#123; for(int j = 0; j &lt; x; j++) &#123; if(i &amp; (1&lt;&lt;j)) printf("1"); else printf("0"); &#125; int id = b[p].id; for(int j = 0; j &lt; y; j++) &#123; if(id &amp; (1&lt;&lt;j)) printf("1"); else printf("0"); &#125; break; &#125; &#125; return 0;&#125; 每天叨叨一句“我不同意你， 但我可以支持你”李开复原来是学法律的，但他爱好计算机，后来师从美国卡内基梅隆大学计算机学院院长罗杰·瑞迪。 罗杰非常喜欢李开复，把自己的知识毫无保留地传授给李开复，使得他在编程水平突飞猛进。但随着研究的深入，李开复与导师有了分歧，尤其是在计算机语音识别系统研究时，罗杰主张用传统的方法，可是李开复却想从另一个方向，这悖离了主流，有别于大多数语音技术同行。怎么办？导师给李开复指出来了，让他“悬崖勒马”。可是李开复还是想按照自己的想法做。 有不少关系李开复的好心人提醒他：“你在计算机领域还乳臭未干，人家罗杰是美国国家工程学院和美国艺术与科学学院院士，你听导师的，可以少走弯路。”可是李开复却说：“我想另辟溪径。”“可是这样会得罪导师，如果得不到他的支持，你可能寸步难行。你另搞一套，如果成了，让他多没面子。相反你顺从了他，他是总统特别顾问委员会信息委员会成员、‘图灵奖’获得者，有他的提携，将来前途不可限量。”可是那时的李开复没想那么复杂，还是决定走自己的路。 没想到，尽管导师批评了李开复几次，可是李开复一意孤行。罗杰说：“作为科学家，我也不是全知全能。我不同意你的看法，但我可以支持你。”这让李开复非常意外。 此后，李开复就放开手脚大干起来。不久，罗杰又来问李开复：“有没有什么困难？”“暂时没有。”“如果有什么需要我帮助的，尽管说啊。”李开复反问道：“你不生我的气啊？”“‘不认同’不等于‘不支持’。”罗杰说。 参考链接http://blog.sina.com.cn/s/blog_98acb6e70102w95o.html]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>狼胆带你每天头铁一题</tag>
        <tag>折半搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10进制矩阵快速幂-狼胆带你每天头铁一题-算法日常[9/100]]]></title>
    <url>%2F2019%2F08%2F14%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-9-100%2F</url>
    <content type="text"><![CDATA[头铁来源因为狼胆小编本人比较垃圾，所以只能每天带大家头铁一题简单常识题(大佬眼中的常识，我这个蒟蒻还只能头铁)，希望能帮助到小白，那就很开心了 题目题目链接2019牛客多校5 B题 题解理想中的草稿状态 真实的草稿状态 dreammoon大佬的官方的题解也可以看看 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;typedef unsigned long long ULL;const int SIZE = 3000010;ULL MOD;char s[SIZE];/*矩阵相乘，第一行乘以第一列，第一行乘以第二列……也可以使用for两重循环求*/void mul(ULL* c1, ULL* c2, ULL *res)&#123; res[0] = (c1[0] * c2[0] + c1[1] * c2[2]) % MOD; res[1] = (c1[0] * c2[1] + c1[1] * c2[3]) % MOD; res[2] = (c1[2] * c2[0] + c1[3] * c2[2]) % MOD; res[3] = (c1[3] * c2[3] + c1[2] * c2[1]) % MOD;&#125;int main() &#123; int a,b; int x1,x2; scanf("%d%d%d%d", &amp;x1, &amp;x2, &amp;a, &amp;b); scanf("%s%llu",s, &amp;MOD); int len = 0; /* 统计长度，并且把个位的值(即最后一位的值)减去1 */ for(; s[len]; len++); s[len-1]--; /* 个位减掉了之后向前面借位 */ for(int i = len - 1; i &gt;= 0 &amp;&amp; s[i] &lt; '0'; i--)&#123; s[i] = '9'; s[i-1]--; &#125; ULL now0 = x1, now1 = x2; ULL d[4][4]; d[0][0] = 0; d[0][1] = 1; d[0][2] = b; d[0][3] = a; for(int it = len - 1; it &gt;= 0; it--)&#123; memset(d[1], 0, sizeof(ULL) * 12); /*A "常数"矩阵相乘4次*/ for(int p = 1; p &lt; 4; p++)&#123; mul(d[p-1], d[p-1], d[p]); &#125; s[it] -= '0'; for(int p = 0; p &lt; 4; p++)&#123; if((s[it] &gt;&gt; p) &amp; 1)&#123; ULL* ml = d[p]; std::tie(now0, now1) = std::make_pair((ml[0] * now0 + ml[1] * now1) % MOD,(ml[2] * now0 + ml[3] * now1) % MOD); &#125; &#125; mul(d[1], d[3], d[0]); &#125; printf("%llu\n", now1); return 0;&#125; 少量知识点tie pair是tuple的一个子集 每天一句叨叨今天看到一禅小和尚: 我们尝遍生活的苦，却都只是为了过好平凡的一生 但我觉得如果自己明知道人生是苦，明知道人是基因的机器人(参见算法日常4的叨叨)，却认认认真真地选择好好生活，这就是一种伟大，这就是自由，这就是自己的突破，就是自己的英雄！]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>狼胆带你每天头铁一题</tag>
        <tag>数学</tag>
        <tag>矩阵快速幂</tag>
        <tag>10进制矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[银联挑战赛复赛A,B题_算法日常[8/100]]]></title>
    <url>%2F2019%2F08%2F13%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-8-100%2F</url>
    <content type="text"><![CDATA[缘起8月10号是计算机设计大赛决赛答辩的最后一天，这天下午是牛客多校8，晚上是银联挑战赛复赛，队友出去吃吃喝喝了，我点个外卖，打着比赛，然后第一题就卡住不会做，然后自闭了，果然银联的比赛很重视数学题啊啊啊，是我数学题没怎么练，太菜了—&gt;所以菜导致既没有吃到好东西，又导致爆零没太多收获，所以还是需要多多努力 A题爱喝「肥宅快乐水」的班长爱喝「肥宅快乐水」的班长 题目解法 看不懂的知识链接隔板法 扩展的隔板法中： 转化前的空盒 == 转化后每个盒子至少放一个 AC代码1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=1000000007;const int inf = 0x3f3f3f3f;const int M = 2e3+7;int C[M][M];int T,n,m;void add(ll &amp;a,ll v)&#123; a += v; if(a &gt;= mod) a-=mod;&#125;void pre()&#123; for(int i=0;i&lt;M;i++)&#123; C[i][0]=1; for(int j=1;j&lt;=i;j++)&#123; C[i][j]=C[i-1][j-1]+C[i-1][j]; if(C[i][j]&gt;=mod) C[i][j]-=mod; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false);cin.tie(0); cin&gt;&gt;T; pre(); while(T--)&#123; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;C[n+m-2][m-1]&lt;&lt;endl; &#125; return 0;&#125; B题整数对整数对 题目解法 AC代码1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll T,n,m,p,ans;int main()&#123; ios::sync_with_stdio(false);cin.tie(0); cin&gt;&gt;T; while(T--)&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;p; ans = 0; ll x = n/p; for(ll r = 0; r &lt; p ; r++ )&#123; /*求出b的种类数*/ ll bn = m/(p/__gcd(r,p)); /*分别对应题解的1,2,3种情况,其实1,3可以合并*/ if(!r) ans+=x*bn; else if(0&lt;r &amp;&amp; r&lt;=n%p) ans+=(x+1)*bn; else ans+=x*bn; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 每天一句叨叨人心的成见如同一座大山，我们总是口上说不能有偏见，其实真正的内心想法却不是这样的… 所以我对别人的偏见，我只能尽量克制，让自己理性对待，然后做之不止，乃成君子 对于别人对自己的偏见不要在意，而是要专注自己的目标 感觉自己生来就有一种追求挑战的血液，在小时候尤为明显，但是感觉在长久的教化过程中削弱了，所以我想要找回本真，生命不息，战斗不止，和天生的不公斗到底，做自己的英雄]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>组合数学</tag>
        <tag>隔板法</tag>
        <tag>数学思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第16周[16/521]]]></title>
    <url>%2F2019%2F08%2F11%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC16%E5%91%A8-16-521%2F</url>
    <content type="text"><![CDATA[Algorithm牛客多校8的签到 ReviewBeing Happy Is Hard Work好多生词啊，所以决定开始背单词Happiness, in other words, is practiced. Tips打算法比赛一定要熟练使用线段树啊，血的教训 Share2019杭电多校1006和1007算法日常[4/100] 后缀数组-算法学习日常[5/100] 2019杭电多校6_1005算法日常[6/100] 2019牛客多校8_B题算法日常[7/100] 每天一句叨叨生活总有太多的美好无法用相机记录下来，所以那就给每一个当下投以最好的微笑吧]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客多校8_B题算法日常[7/100]]]></title>
    <url>%2F2019%2F08%2F11%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-7-100%2F</url>
    <content type="text"><![CDATA[题目题目链接以及描述2019牛客多校8_B题 题意以及思路 AC代码1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100000 + 5;int a[maxn], b[maxn], c[maxn];int main() &#123; int n; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); /*c[i]记录的是a[i]的上一个位置加1的位置*/ c[i] = b[a[i]]+1; b[a[i]] = i; &#125; ll ans = 0; for(int i = 1; i &lt;= n; i++) &#123; ans += 1LL*(n-i+1)*(i-c[i]+1); &#125; printf("%lld\n", ans); return 0;&#125; 每日一句叨叨但求精进,无问西东]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019杭电多校6_1005算法日常[6/100]]]></title>
    <url>%2F2019%2F08%2F07%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-6-100%2F</url>
    <content type="text"><![CDATA[题目题目链接2019杭电多校6_1005_HDU6638 思路自己一开想偏了，想着像以前0,1矩阵那种同权值点一样叠加成为矩形的最大面积来求解，这样子就能让复杂度在O(n^2)的样子 然后并非如此，这里的权值w是一个可正可负的整数…自己隐隐约约地感觉复杂度要达到O(n^2*log(n)),但是没有往下想，虽然想了也不一定会,,,emmmm,继续努力吧 正解 首先将纵坐标离散化到 O(n) 的范围内，方便后续的处理。 将所有点按照横坐标排序，枚举矩形的上边界，然后往后依次加入每个点，这样就确定了矩形的上下边界。 设 v[y] 表示矩形内部纵坐标为 y 的点的权值和，则答案为 v 的最大子段和，用线段树维护带修改的最大子段和即可。 时间复杂度 O(n^2*log(n)) std理解版今天比较晚了，明天要出一趟远门，所以暂时没有手写，对不起自己啊，等回家一定要好好把这个重新写几遍 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int N=2010,M=4100;int Case,n,m,i,j,k,cb,b[N],pos[N];ll pre[M],suf[M],s[M],v[M],ans;struct E&#123;int x,y,z;&#125;e[N];inline bool cmp(const E&amp;a,const E&amp;b)&#123;return a.x&lt;b.x;&#125;/*用纵坐标建的线段树，大佬对于线段树的理解以及如同我对1+1的理解一样了！*/void build(int x,int a,int b)&#123; pre[x]=suf[x]=s[x]=v[x]=0; if(a==b)&#123; pos[a]=x; return; &#125; int mid=(a+b)&gt;&gt;1; build(x&lt;&lt;1,a,mid),build(x&lt;&lt;1|1,mid+1,b);&#125;inline void change(int x,int p)&#123; x=pos[x]; s[x]+=p; if(s[x]&gt;0)pre[x]=suf[x]=v[x]=s[x];else pre[x]=suf[x]=v[x]=0; /*上传的操作精辟,orz*/ for(x&gt;&gt;=1;x;x&gt;&gt;=1)&#123; /*根的左边的 = max(左子树之前的,左子树+右子树之前的)*/ pre[x]=max(pre[x&lt;&lt;1],s[x&lt;&lt;1]+pre[x&lt;&lt;1|1]); /*根的右边的 = max(右子树右边的,右子树+左子树右边的)*/ suf[x]=max(suf[x&lt;&lt;1|1],s[x&lt;&lt;1|1]+suf[x&lt;&lt;1]); /*s是直接叠加的*/ s[x]=s[x&lt;&lt;1]+s[x&lt;&lt;1|1]; /*区间最大值 = max(左子树最大,右子树最大,左子树后面的+左子树前面的)*/ v[x]=max(max(v[x&lt;&lt;1],v[x&lt;&lt;1|1]),suf[x&lt;&lt;1]+pre[x&lt;&lt;1|1]); &#125;&#125;int main()&#123; scanf("%d",&amp;Case); while(Case--)&#123; scanf("%d",&amp;n); for(cb=0,i=1;i&lt;=n;i++)&#123; scanf("%d%d%d",&amp;e[i].x,&amp;e[i].y,&amp;e[i].z); b[++cb]=e[i].y; &#125; /*离散化纵坐标*/ sort(b+1,b+cb+1); for(m=0,i=1;i&lt;=cb;i++)if(i==1||b[i]!=b[m])b[++m]=b[i]; /*给横坐标排序*/ sort(e+1,e+n+1,cmp); ans=0; /*用离散化后的纵坐标覆盖掉原来的纵坐标*/ for(i=1;i&lt;=n;i++)e[i].y=lower_bound(b+1,b+m+1,e[i].y)-b; /*枚举上边界，x是行号，是上边界*/ for(i=1;i&lt;=n;i++)if(i==1||e[i].x!=e[i-1].x)&#123; build(1,1,m); /*加入点确定好下边界，这样上下边界都确定好了*/ for(j=i;j&lt;=n;j=k)&#123; /*又是逐步插入空树维护区间最大值的操作*/ for(k=j;k&lt;=n&amp;&amp;e[j].x==e[k].x;k++)change(e[k].y,e[k].z); if(ans&lt;v[1])ans=v[1]; &#125; &#125; printf("%lld\n",ans); &#125;&#125; 每天一句叨叨今天是情人节，然而…没得女朋友…不过有队友和我一起大杭电多校还是很开心的啦(还是有点点失落) 虽然 但是谁终将声震人间，必长久深自缄默 谁终将点燃闪电，必长久如云漂泊 全力以赴打完这一段时光的退役赛一定会是一个大学乃至人生最珍贵的记忆，所以这段时间先不要让自己被一个体内的激素控制，等时机到了，一定会更加美好！加油吧，少年！]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>线段树</tag>
        <tag>算法学习日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组-算法学习日常[5/100]]]></title>
    <url>%2F2019%2F08%2F06%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8-5-100%2F</url>
    <content type="text"><![CDATA[后缀数组论文分享后缀数组论文分享 每天一句叨叨人一能之，己百之；人十能之，己千之。果能此道矣，虽愚必明，虽柔必强。]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019杭电多校1006和1007算法日常[4/100]]]></title>
    <url>%2F2019%2F08%2F05%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-4-100%2F</url>
    <content type="text"><![CDATA[序 今天是杭电多校第5场，然后1006签到本来应该10mins内写完，然后我菜鸡写了2小时(各种问题不熟练和紧张)，赛后发现有大佬用dc3(一种据说复杂度O(n)的后缀数组算法,发现自己孤陋寡闻) 1007真滴有趣…闪电蛇皮走位，然后自己想复杂了一点点… 题目链接2019杭电多校5 1006解法Ekmp，用s.substr(1)的串来做ekmp函数的原串，s做ekmp函数的匹配串，这样跑一次ekmp就行，然后累加extend ekmp学习教程·我觉得比较好的一个(我也用这个学的) AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;long long ans;// int next[1000000];int nxt[1000000];int extend[1000000];string S, T;int n, m;/* 求解 T 中 next[]，注释参考 GetExtend() */void GetNext(string &amp; T, int &amp; m, int next[])&#123; int a = 0, p = 0; next[0] = m; for (int i = 1; i &lt; m; i++) &#123; if (i &gt;= p || i + next[i - a] &gt;= p) &#123; if (i &gt;= p) p = i; while (p &lt; m &amp;&amp; T[p] == T[p - i]) p++; next[i] = p - i; a = i; &#125; else next[i] = next[i - a]; &#125;&#125;/* 求解 extend[] */void GetExtend(string &amp; S, int &amp; n, string &amp; T, int &amp; m, int extend[], int next[])&#123; int a = 0, p = 0; GetNext(T, m, next); for (int i = 0; i &lt; n; i++) &#123; if (i &gt;= p || i + next[i - a] &gt;= p) // i &gt;= p 的作用：举个典型例子，S 和 T 无一字符相同 &#123; if (i &gt;= p) p = i; while (p &lt; n &amp;&amp; p - i &lt; m &amp;&amp; S[p] == T[p - i]) p++; extend[i] = p - i; a = i; &#125; else extend[i] = next[i - a]; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); int t; cin&gt;&gt;t; while(t--)&#123; ans = 0; cin&gt;&gt;S; n = S.size(); T = S.substr(1); m = n - 1; /*可能程序以为我用了前面的函数声明中的next[],所以说我模棱两可,加个全局的命名空间就行 或者换个变量名也行*/ // GetExtend(T, m, S, n, extend, ::next); GetExtend(T, m, S, n, extend, nxt); for (int j = 0; j &lt; m; j++)&#123; // cout &lt;&lt; extend[j] &lt;&lt; " \n"[j==m-1]; ans += extend[j]+j==n-1 ? extend[j] : extend[j]+1 ; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 1007解法法一a[i] = a[i-1]+a[i-3],就是对于第i项有两种情况，要么是直接往上走要么是闪电 法二dls说暴力打表找规律比较不用动脑子，哭了，臭大佬，好过分 AC代码123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 998244353;const int inf = 0x3f3f3f3f;const int maxn = 100000 + 5;ll a[maxn];int main() &#123; a[1] = a[2] = a[3] = 1; for(int i = 4; i &lt; maxn; i++) a[i] = (a[i-1]+a[i-3])%mod; int T; scanf("%d", &amp;T); while(T--) &#123; int n, l, r; scanf("%d%d%d", &amp;n, &amp;l, &amp;r); if(l &gt; r) swap(l, r); if(l != 1) l++; if(r != n) r--; printf("%lld\n", a[r-l+1]); &#125; return 0;&#125; 注因为今天一直在听dls的直播，尽管后面的题听不懂，想听听dls一般解题思路是啥(其实后面听不懂就容易发呆了),所以今天还没有补很多题，然后就只写了这么一点点,我好弱啊 每天一句叨叨人总得有个目标，才能继续勇敢而坚强地活着，大部分成年人，在三十岁左右已经没了活着的目标，为了不让自己死去，他们制造了一个孩子，有了这个小孩，他们终于找到了努力工作和继续活下去的目标。 不，不是的，那是基因的谎言…让你这个机器人帮忙传递他们的存在 但如果你知道这是谎言，并决定真的要选择它，那才是真正的选择 教育本来就是不平等的，有些人很年轻就是OI金牌了，然而有些人还在发愁下次要怎么骗外公外婆我出去玩了，其实是偷偷跑去了网吧，如饥似渴地享受那几个小时的奥比岛，赛尔号，功夫派，洛克王国，地下城与勇士，英雄联盟…(从小学到高中渐渐变化的是游戏),然而别人早就享受到了算法的美妙，并将来很大程度能因此受到更好的教育，然后享受社会上最好的资源，过上幸福的生活，虽然我不能这样定义幸福，但是不平等确实存在，想要跨越社会阶层的鸿沟，可能要花上很久很久的努力.不过，我认为，跨越社会阶层的鸿沟，才是这个和平时代个人最英雄的挑战.做你自己的英雄，不断超越自己，并同时珍爱身边的人，过好这一生… 今天说的好像有点小多，叨叨叨多了，快滚去运动洗澡睡觉，明天继续来补题]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>ekmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python写字符串模拟真香_算法日常[3/100]]]></title>
    <url>%2F2019%2F08%2F04%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-3-100%2F</url>
    <content type="text"><![CDATA[题目链接2019牛客多校第6场B题 描述 解法解法一把8段中每段都处理成为一个整数,然后找出最长的连续0,相同的长度的话就让0放前面的段(因为0的ASCII码是48,比:的58小),然后进行判断性输出(数字用%x可以实现以16进制输出) 详见代码注释 C++版AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/*"%x"以16进制的形式输出,是我孤陋寡闻了*/#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int a[10];int main()&#123; int T,t; scanf("%d",&amp;T); for(int ii=1;ii&lt;=T;ii++)&#123; int f=0,l=0,nl=0; /*观察下面的代码容易知道,只有最前面为0的时候是f=1, 其他地方为0,f为i-nl(减掉了0的长度即为0开始的地方) 综上: f是最长连续0开始的位置 然后l是保存维护最长连续0的长度 nl是当前的最长连续0的长度*/ for(int i=1;i&lt;=8;i++)&#123; a[i]=0; for(int j=1;j&lt;=16;j++)&#123; scanf("%1d",&amp;t); a[i]=a[i]*2+t; &#125; if(!a[i]) nl++; else&#123; /*判断现在的连续0的数目是否超过之前的连续0的数目*/ if(nl&gt;=l&amp;&amp;nl&gt;1)&#123; f=i-nl;l=nl; &#125; nl=0; &#125; if(i==8&amp;&amp;nl&gt;1)&#123; if(nl&gt;l)&#123; f=i-nl+1;l=nl; &#125; /*末尾有0，但是末尾的连续0和最前面的连续0相同 所以考虑字典序最小，由于'0'-48,':'-58 所以优先让前面输出0,后面就输出':'*/ if(nl==l&amp;&amp;f==1)&#123; f=i-nl+1;l=nl; &#125; &#125; &#125; printf("Case #%d: ",ii); if(f==1)printf(":"); for(int i=1;i&lt;=8;i++)&#123; if(i==f)&#123; printf(":"); i+=l; &#125; if(i&gt;8)puts(""); else printf("%x%c",a[i],":\n"[i==8]); &#125; &#125; return 0;&#125; 解法二通过枚举每种有0的串，然后统一加到一个列表中，之后通过sort(优先长度然后优先字典序)，最后输出 详见我的Python注释代码 Python_AC代码12345678910111213141516171819T=int(input())for t in range(T): b=input() a=[] for i in range(8): # 这个[2:]是去掉'0x' a.append(hex(int(b[i*16:i*16+16],2))[2:]) s=[] s.append(':'.join(a)) for i in range(8): for j in range(i+1,8): # 对每个i中的后缀长a[i:j+1]判断各元素是否都是等于0的 # 是就直接把字符串丢进去,比C++AC版本中的记录长度简单很多 if all(map(lambda x:x=='0',a[i:j+1])): # 用':'分隔的a[i]串 s.append(':'.join(a[:i])+'::'+':'.join(a[j+1:])) # 优先用长度排序,其实是同长度按照字典序排序 s.sort(key=lambda x:(len(x),x)) print('Case #%d:'%(t+1),s[0]) 每天一句叨叨 岁月还漫长总会有人陪你骑马喝酒走四方]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>Python写算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第15周[15/521]]]></title>
    <url>%2F2019%2F08%2F04%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC15%E5%91%A8-15-521%2F</url>
    <content type="text"><![CDATA[Algorithm已经下定决心要努力刷题了，所以每天都有刷 ReviewChina Has Started a Grand Experiment in AI Education. It Could Reshape How the World Learns. 语句摘选 In three hours we understand students more than the three years spent by the best teachers. Three things have fueled China’s AI education boom. The first is tax breaks and other incentives for AI ventures that improve anything from student learning to teacher training to school management. For VCs, this means such ventures are good bets. According to one estimate, China led the way in over $1 billion invested globally last year in AI education. Second, academic competition in China is fierce. Ten million students a year take the college entrance exam, the gaokao. Your score determines whether and where you can study for a degree, and it’s seen as the biggest determinant of success for the rest of your life. Parents willingly pay for tutoring or anything else that helps their children get ahead. Finally, Chinese entrepreneurs have masses of data at their disposal to train and refine their algorithms.The population is vast, people’s views on data privacy are much more lax than in the West (especially if they can get coveted benefits like academic performance in return), and parents are big believers in the potential of technology, having seen how much it has transformed the country in just a few decades. Squirrel’s approach may yield great results on traditional education, but it doesn’t prepare students to be flexible in a changing world, the experts I spoke to say. “There’s a difference between adaptive learning and personalized learning,” says Chris Dede, a professor at Harvard University in the Technology, Innovation, and Education Program. Squirrel is doing adaptive learning, which is about “understanding exactly what students know and don’t know.” But it pays no attention to what they want to know or how they learn best. Personalized learning takes their interests and needs into account to “orchestrate the motivation and time for each student so they are able to make progress.” Much of Squirrel’s philosophy stems from Li’s own experiences as a child. When he was young, he didn’t have very good emotional intelligence, he says, and reading books on the subject didn’t help. So he spent half a year dividing the skill into 27 different components and trained himself on each one. He trained himself to be more observant, for example, and to be an interesting conversationalist (“I spent a lot of time finding 100 topics, so I have a lot of material to talk with others,” he says). He even trained himself to keep smiling when others criticized him. (“After that, in my life, I do not have any enemies.”) The method gave him the results he wanted — along with the firm belief that anything can be taught this way. That’s exactly what China lacks. If you are able to speak multiple languages, you are able to talk to different people; you are able to communicate different ideas感想 估计阅读时间是17mins，然而我抠脚的英语水平加上文章的深度和联想性让我看了整整一个小时 AI教学有很好的数据分析优势，计算机的快速处理数据能力，不分日夜地工作能力，都使得AI教学有很好的前景，只要不断地迭代分析数据的算法，一定可以让计算机拥有快速检测一个学生水平的能力，传统老师与计算机的差距在于经验的积累速度，不过对于单个知识点来说目前可能一个老师可能能给更好的帮助，所以我认为当下如果有AI算法辅助分析一个学生的水平，然后给针对的训练，再在个别的知识点上用上老师，那么可以大大降低对老师经验性的要求。因为我认为一个顶级老师和一个初级老师的区别仅在于对知识系统性的掌握以及对学生知识框架的快速认识能力上面(后者为主)，所以有了AI算法的辅助，将能降低家长花重金请名师的成本，而可以请一个初级老师+AI算法辅助的方式 感叹世界变化之快！ 感觉自己如果要成为认知层的上层人士，必须和世界进行连接，和更多的大师交流，那就必须学好英语，不然看一篇这样简单的文章要花上太久的时间…所以坚持好好学English！ Tips推荐一个OIwiki网站,内容很全面,分享给你们 Share线段树入门-AcWing-245-你能回答这些问题吗 priority-queue和multiset异同以及线段树空树插入维护初见 8数码和15数码算法结论和延展 拓扑排序以及C++读取空行[算法学习日常1/100] 反二分题的做法-算法日常[2/100] Python写字符串模拟真香_算法日常[3/100]]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反二分题的做法-算法日常[2/100]]]></title>
    <url>%2F2019%2F08%2F03%2F%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-2-100%2F</url>
    <content type="text"><![CDATA[序今天是个好日子，开局多校D看起来就是个简单的二分模拟,马上动手写起来啊！然后一直写到了比赛结束(当然中途看了一下其他题,并且给队友提供了j题的解题思路) 反二分的2019牛客多校6D题题目链接 哒哒马蹄终究是错因为这个题目终极不是正规的二分做法！因为答案根本不满足二分算法中的答案单调性，比如如下反例 1215 539 39 39 39 39 60 60 60 60 60 100 100 100 100 100 答案是199，而200不能是答案，201也不能是答案 (二分输出答案是216)(因为二分总是在较大数值的时候是满足的可能性极大的,所以二分后整体的结果偏大,其实有更小的答案漏掉了) 不过这题的美丽错误美就美在了它让人有种是二分的错误–(哒哒的马蹄，是个美丽的错误) 如何AC不过因为数据比较弱(其实造一个完美避开二分的数据几乎是不可能在题目数据范围实现的，如果可以，那我把二分后往小的方向开得更远一下枚举，根据上面分析为了避免小概率事件还可以多搞一下向大的方向也枚举)，所以我们现在可以有两种做法 先二分，然后在这个ans下继续向小的方向枚举20项 因为答案的下界和上界相差很小，可以直接枚举 二分再向小方向走1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/*因为数据弱，所以不满足单调性的时候这样这样来凑一手*/#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=1000000007;const int inf = 0x3f3f3f3f;const int M = 1e3+10;int T,n,K,v[M],sum,vis[M];bool check(int x)&#123; if(x*K&lt;sum || x&lt;v[n-1]) return false; if(x&gt;=v[n-1] &amp;&amp; K&gt;=n) return true; for(int i=0;i&lt;n;i++) vis[i]=0; int tmp=0,ts=sum; int i=1; while(ts&gt;0)&#123; int tps = 0; while(i&lt;=n &amp;&amp; vis[n-i]) i++; if(n-i&gt;=0) &#123; tps += v[n-i]; // cout&lt;&lt;"I get you! : "&lt;&lt;v[n-i]&lt;&lt;endl; vis[n-i]=1; &#125; else break; while(tps&lt;x)&#123; int tn = upper_bound(v,v+n-i,x-tps)-v; int j=1; while(j&lt;=tn &amp;&amp; vis[tn-j]) j++; if(tn-j&gt;=0) &#123; tps += v[tn-j]; // cout&lt;&lt;"I get you! : "&lt;&lt;v[tn-j]&lt;&lt;endl; vis[tn-j]=1; &#125; else break; &#125; // cout&lt;&lt;"How much is the tps "&lt;&lt;tps&lt;&lt;endl; ts -= tps; tmp++; &#125; if(tmp&gt;K) return false; return true;&#125;int main()&#123; ios::sync_with_stdio(false);cin.tie(0); cin&gt;&gt;T;int kase=1; while(T--)&#123; cin&gt;&gt;n&gt;&gt;K; sum = 0; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;v[i]; sum+=v[i]; &#125; sort(v,v+n); int l=1,r=1e6; while(l&lt;r) &#123; // cout&lt;&lt;"l: "&lt;&lt;l&lt;&lt;" r: "&lt;&lt;r&lt;&lt;endl; int mid = (l+r)&gt;&gt;1; if(check(mid)) r=mid;else l = mid+1; &#125; int ans = l; for(int i=ans;i&gt;=ans-20;i--) if(check(i)) ans = i; cout&lt;&lt;"Case #"&lt;&lt;kase++&lt;&lt;": "&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 正规做法-从下界开始枚举123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 代码来源--杭电的一个二人小分队 jesus#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N=1086;int v[N],vis[N];int n,k;bool check(int vv)&#123; int num=k; for(int i=0;i&lt;=n;i++)&#123; vis[i]=0; &#125; int left=n; int maxx=n,no=1; while(num)&#123; int sp=vv; for(int i=maxx;i&gt;0;i--)&#123; //如果当前剩余容量比最小的更小，不能继续装，退出循环 if(sp&lt;v[no])break; //如果当前剩余容量足够，并且物品i还没有装过，则装入 if(sp&gt;=v[i]&amp;&amp;!vis[i])&#123; sp=sp-v[i];vis[i]=1;left--; //如果无剩余，直接退出循环 if(!sp)break; &#125; &#125; //压缩下次寻找的范围 while(vis[maxx])maxx--; while(vis[no])no++; num--; &#125; //如果无剩余，则正好输出 if(!left)return 1; return 0;&#125;int main()&#123; int cases; scanf("%d",&amp;cases); for(int ti=1;ti&lt;=cases;ti++)&#123; scanf("%d%d",&amp;n,&amp;k); int sum=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;v[i]); sum+=v[i]; &#125; sort(v+1,v+n+1); int b=sum/k; if(sum%k)b++; int maxx=max(v[n],b); int ans=maxx; int i=maxx; while(i)&#123; if(check(i))&#123; ans=i;break; &#125; i++; &#125; printf("Case #%d: %d\n",ti,ans); &#125; return 0;&#125; 每天一句叨叨人生本来就是一场修行，人的基因把我们当做机器人，然后让我们为他们传递生命，所以给我们制造了很多激素，其中一些情绪激素让我们时而快乐时而悲伤，时而兴奋时而自闭，我们可能无法改变太多，唯有做的就是享受这个当机器人还能发发牢骚的快乐，并享受这一次人生的偶然，尽自己的快乐，去奋斗，去创造，因为平庸更使自己感到乏味…那就成为一个，不断进化，并快乐地享受其中的机器人吧]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>反二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序以及C++读取空行[算法学习日常1/100]]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%86%99%E5%B0%81%E6%83%85%E4%B9%A6%E7%BB%99%E7%AE%97%E6%B3%951%2F</url>
    <content type="text"><![CDATA[算法学习日常第一天2019年8月2日 今天上午，重新认识算法的全貌各种资源及知识点总结 并且还了解到了常见错误写法，当然自己当年也写过很多错误 下午先是补牛客5的多校G题的dp–接着昨天的补都补了90mins(含对着手写第一遍)，还是太菜了 然后补H题，发现自己昨天写了3个小时的这个题目不是字符串插入题…而是一个拓扑排序题..真的自己菜得可怕..写错分类怎么可能做对，然后自己又焦虑了很久，知道2019年8月2日15:48:15才静下来认真地学习拓扑排序 拓扑排序在紫书上学了下，就是把点对关系看成一个图里面的指向关系，即把每一个点对看做小数指向大数的有向边，如果图没有有向环的话，说明是可以的，否则是不行的 记自己头铁处理空行读入，搞了整整一个小时读取空行 拓扑排序以及空行头铁见代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/*2019年8月2日19:25:05拓扑排序bfs拓扑排序算法思想1、在AOV网络中选一个没有直接前驱的顶点, 并输出之;2、从图中删去该顶点, 同时删去所有它发出的有向边;---&gt;(我下面的题目使用stop实现删除)3、重复以上步骤, 直到◆ 全部顶点均已输出，拓扑有序序列形成，拓扑排序完成；◆ 或者图中还有未输出的顶点，但已跳出处理循环。这说明图中还剩下一些顶点，它们都有直接前驱，再也找不到没有前驱的顶点了。这时AOV网络中必定存在有向环。*/#include&lt;bits/stdc++.h&gt;using namespace std;const int M = 1e4+5;int n,m,lentmp;string s[10][10];/*用string本来可以不用下面的len*/int len[10][10];int it[10][10];string ans,t;bool check();bool solve();int main()&#123; ios::sync_with_stdio(false);cin.tie(0); cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m*(m-1)/2;i++)&#123; cin&gt;&gt;t&gt;&gt;lentmp; int x=t[0]-'a',y=t[1]-'a'; if(x&gt;y) swap(x,y); len[x][y] = lentmp; // if(lentmp) cin&gt;&gt;s[x][y]; /*我的头铁(~~比赛因此卡1小时去谷歌~~)写法 先直接用cin.get()吃掉t和lentmp后面的回车 再getline(), 否则getline会吃那个回车而导致少读数据*/ cin.get(); getline(cin,s[x][y]); &#125; if(!solve()) puts("-1"); return 0;&#125;/*暴力检测每队关系是否和整个串中的样子是一样的法二: 也可以每一对关系得到一个ans的tmp串,然后再去==判断 但是效率低*/bool check()&#123; for(int i=0;i&lt;m;i++)&#123; for(int j=i+1;j&lt;m;j++)&#123; int now = 0; for(int k=0;k&lt;n;k++)&#123; if(ans[k]=='a'+i||ans[k]=='a'+j)&#123; if(ans[k]!=s[i][j][now]) return 0; now++; &#125; &#125; if(now!=len[i][j]) return 0; &#125; &#125; return 1;&#125;bool solve()&#123; for(int i=0;i&lt;n;i++)&#123; /* 这里是每个大串的排序关系-通过m次的关系问询确定的 注意前面巧妙地处理出了j小于k---&gt;这就是拓扑排序的思路 1.对没有出现过的关系(即s[j][k]的那一维全为空)stop[j]和stop[k]全都赋值为1 2.对于到最后了的关系(即s[j][k][]='\0')全赋空 因为有m*(m-1)/2 对 关系，也就是每两个都有比较，所以一定能够得出最前面的一个字符..所以就完美了！ 这里每次stop都会清零！*/ bool stop[10] = &#123;&#125;; for(int j=0;j&lt;m;j++)&#123; for(int k=j+1;k&lt;m;k++)&#123; if(!s[j][k][it[j][k]]) stop[j]=stop[k]=1; else if(s[j][k][it[j][k]]=='a'+j) stop[k]=1; else stop[j] = 1; &#125; &#125; bool done = false; for(int j=0;j&lt;m;j++)&#123; if(!stop[j])&#123; ans+='a'+j; for(int k=0;k&lt;m;k++)&#123; if(k&lt;j) it[k][j]++; else if(k&gt;j) it[j][k]++; &#125; done = true; break; &#125; &#125; if(!done) return 0; &#125; if(!check()) return 0; cout&lt;&lt;ans&lt;&lt;endl; return 1;&#125; 晚上成功补完H题和I题，发现好像没有时间补B题了，明天上午来补一下B题 每日一句叨叨杜月笙知道成功需要代价，他想为自己洗白(小时候家里穷只能混黑帮)，为整个帮派洗白，但穿了大半辈子长褂(为了不露出纹身)，让自己的说书先生给自己讲了大半辈子学，也为上海的繁荣安定做了大半辈子贡献，但却最终未被认可(通过人脉被选之为一个参议长，但蒋介石让他自己退位)，但杜月笙却永远被后人被历史铭记 若命运不公，那就和它斗到底！]]></content>
      <categories>
        <category>算法学习日常</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法学习日常</tag>
        <tag>拓扑排序</tag>
        <tag>BFS</tag>
        <tag>读取空行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8数码和15数码算法结论和延展]]></title>
    <url>%2F2019%2F07%2F31%2F8%E6%95%B0%E7%A0%81%E5%92%8C15%E6%95%B0%E7%A0%81%E7%AE%97%E6%B3%95%E7%BB%93%E8%AE%BA%E5%92%8C%E5%BB%B6%E5%B1%95%2F</url>
    <content type="text"><![CDATA[此类问题是否有解定义一个东西先定义此类问题矩阵的逆序数的和值为除去0以外其他数的排列(把二维一行行地读取的循序的排列)的逆序数和 发现一我们可以发现排列中相邻的两个数交换位置会它们两相互之间的逆序数值,而其他部分以及他们各自和其他部分的逆序数值都不变,所以矩阵的逆序数+1或-1,也就是矩阵的逆序数的奇偶性发生了改变 发现二我们还可以发现0左右移动不影响矩阵的逆序数的奇偶性，然而如果是上(下)移动的话，就想到于一个数连续和左(右)边3个数进行了交换位置，所以矩阵的逆序数的奇偶性会变 发现三矩阵的改变只能通过与0变换位置，所以只有在与0上下交换的时候才会产生矩阵的逆序数的奇偶性的变化 结论所以我们知道最终状态逆序数为0,且最后0在最后一行(高中学化学经常讲终态法)，也就是矩阵要有解，最终逆序数的奇偶性为偶，那么就要在初始状态的逆序数上面 加上 0值在初始状态移动到最后一行产生的逆序数奇偶性的变化值仍为偶数则有解 题目有解性题HDU-6620 2019杭电多校4 手写AC代码1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int T,a[16];int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;T; while(T--)&#123; int cnt = 0; for(int i=0;i&lt;16;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;16;i++)&#123; if(!a[i])&#123; cnt+=3-i/4; &#125; else&#123; for(int j=0;j&lt;i;j++)&#123; if(a[j] &amp;&amp; a[j]&gt;a[i]) cnt++; &#125; &#125; &#125; if(cnt&amp;1) cout&lt;&lt;"No"&lt;&lt;endl; else cout&lt;&lt;"Yes"&lt;&lt;endl; &#125; return 0;&#125; 求最少步数如果我们要求解步数的话,我们首先是用逆序数进行判定是否有解，有解才进行搜索 使用曼哈顿距离递减 和 IDA*(迭代层数达到120层就放弃) 的方式曼哈顿是初始排列到目标排列每个数字abs(x1-x2)+abs(y1+y2)的和值 给个板子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/*先用结论判断是否有解呀！不然没解跑这个会死循环，燃烧你的CPU的话我不背锅哦 */#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;//limit全部的曼哈顿距离之和int map[4][4], map2[16], limit;int flag, length;//各个数字应在位置(i,j)对照表,比如0在位置(3,3)int goal[16][2] = &#123;&#123;3,3&#125;,&#123;0,0&#125;,&#123;0,1&#125;,&#123;0,2&#125;, &#123;0,3&#125;,&#123;1,0&#125;,&#123;1,1&#125;,&#123;1,2&#125;, &#123;1,3&#125;,&#123;2,0&#125;,&#123;2,1&#125;,&#123;2,2&#125;, &#123;2,3&#125;,&#123;3,0&#125;,&#123;3,1&#125;,&#123;3,2&#125;&#125;;int nx[4][2] = &#123; &#123; -1, 0 &#125;, &#123; 0, -1 &#125;, &#123; 0, 1 &#125;, &#123; 1, 0 &#125; &#125;;//估价函数,曼哈顿距离,小于等于实际总步数int hv(int a[][4])&#123; int cost = 0; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; int w = map[i][j]; // 不算0 if (w != 0) cost += abs(i - goal[w][0]) + abs(j - goal[w][1]); &#125; &#125; return cost;&#125;/* x,y起始坐标，len是已经走过的长度,pre_move是上次走的方向 */void dfs(int x, int y, int len, int pre_move)&#123; if (flag) return; int dv = hv(map); if (len == limit) &#123; //成功 退出 if (dv == 0)&#123; flag = 1; length = len; return; &#125; else //超过预设长度 回退 return; &#125; for (int i = 0; i &lt; 4; i++) &#123; //不和上一次移动方向相反,对第二步以后而言 if (i + pre_move == 3 &amp;&amp; len &gt; 0) continue; int tx = x + nx[i][0]; int ty = y + nx[i][1]; if (tx &gt;= 0 &amp;&amp; tx &lt; 4 &amp;&amp; ty &gt;= 0 &amp;&amp; ty &lt; 4) &#123; swap(map[x][y], map[tx][ty]); int p = hv(map); if (p + len &lt;= limit &amp;&amp; flag == 0) &#123; dfs(tx, ty, len + 1, i); if (flag) return; &#125; /* 递归回来后恢复现场 */ swap(map[x][y], map[tx][ty]); &#125; &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--) &#123; int x1, y1; //map2一维 map二维 for (int i = 0; i &lt; 16; i++)&#123; scanf("%d", &amp;map2[i]); if (map2[i] == 0) &#123; x1 = i/4; y1 = i%4; map[x1][y1] = 0; &#125; else &#123; map[i/4][i%4] = map2[i]; &#125; &#125; /* 曼哈顿长度要递减的 */ limit = hv(map); flag = 0; length = 0; //要求120步之内到达,其实如果可以的话最多80多步就可以走完 while (flag == 0 &amp;&amp; length &lt;= 90)&#123; //得到的是最小步数 dfs(x1, y1, 0, 0); /* 加大初始额曼哈顿距离的限制，让递归的行走能不曼哈顿距离递减得多试探几步 */ if (flag == 0) limit++; &#125; // if (flag) // printf("%d\n", length); if(flag) cout&lt;&lt;"Yse"&lt;&lt;endl; else cout&lt;&lt;"No"&lt;&lt;endl; &#125; return 0;&#125; 后续不好意思，写完后才发现重复造轮子了，不过应该我写得应该算比较简单，可以立马用上吧]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>逆序数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[priority_queue和multiset异同以及线段树空树插入维护初见]]></title>
    <url>%2F2019%2F07%2F30%2Fpriority-queue%E5%92%8Cmultiset%E5%BC%82%E5%90%8C%E4%BB%A5%E5%8F%8A%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%A9%BA%E6%A0%91%E6%8F%92%E5%85%A5%E7%BB%B4%E6%8A%A4%E5%88%9D%E8%A7%81%2F</url>
    <content type="text"><![CDATA[priority_queue和multiset异同优先级队列只能按照排序顺序访问一个元素 - 即，可以获得最高优先级的项目，想要访问其他的元素，就必须删除顶端元素。 优先级队列还允许重复元素，因此它很像是一个multiset。 但是multiset比priority_queue的好处就在于multiset不用删除掉优先级最高的元素就可以访问其他优先级的元素，就相当于一个动态的有序数组 同为log(n)插入，但是multiset却能访问更多，真香 虽然priority_queue可以通过删除再恢复的方式达到访问其他优先级的元素，但是实现很不优雅，而且让一个log(n)的操作蹩脚地魔改成了接近O(n^2)的操作，并且容易卡时间 比如HDU-6609这一题暴力priority_queue虽然我很不愿意把我很喜欢的一种STL加上暴力的前缀，但是确实是很朴素自然，大道至简但是这里有点过分使用了…所以下面是TLE的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=1000000007;const int inf = 0x3f3f3f3f;const int M = 2e5 + 7 ;int Q, n, m, w[M];ll sum;int k;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pre;priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; q;int main()&#123; ios::sync_with_stdio(false);cin.tie(0); cin&gt;&gt;Q; while(Q--)&#123; /* init */ sum = 0;k=0; while(!q.empty()) q.pop(); while(!pre.empty()) pre.pop(); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i]; for(int i=1;i&lt;=n;i++)&#123; /* 根据题意不能弹出本次加入的 */ /* 根据题意应该不会在空的时候满足条件 */ // int pre=inf; /*每弹出一个k++,所以每回收pre一个k--*/ // while(!pre.empty()) pre.pop(); while(!q.empty()&amp;&amp;sum+w[i]&gt;m)&#123; k++; pre.push(q.top()); sum-=q.top(); q.pop(); &#125; /*输出*/ cout&lt;&lt;k&lt;&lt;" "; if(i==n)&#123; cout&lt;&lt;endl; break; &#125; /*回溯*/ ll tmp = 0; /* = 再想想*/ bool f=0; while(!pre.empty()&amp;&amp;tmp+pre.top()&lt;=w[i])&#123; f=1; tmp += pre.top(); q.push(pre.top()); k--; pre.pop(); &#125; /*能加入一个就无需加本身了,要加回之前的sum值 本身未加入的话就相当于弹出了一个k++*/ /*不对,加回本身,让其在后面的循环中进入pre*/ // if(f) sum += tmp,k++; if(f) sum += tmp; q.push(w[i]); sum += w[i]; &#125; &#125; return 0;&#125; multiset12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;const int maxn = 2e5 + 10;int a[maxn];multiset&lt;int&gt; ss;int main()&#123; int t; scanf("%d", &amp;t); while (t--) &#123; ss.clear(); long long int n, m; scanf("%lld%lld", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;a[i]); &#125; long long int sum = 0; int tem = 0; for (int i = 0; i &lt; n; i++) &#123; long long int suma = sum; int jishu = 0; if (suma + a[i] &gt; m) &#123; auto j = ss.end(); /* 这里用计数jishu记下软删除的数量，由于priority_queue 只能访问第一个值，所以不支持软硬删除操作...所以会用真实删除再 恢复的操作会TLE...因为这样会从O(nlog(n))魔化到O(n^2) */ /* 由题意a[i]&lt;=m，满足下面条件时一定不会出现ss为空 */ while (suma + a[i] &gt; m) &#123; j--; suma -= *j; jishu++; &#125; &#125; /* 第一个铁定是0的 */ printf("%d ", jishu + tem); ss.insert(a[i]); auto j = ss.end(); sum += a[i]; /* 用tem记录下硬删除的数量 */ while (sum &gt; m) &#123; j--; sum -= *j; /* 这里由于find返回的是指针，所以就会只删除一个值 而不是删除数值那样把所有数值都删除掉 */ ss.erase(ss.find(*j)); tem++; &#125; &#125; printf("\n"); &#125;&#125; 线段树树空树插入维护初见这个线段树标程真是魔鬼一般地折磨了我整整7个小时…菜鸡刚学线段树，还没有过插入空树的经历，然后这个std是插入空树…我好菜啊 所以放一发带思考注释的手抄代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;using namespace std;#define mod 1e9+7#define ll long longconst int M = 2e5+7;ll int a[M],number[M&lt;&lt;2],bz[M&lt;&lt;2];int number2[M&lt;&lt;2],bz2[M&lt;&lt;2],to[M];struct node&#123; int id; ll b;&#125; no[M];bool cmp(node a,node b)&#123; return a.b==b.b ? a.id&lt;b.id : a.b&lt;b.b;&#125;/* 自己重写std感觉上推数值好像还是不对，如果不理解的话，下次就算有板子也不能秒掉！所以还是要先理解一下 ，多多重现算法*//* 先写着，等下写完全部看看有没有新的认识 *//* 2019年7月30日16:59:35 还是不懂，维护区间之和难道不是要左右相加吗？2019年7月30日20:34:57 突然灵光一闪！因为你一开始是一棵空树，然后你一个个插入，如果使用的是max，就相当于(to[i],n+1)这个区间以及每个子区间都是你的插入值的和. 因为都是直接到了叶子节点去加和如果使用加法，那么就出错了，就有很多重复计算，所以说[1-&gt;n]区间就是最大的前缀和所以询问的时候就可以直接加和*/void PushUp(int rt)&#123; number[rt] = max(number[rt&lt;&lt;1],number[rt&lt;&lt;1|1]);&#125;/* 其实这里是多组测试的初始化0值 *//* 但是number2不PushUp清零吗？这里好像有问题，但为什么std能AC惊呆的发现竟然放在了pushdown下推标记的时候清零了...感觉线段树的写法真多*/void build(int l,int r,int rt)&#123; bz[rt]=bz2[rt]=number[rt]=0; if(l==r)&#123;number2[rt]=0;return;&#125; int mid = (l+r)&gt;&gt;1; build(l,mid,rt&lt;&lt;1); build(mid+1,r,rt&lt;&lt;1|1); PushUp(rt);&#125;void pushdown(int l,int r,int rt)&#123; if(bz[rt])&#123; bz[rt&lt;&lt;1] += bz[rt]; bz[rt&lt;&lt;1|1] += bz[rt]; number[rt&lt;&lt;1] += bz[rt]; number[rt&lt;&lt;1|1] += bz[rt]; bz[rt] = 0; &#125; if(bz2[rt])&#123; bz2[rt&lt;&lt;1] += bz2[rt]; bz2[rt&lt;&lt;1|1] += bz2[rt]; number2[rt&lt;&lt;1] += bz2[rt]; number2[rt&lt;&lt;1|1] += bz2[rt]; bz2[rt] = 0; &#125;&#125;void change(ll o,int L,int R,int l,int r,int rt)&#123; if(L&gt;R) return; if(l==r)&#123; number[rt]+=o; /* 之前初始化成了0，所以这里可以这样...这个标程写得真随意... */ number2[rt]+=1; return ; &#125; /* 此节点(区段l,r)全被包含在内 */ if(L&lt;=l &amp;&amp; r&lt;=R)&#123; /* 先自己赋值，下推标记就直接给儿子赋值 */ number[rt]+=o; bz[rt]+=o; bz2[rt] += 1; return ; &#125; int mid = (l+r)&gt;&gt;1; /* pushdown和PushUp都只管修改相邻层 */ pushdown(l,r,rt); /* 区段l,r包含L,R,或者有交叠,则访问子节点(子区段) */ if(L&lt;=mid) change(o,L,R,l,mid,rt&lt;&lt;1); if(R&gt;mid) change(o,L,R,mid+1,r,rt&lt;&lt;1|1); PushUp(rt);&#125;ll query(ll k,int l,int r,int rt)&#123; if(l==r) return number2[rt]; int mid = (l+r)&gt;&gt;1; pushdown(l,r,rt); int ans; if(k &lt; number[rt&lt;&lt;1]) ans = query(k,l,mid,rt&lt;&lt;1); else ans = query(k,mid+1,r,rt&lt;&lt;1|1); PushUp(rt); return ans;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); build(1,n+1,1); for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;a[i]); no[i].b = a[i]; no[i].id = i; &#125; sort(no+1,no+n+1,cmp); /* 把与n+1有关的节点都打上number=1e9,number2=1的标记... 只给n+1对应的叶子节点处打上了标记！其他地方没有进去过！ 就相当于在那里插入了一点*/ change(1e9,n+1,n+1,1,n+1,1); for(int i=1;i&lt;=n;i++) to[no[i].id] = i; for(int i=1;i&lt;=n;i++)&#123; /*一个个插入,第一个时还没插入，是空树，所以肯定返回0*/ ll k = query(m-a[i],1,n+1,1); printf("%lld ",i-k); /*按照队友的说法,那这里就是插入第一个*/ /* 给排名在to[i]到n+1的地方都所有区段打上区间数值和number 和此区间个数和number2 */ change(a[i],to[i],n+1,1,n+1,1); &#125; puts(""); &#125; return 0;&#125; 借鉴: C++&amp;STL&amp;multiset&amp;杭电多校第三场 1007 find the answer]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>线段树</tag>
        <tag>STL</tag>
        <tag>优先队列</tag>
        <tag>multiset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AcWing-245.你能回答这些问题吗]]></title>
    <url>%2F2019%2F07%2F30%2FAcWing-245-%E4%BD%A0%E8%83%BD%E5%9B%9E%E7%AD%94%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%E5%90%97%2F</url>
    <content type="text"><![CDATA[背景2019牛客杭电多校都把线段树当做最最最基础的知识点，杭电3甚至把线段树当做签到，所以线段树要多练啊 题目你能回答这些问题吗 算法线段树入门题 O(Mlog(N))一步步思考线段树过程关键点不能简单的对比对比左右子区间的dat和值(区间最大和值)来更新本节点的区间最大和值，还要对比右子树的rmax+左子树的lmax的和值 c.dat=max(max(a.dat,b.dat),a.rmax+b.lmax); 附图可以参考，关键看代码注释 手写AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int SIZE = 5e5+7;struct SegmentTree&#123; int l,r; int lmax,rmax,sum; int dat;&#125; t[SIZE&lt;&lt;2];int a[SIZE],N,M;void pushup(int p)&#123; t[p].sum = t[p*2].sum + t[p*2+1].sum; t[p].lmax = max(t[p*2].lmax,t[p*2].sum+t[p*2+1].lmax); t[p].rmax = max(t[p*2+1].rmax,t[p*2+1].sum+t[p*2].rmax); t[p].dat = max(t[p*2].dat,max(t[p*2+1].dat,t[p*2].rmax+t[p*2+1].lmax));&#125;void build(int p,int l,int r)&#123; t[p].l=l,t[p].r=r; if(l==r)&#123; t[p].sum=t[p].lmax=t[p].rmax=t[p].dat=a[l]; return ; &#125; int mid = (l+r)/2; build(p*2,l,mid); build(p*2+1,mid+1,r); pushup(p);&#125;void change(int p,int x,int v)&#123; if(t[p].l==t[p].r)&#123;t[p].dat=t[p].sum=t[p].lmax=t[p].rmax=v;return ;&#125; int mid = (t[p].l+t[p].r)/2; if(x&lt;=mid) change(p&lt;&lt;1,x,v); else change(p&lt;&lt;1|1,x,v); pushup(p);&#125;// int ask(int p,int l,int r)&#123;// if(l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) return t[p].dat;// int mid = (t[p].l + t[p].r)/2;// int val = -(1&lt;&lt;30);// if(l&lt;=mid) val = max(val,ask(p&lt;&lt;1,l,r));// if(r&gt;mid) val = max(val,ask(p&lt;&lt;1|1,l,r));// return val;// &#125;/* 此处感谢队友帮忙debug */SegmentTree ask(int p,int l,int r)&#123; if (l&lt;=t[p].l &amp;&amp; r&gt;=t[p].r) return t[p]; int mid=(t[p].l+t[p].r)&gt;&gt;1; int val=-(1&lt;&lt;30); SegmentTree a,b,c; a.dat=a.sum=a.lmax=a.rmax=val; b.dat=b.sum=b.lmax=b.rmax=val; c.dat=c.lmax=c.rmax=val; c.sum=0; /* 要么都在最左边，要么都在最右边，要么跨越了左右，跨越了左右就要判断 c.dat=max(max(a.dat,b.dat),a.rmax+b.lmax); 这个点没想到会卡住 --&gt; 我就是从前面的注释的ask函数出错来的*/ if (l&lt;=mid&amp;&amp;r&lt;=mid)&#123; a=ask(p&lt;&lt;1,l,r); c.sum+=a.sum; &#125; /* 还要注意左区间r&lt;=mid,右区间l&gt;mid */ // else if (l&gt;=mid&amp;&amp;r&gt;=mid)&#123; else if (l&gt;mid&amp;&amp;r&gt;mid)&#123; b=ask(p*2+1,l,r); c.sum+=b.sum; &#125; else&#123; a=ask(p&lt;&lt;1,l,r); b=ask(p*2+1,l,r); c.sum+=a.sum+b.sum; &#125; c.dat=max(c.dat,max(max(a.dat,b.dat),a.rmax+b.lmax)); c.lmax=max(c.lmax,max(a.lmax,a.sum+b.lmax)); c.rmax=max(c.rmax,max(b.rmax,b.sum+a.rmax)); return c;&#125;int main()&#123; ios::sync_with_stdio(false);cin.tie(0); cin&gt;&gt;N&gt;&gt;M; for(int i=1;i&lt;=N;i++) cin&gt;&gt;a[i]; build(1,1,N); int i,x,y; while(M--)&#123; cin&gt;&gt;i&gt;&gt;x&gt;&gt;y; if(i==1)&#123; if(x&gt;y) swap(x,y); cout &lt;&lt; ask(1, x, y).dat &lt;&lt; endl; &#125; else change(1,x,y); // for(int i=1;i&lt;=9;i++)&#123; // cout&lt;&lt;"dat: "&lt;&lt;t[i].dat&lt;&lt;" sum: "&lt;&lt;t[i].sum&lt;&lt;" lmax: "&lt;&lt;t[i].lmax&lt;&lt;" rmax: "&lt;&lt;t[i].rmax&lt;&lt;endl; // &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[银联挑战赛初赛第二场B题]]></title>
    <url>%2F2019%2F07%2F28%2F%E9%93%B6%E8%81%94%E6%8C%91%E6%88%98%E8%B5%9B%E5%88%9D%E8%B5%9B%E7%AC%AC%E4%BA%8C%E5%9C%BAB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目题目链接码队弟弟的求和问题 题面 题解思路 数论分块知识点图片截取了大佬的blog 手写AC代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll mod = 1e9+7;ll n,m;ll inv6;ll qpow(ll a,ll b)&#123; ll res = 1; while(b)&#123; if(b&amp;1) res = res*a%mod; a = (a*a)%mod; b&gt;&gt;=1; &#125; return res;&#125;ll f(ll n)&#123; return n*(n+1)%mod*(2*n+1)%mod*inv6%mod;&#125;ll solve(ll n)&#123; ll ans = (n*(n+1)/2%mod)*n; // ll ans = n*n%mod*(n+1)/2%mod; for(int i=1,j;i&lt;=n;i=j+1)&#123; /*i=j+1,以及n/i要加括号*/ j = n/(n/i); /*其实j不会大于n*/ if(j&gt;n) j=n; ans = (ans - (f(j)-f(i-1))*(n/i)%mod + mod)%mod; /*只要保证每次相减时两个都是正数 然后结果再来一次保证正数操作就不会出错*/ &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); inv6 = qpow(6,mod-2); cin&gt;&gt;n&gt;&gt;m; ll ans = solve(n)*solve(m)%mod; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 菜鸡我踩坑坑我35mins 123// bug是因为除号必须在mod前！ll ans = (n*(n+1)/2%mod)*n;// ll ans = n*n%mod*(n+1)/2%mod;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第14周-14-521]]></title>
    <url>%2F2019%2F07%2F27%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC14%E5%91%A8-14-521%2F</url>
    <content type="text"><![CDATA[Algorithmgogogo ReviewDo You Really Need Another Computer Monitor? 是啊，对于单一的工作，没有很多要素的工作一个屏幕就够了 但是对于需要很多要素的工作，比如一边看编程视频教学，一边跟着写这种要素很多的工作，有两个屏幕真的能提高自己的效率 Tips线段树从零开始 线段树详解 Share2019牛客多校3 I]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客多校3 I]]></title>
    <url>%2F2019%2F07%2F26%2F2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A13-I%2F</url>
    <content type="text"><![CDATA[题目题目链接Median 题意3个数产生一个中位数，现在给你一串中位数，请还原出一个合理的原串 InputT组,每组给n表示原串的长度,然后是给你中位数串b[1]-&gt;b[n-1] 范围: n的和不超过10^6,每个b不超过10^9 Output有合理的串则输出原串,否则输出-1 题解结论若存在合理的解,那么解的每个位置的最终值一定是它能影响到的3个中位数之一 证明 Dp解法 自己动手写AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;const int M = 1e5+7;bool f[M][3][3];int pre[M][3][3];int v[M][3];int b[M],a[M];int T,n;int mid(int x,int y,int z)&#123; static int tmp[3]; tmp[0]=x,tmp[1]=y,tmp[2]=z; sort(tmp,tmp+3); return tmp[1];&#125;/*回溯构造*/void back(int i,int j,int k)&#123; while(i&gt;=1) &#123; a[i] = v[i][j]; int pr = pre[i][j][k]; j = k; k = pr; i--; &#125;&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); for(int i=2;i&lt;=n-1;i++) scanf("%d",&amp;b[i]); /*init*/ b[0]=b[1]=b[2]; b[n+1]=b[n]=b[n-1]; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;3;j++) for(int k=0;k&lt;3;k++) f[i][j][k]=false; /*注意:我给的手写题解中a[3]对应b[1],b[2],b[3] 我这里为了实现方便是用的对应b[2],b[3],b[4]*/ for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;3;j++)&#123; v[i][j]=b[i-1+j]; &#125; sort(v[i],v[i]+3); &#125; /*边界条件: 前i-2个中位数(此时i=2为0个中位数)是满足条件的 最终f[N][i][j]的时候的是N-2个中位数是否满足条件*/ for(int i=0;i&lt;3;i++) for(int j=0;j&lt;3;j++) f[2][i][j]=true; /*solve*/ bool findans = false; for(int i=3;i&lt;=n;i++)&#123; for(int j=0;j&lt;3;j++)&#123; for(int k=0;k&lt;3;k++)&#123; for(int l=0;l&lt;3;l++)&#123; if(!f[i-1][k][l]) continue; /*判断前面的位置和本位置使用与他们位置相关的 3个中位数的排列中哪些排列能够满足要求 v[i][j]对应的是b[i-1],b[i],b[i+1]中的一个*/ if(mid(v[i-2][l],v[i-1][k],v[i][j])!=b[i-1]) continue; f[i][j][k]=true; /*记录下前面使用的是l大的*/ pre[i][j][k]=l; /*break写完再探索-std中用了break 我认为应该遍历全部情况,所以去掉了break 然后两份代码都AC了,所以可能解唯一或者是按照std 生成的数据吧*/ // break; &#125; if(i==n &amp;&amp; f[i][j][k])&#123; findans = true; back(i,j,k); goto END; &#125; &#125; &#125; &#125; END: if(!findans) printf("%d\n",-1); else&#123; for(int i=2;i&lt;n;i++) &#123; assert(mid(a[i-1],a[i],a[i+1]) == b[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; printf("%d%c",a[i]," \n"[i==n]); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>多校</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第13周-13-521]]></title>
    <url>%2F2019%2F07%2F22%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC13%E5%91%A8-13-521%2F</url>
    <content type="text"><![CDATA[Algorithm牛客多校中一题 ReviewRule of Three: Bad Ideas, Arguments and Brainstorming When you do a brainstorm to solve a problem or generate an idea, you’ll always experience two sides. First you flare to generate as many ideas as possible. Then you focus to decide on the one path that you’re actually going to execute on. 确实,做决定的时候要好好选择,别人批评,自己选择,选择好然后专注做下去,自己负责 Tips我再也不装扮博客了 那我也不装了 Share2019牛客多校第一场补题笔记 2019牛客多校第二场补题笔记]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客多校第二场补题笔记]]></title>
    <url>%2F2019%2F07%2F21%2F2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%8C%E5%9C%BA%E8%A1%A5%E9%A2%98%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[题目链接2019牛客多校第二场 background出题人:sd0061赵轩昂，北京航空航天大学，WorldFinal 2015/2016 Eddy好像就是出题人的电脑用户名 出题评价题目对我这个菜鸡来说较难，题意复杂 讲题评价逻辑清晰，对每一题的讲解由浅入深，对时间复杂度不断优化精细讲解，层层入深，获得大家的一致好评(只是目前我这个菜鸡对于很多浅的地方还没学好甚至还没学过，所以补补补o(╥﹏╥)o) A题意 Eddy大佬走路 先让0-&gt;N-1都有标记 -&gt; 第i天走一圈需要Ni步(每天脚长不一样还行),可以前进和后退,然后收集完所有标记(每个地方都有标记,即0-&gt;N-1处都是标记)就立马感到无聊了就立马回去吃饭睡觉打豆豆(你的记录值中Eddy大佬走到Mi就算是收集完了所有的标记) 你每天观摩大佬走路(giao) 你复查数据的时候，你不确定到底数据是不是对的，然后你想知道这些天的数据正确的可能性(所以很自然的知道后面为什么要你输出前缀积,原来写笔记确实可以加深理解奥) input T组测试(T天的观测) 然后每组测试都是给你Ni和Mi(每天Eddy的走路信息) Output 输出前i天的数据都正确的可能性(也就是每天可能性之积) 思路 Corner Case: 当N=1的时候，也就是1步就可以走完一圈，无论Eddy大佬前进还是后退，肯定是1步走完(这样肯定收集完了所有的标记),所以可能性为1 当M=0的时候，你记录的是Eddy大佬在0处就收集完了所有的标记,这是不可能，因为Eddy大佬一开始从0出发，所以一开始就已经拥有0号标记了,而一旦Eddy收集完所有的标记之后必定会立马回家,所以离开的地方的那个标记一定是最后收集到的,而且是第一次收集到的那个标记，所以你记录值为0显然是错的,所以可能性是0 一般情况(N非1,M非0) 有了上面M=0的理解，这里就好理解了，因为Eddy大佬一开始从0出发,然后Eddy大佬可以前进也可以后退，所以Eddy大佬最后一个到达的点可以是非0的其他任意一个点，所以最后到达每个点的可能性都是等概的，也就是1/(N-1) 对了，输出的是前i的概率积 AC代码(自己再手写一遍收获更多)1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int mod = 1e9+7;int T,n,m;ll ans;ll mul(ll a,ll b)&#123; a *= b; return a&gt;=mod?a%mod:a;&#125;ll qpow(ll a,ll b)&#123; ll ret = 1; while(b)&#123; if(b&amp;1) ret = mul(a,ret); /* b&gt;&gt;1,那么a就要变成a*a */ b&gt;&gt;=1; a = mul(a,a); &#125; return ret;&#125;ll inv(ll a)&#123; return qpow(a,mod-2); &#125;ll solve(ll n,ll m)&#123; if(n==1) return 1; if(m==0) return 0; return inv(n-1);&#125;int main()&#123; ios::sync_with_stdio(false); /*init*/ ans = 1; cin&gt;&gt;T; while(T--)&#123; cin&gt;&gt;n&gt;&gt;m; /*solve*/ ans = mul(ans,solve(n,m)); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; Bemmmm,看懂了一点点题解,但是对于题解中的BM完全不熟悉,所以先留坑 C,D自己太菜了,留坑Eemmmm,看懂了一点点题解,但是还是不太熟悉基础的算法,我先去补基础的算法,留坑 F题意给定2N个人,(N &lt;= 14),两两间有边权,把这2N个人分为2组,每组N个,求两组间的边权和最大 题解朴素法(也称暴力法),在新加入一个人的时候，比如说加入了A组，那么直接将它与B组间已经有的所有人的边权加一遍 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int M = 50;int d[M][M];int a[M],b[M];int cnt1,cnt2;ll ans;int N;void dfs(int cur,ll val)&#123; /*当达到2*N+1的时候,正好已经插入了2*N个人了,所以开始比较*/ if(cur&gt;2*N)&#123; ans = max(ans,val);return ;&#125; if(cnt1&lt;N)&#123; a[cnt1++]=cur; ll tmp = 0; /*每次加入了cnt1之后,就要把左边队伍新加人与对面队伍当下所有人产生的竞争值加入左边队伍*/ for(int i=0;i&lt;cnt2;i++) tmp+=d[cur][b[i]]; dfs(cur+1,val+tmp); /*上面的遍历return之后要恢复现场,即之前产生的影响要消除掉,避免对后面的操作有影响*/ cnt1--; &#125; if(cnt2&lt;N)&#123; b[cnt2++]=cur; ll tmp = 0; /*每次加入了cnt2之后,就要把右边队伍新加人与对面队伍当下所有人产生的竞争值加入右边队伍*/ for(int i=0;i&lt;cnt1;i++) tmp+=d[a[i]][cur]; dfs(cur+1,val+tmp); cnt2--; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;N; for(int i=1;i&lt;=2*N;i++) for(int j=1;j&lt;=2*N;j++) cin&gt;&gt;d[i][j]; ans = 0; /*像一颗树一样遍历下去,然后到达叶子的时候进行比较出最大值再返回*/ dfs(1,0); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; G计算几何,留坑H题意给定一个N*M的01矩阵(1&lt;=N,M&lt;=1000),求第二大全是1的矩阵面积 题解 枚举每一行，以当前行为底，记录每一列往上不间断最多延长多远，那么这样之后就变成了一维的柱状图求最大/次大/k大矩形面积，可用单调栈求解 由于要记录第二大,之前求最大的做法(poj2559)是直接用max维护ans,width合并的做法在这里就要改成把所有解先丢进一个vector(之后排序复杂度 ans个数 * log(ans个数))(或者维护一个k大的小值优先的priority_queue,复杂度算上维护也是ans个数 * log(ans个数)) 但是这里必须把(width-1)*ddz[top]也放入状态级,因为求第二大,所以只要把次大状态加入(详细原因看下面说的坑点) 所以推荐使用把全状态扔进vector，这样还可以求第k大，虽然慢点 坑点图中最后一行样例的dp的单调栈这里是小于也没有用，因为1会占据掉3的宽度，而且仍为高度1，之后就在0到来的时候累加宽度 (宽度直接从4加到了6，跳过了5,因为1之前会占据掉3的宽度)，然后就会无视掉矩阵面积是5的情况！！！ 所以用width会导致状态数减少，这里求第二大可以把width-1的状态也加入，从而达到正确答案并减少了一定状态数 不过还是推荐使用全状态，就是用cnt++，把所有状态放入vector，这样就可以求出第k大 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/*5 1001001011000010110110100001111010001100101111110010*/#include&lt;bits/stdc++.h&gt;using namespace std;const int M = 1e3+5;int dp[M][M];int ddz[M],w[M];vector&lt;int&gt; ans;int n,m;void solve(int *f)&#123; int top = 0; ddz[top] = -1; f[m+1] = -1; for(int i=1;i&lt;=m+1;i++)&#123; /*等于时是否弹出这需要自己注意一下,就是严不严格单调的选择*/ if(ddz[top]&lt;f[i]) ddz[++top]=f[i],w[top]=1; else&#123; int width = 0; /*此处注意要先加宽度*/ while(top&amp;&amp;f[i]&lt;ddz[top])&#123; width+=w[top],ans.push_back(ddz[top]*width),ans.push_back(ddz[top]*(width-1));top--;&#125; /*我的做法是 : 等于是加入,不严格单调*/ ddz[++top]=f[i],w[top]=width+1; &#125; /*推荐下面的方法*/ // if(ddz[top] &lt;= f[i]) ddz[++top] = f[i]; // else &#123; // int cnt = 0; // /*然后这里可以写宽度进行优化*/ // while(top &amp;&amp; ddz[top] &gt; f[i]) &#123; // cnt++; // ans.push_back(ddz[top] * cnt); // top--; // &#125; // while(cnt--) ddz[++top] = f[i]; // ddz[++top] = f[i]; // &#125; &#125;&#125;int main()&#123; char c[M]; while(~scanf("%d%d",&amp;n,&amp;m)) &#123; /*init*/ ans.clear(); for(int i=1;i&lt;=n;i++)&#123; /*对于每一列的每一行进行连续高度扫描*/ scanf("%s",c); /*此行非0,则可以接上上面连续来的高度(可能为0)*/ for(int j=1;j&lt;=m;j++) dp[i][j] = c[j-1] == '0'? 0 : dp[i-1][j]+1; &#125; // for(int i = 1;i&lt;=n;i++) &#123;for(int j=1;j&lt;=m;j++) cout&lt;&lt;dp[i][j]; cout&lt;&lt;endl;&#125; cout&lt;&lt;endl; /*solve*/ /*对每一行进行直方图扫描求解*/ for(int i=1;i&lt;=n;i++) solve(dp[i]); sort(ans.begin(),ans.end()); /*考虑特例*/ int sz = ans.size(); if(sz&lt;=1) printf("0\n"); printf("%d\n", ans[sz-2]); &#125; return 0;&#125; I听Eddy大佬说有7种dp,太难留坑J也太难留坑]]></content>
      <categories>
        <category>算法</category>
        <category>多校</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客多校第一场补题笔记]]></title>
    <url>%2F2019%2F07%2F19%2F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA%E8%A1%A5%E9%A2%98%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[题目链接2019牛客多校第一场 A题题解知道了单调栈，那么第一题就很好解决了，就是两个串到每个位置都比较一下前面的最小值的下标是否相等(用单调栈来实现–后面讲)，如果相等则继续，如果都没有找到就是都是自己最小，也用单调栈处理成为相等，如果遇到不相等，那么i-1就是题目所要求出来的k的值 补充 单调栈单调栈的一大优势就是线性的时间复杂度，所有的元素只会进栈一次，而且一旦出栈后就不会再进来了。 单调递增栈可以找到左起第一个比当前数字小的元素。比如数组 [2 1 4 6 5]，刚开始2入栈，数字1入栈的时候，发现栈顶元素2比较大，将2移出栈，此时1入栈。那么2和1都没左起比自身小的数字。然后数字4入栈的时候，栈顶元素1小于4，于是1就是4左起第一个小的数字。此时栈里有1和4，然后数字6入栈的时候，栈顶元素4小于6，于是4就是6左起第一个小的数字。此时栈里有1，4，6，然后数字5入栈的时候，栈顶元素6大于5，将6移除，此时新的栈顶元素4小于5，那么4就是5左起的第一个小的数字，最终栈内数字为 1，4，5。 1234567891011/* L是输出端，然后s是辅助数组,c是源数组 */void solve(int* c, int* L) &#123; int top = 0; s[0] = node&#123;0, 0&#125;; for(int i = 1; i &lt;= n; i++) &#123; /*找到向左走第一个比它小的数 */ while(top &amp;&amp; s[top].val &gt;= c[i]) top--; L[i] = s[top].id; s[++top] = node&#123;i, c[i]&#125;; &#125;&#125; 参考链接:https://www.cnblogs.com/grandyang/p/8887985.html AC代码代码是队友写的,orz 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int inf = 0x3f3f3f3f;const int maxn = 100000 + 5;struct node &#123; int id; int val; &#125;;int a[maxn], b[maxn];int l1[maxn], l2[maxn];node s[maxn];int n;/* L是输出端，然后s是辅助数组,c是源数组 */void solve(int* c, int* L) &#123; int top = 0; s[0] = node&#123;0, 0&#125;; for(int i = 1; i &lt;= n; i++) &#123; /*找到向左走第一个比它小的数 */ while(top &amp;&amp; s[top].val &gt;= c[i]) top--; L[i] = s[top].id; s[++top] = node&#123;i, c[i]&#125;; &#125;&#125;int main() &#123; while(~scanf("%d", &amp;n)) &#123; for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;b[i]); solve(a, l1); solve(b, l2); int ans = n; for(int i = 1; i &lt;= n; i++) &#123; if(l1[i] != l2[i]) &#123; ans = i-1; // ans = n-1; break; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125; B题看到大佬的分析 C题，D题能力有限，战略计划原因没有补这两题 C题解推荐C题可以看大佬的题解 E题1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;#define MAXN 2000#define MOD 1000000007int n,m;int dp[MAXN+5][MAXN+5];int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; for(int i=0;i&lt;=n+m;i++) for(int j=0;j&lt;=n+m;j++) dp[i][j]=0; dp[0][0]=1; for(int i=0;i&lt;=n+m;i++) for(int j=0;j&lt;=n+m;j++)&#123; if(i+1&lt;=j+n&amp;&amp;j&lt;=i+m) dp[i+1][j]=(dp[i+1][j]+dp[i][j])%MOD; if(i&lt;=j+n&amp;&amp;j+1&lt;=i+m) dp[i][j+1]=(dp[i][j+1]+dp[i][j])%MOD; &#125; printf("%d\n",dp[n+m][n+m]); &#125;&#125; F图片以及思路转载+少量整理+感谢借鉴两位大佬的思路和博文进行整理的，感谢Izayoi_wWAautomaton 题目要求36*E，而E = (22/36) * S，所以ans = 22 * S 关于三角形的面积，已知三个顶点坐标，我们可以用叉积来求，如ΔABC，S = (1/2) * ( 向量(AB) ✖ 向量(AC) )。 这里要注意，叉积有正有负，最终的答案为11倍叉积的绝对值。 AC代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int inf = 0x3f3f3f3f;const int maxn = 100000 + 5;int main() &#123; ll x1, y1, x2, y2, x3, y3; while(cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3) &#123; ll res = 11*((x1-x2)*(y3-y2)-(y1-y2)*(x3-x2)); if(res &lt; 0) res = -res; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; G,H,I因己太菜先留坑J题解解法一: 直接交叉相乘 解法二: 直接看出题人叉姐的解法 AC代码123456789101112131415#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef __int128 ll;int main() &#123; long long x, a, y, b; while (scanf("%lld %lld %lld %lld", &amp;x, &amp;a, &amp;y, &amp;b) != EOF) &#123; ll p = x; p *= b; ll q = y; q *= a; if (p &gt; q) printf("&gt;\n"); else if (p == q) printf("=\n"); else printf("&lt;\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>多校</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[真的有必要把文章发布到多个平台吗？]]></title>
    <url>%2F2019%2F07%2F16%2F%E7%9C%9F%E7%9A%84%E6%9C%89%E5%BF%85%E8%A6%81%E6%8A%8A%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E5%88%B0%E5%A4%9A%E4%B8%AA%E5%B9%B3%E5%8F%B0%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[如题真的需要把自己的文章发布到多个网站平台吗？比如WordPress，Hexo，CSDN，知乎，简书，博客园，sf，开源中国等等… 说实话，我也不知道具体答案，因为答案总是和个人情况有关的 源起我之前看李自然说的视频，他说自媒体的运营应该全平台覆盖,把公域流量变成自己的私域流量，然后我也就开始了每次写一篇文章就风风火火地把自己的文章发布到自己wordpress，自己的hexo，自己的简书，自己的CSDN，自己的知乎，而且还在自己的关于界面写上了欢迎加我微信，然后一起拉群讨论… 冲突今天，是放暑假的第5天，大家都回家了，当然还有很多巨佬在疯狂地自学，我昨天连续学了3个小时技术，然后做了8个小时的算法，感觉很开心，但是今天上午睡过头，今天下午和晚上因为增强看板娘的事情，以及处理gitee大于上传100M出现了问题导致自己今天到9点都没有刷算法题，然后此时写完一篇博文，准备写算法，然后一想到自己还有4个平台没有上传自己的博文……开始思考自己是不是要把其他的平台停止更新了 取舍 感觉自己并不想通过写个人博客来转化变现，只想自己整理一些东西，然后分享给大家，所以也就不那么想去花太多时间运维什么的了 搞这么多东西其实和我真正要做的人生五件事是完全无关的！所以以后不仅不能花太多时间在这个无关的事情上面，而且还要想见了鬼一样地避开这些事情… 所以以后就用Hexo做笔记的整理与环境搭建的记录，然后值得分享的技术文档就发布到CSDN上面去，因为CSDN越做越好了，而且它的SEO做得最好(怪不得广告多…槽点…不过这也是生命线,无可厚非)，符合我分享给大家的意愿，然后用coding的私人仓库和wordpress小站来做备份… 询问你们怎么取舍的呢？]]></content>
      <categories>
        <category>思索</category>
      </categories>
      <tags>
        <tag>思索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git reset 和 git reset --hard区别]]></title>
    <url>%2F2019%2F07%2F16%2Fgit-reset-%E5%92%8C-git-reset-hard-%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[git reset 和 git reset --hard区别先说知识点 有时候，进行了错误的提交，但是还没有push到远程分支，想要撤销本次提交，可以使用git reset –-soft/hard命令 缺省情况git reset缺省为git reset --soft 二者区别： git reset –-soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可 git reset -–hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容，撤销的commit中所包含的更改被冲掉 我忘了知识点踩坑沙雕认为 当下情况:最新版本的100M压缩包已经在本地删除，但是本地版本库中之前有个版本中还有，所以git push到gitee会被拒收..但是git一定要先传输完前面的版本之后再传后面的修改(所以我要帮git本地仓库手动执行git rm前面版本的文件，或者忘了文件名，通过下面3的复杂的操作，来完成此项操作) 真的不知道怎么去掉本地仓库的4commit，因为去不掉的话就会先向远程库提交超100M文件然后被拒接，所以原地重复… 然后如果git rm 忘了那个压缩包的名字了，所以直接回退版本到昨天的样子，然后再git reflog回来并展示今天的所有修改，git checkout归还所有修改，然后把今天的修改备份，之后再回到昨天的版本库，然后重新提交今天的内容，除了你个超过100M的压缩包 慢慢懂了奇怪，最后一次版本回退又没有删除本地文件，可能是因为恢复过？ 原来是git reset –hard 和 git reset –soft的区别 所以我幸幸苦苦寻找了好久的取消commit而不影响工作区就是git reset –soft 真是汗啊，因为用得少，所以学了又忘了，所以现在踩一遍坑，使得自己更深刻了，也提醒了自己 对于基础知识 还是要多重复，学习多次，不断加深记忆，或者很可能还是会踩坑 参考：https://blog.csdn.net/yangfengjueqi/article/details/61668381]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[makedown写作超方便的图片使用方式]]></title>
    <url>%2F2019%2F07%2F14%2Fmakedown%E5%86%99%E4%BD%9C%E8%B6%85%E6%96%B9%E4%BE%BF%E7%9A%84%E5%9B%BE%E7%89%87%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[序言 写makedown用图片的时候总是在上传图床的时候，以及使用图片链接的时候会感觉有一些麻烦 我以前使用的是，github图床通过手动git上传,然后自己再一个个去打开github的图片的download的页面去获取图片的分享链接—自己也觉得很麻烦，但是我的小站目标是人在站在，人不在，站希望也还在的战略目标，所以追求的极致的稳定，而不是一时的快速，所以没有使用那些可以直接粘贴上传到免费图床的操作，因为我怕指不定哪一天这种图床没有消息地就倒闭了，那我的数据就这样没了，小站将遭到巨大的打击，所以我还是慢慢使用这种方式用了3个月，知道我听学长说用七牛云太方便了，还能加速网站加载速度，所以我今天也花了许多时间了解七牛云，发现七牛云确实有免费的10G图床和每月10G的加速流量，但是我觉得这样的加速在前期是很好的，不过有个小问题就是你不自定义域名的话到时候可能失效(自定义域名要备案，腾讯云的域名备案又要买腾讯云的服务器…),而且10G对于我的小站战略来说有点不合适，所以就抛弃了，然后无意看到了PicGo+github图床，于是了解了一下，操作了一下，发现是我要找的靓仔啊！ 使用PicGo上传图库下载PicGo在GitHub的最新发布页面下载 博主本人是windows，所以下载的.exe文件直接安装就可以了 配置起来使用官方文档找到GitHub图床配置进行必要的配置 注： 仓库名是用户名/仓库名 指定存储路径是以仓库为根目录的远程仓库存储路径(可以先在本地仓库先创建一个文件夹，然后再文件夹下创建一个readme.md(为什么？看下面的小发现)，然后git push,这样就是设置这个文件夹了) github图床好像是不支持直接自定义域名的,我试过了,如果有朋友知道的希望能告知，谢谢 我的配置 小发现本地文件夹如果没有文件的话，远程仓库对应的这个文件夹是不会生成的，所以以后最好新建文件夹都写一个readme.md 上传图片这个应该大家配置不出问题，这里都会用的 复制链接使用 VScode写makedown使用snippets我发现我的使用了hexo的fancybox3之后，有一个图集的功能，很是炫酷，但是每次图片粘贴要很复杂的输入 123&lt;a href=&quot;&quot; data-fancybox=&quot;images&quot;&gt; &lt;img src=&quot;&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/a&gt; 于是我就想到了snippets 预警如果用了除hexo以外的其他平台，请谨慎使用我的snippets代码！因为data-fancybox=&quot;images&quot;这个图集功能只能用在hexo, 但是可以用于其他的snippets啊 配置snippets去官网看配置 贴一下我的配置 12345678910111213"Mypic":&#123; "prefix":[ "pic", "pic-snippets" ], "body": [ "&lt;a href=\"$&#123;1&#125;\" data-fancybox=\"images\"&gt;", "\t&lt;img src=\"$&#123;1&#125;\" width=\"50%\" height=\"50%\" /&gt;", "&lt;/a&gt;", "$0" ], "description": "Use my images fancybox3"&#125;, 开启makedown的snippets使能！其实VScode是默认关掉了makedown的snippets的使能的！但是你却找不到配置，我在网上找了好久，发现一个大神写了出来，可能是他去提交过issue吧,下面开始解决(昨天被这个问题坑了好久) 进入文件-&gt;首选项-&gt;设置-&gt;打开代码配置 进入setting，输入makedown 配置成true，have fun 插曲电脑重启？ 2019年7月14日16:41:04 写了50mins后，电脑自动关机，重启电脑，看着文档白茫茫的一片，内心一万只草泥马在奔腾…去你大爷的本地写作，就连最基本的hexo新建文章后的信息也不给我留，是个狠人！不想写VScode的snippets的写作方式了—-&gt; 跑到coding的备份库一看，还有20mins的工作量被保存，还好一点点吧 努力学习，努力赚钱，换一个不会莫名其妙重启的电脑 写作一定要多多保存备份 可以在网站上写makedown，然后把snippets复制粘贴到网上的makedown上面，这样就重分利用了网站的自动及时保存的功能 发现snippets的图集功能不是所有平台的makedown通用的 所以非特殊情况应该以后不会怎么用这个操作 使用PicGo和以前使用git上传的区别上传 picgo 可以直接截图上传，支持重命名 也可以拖动上传 git 只能在全部搞好之后使用命令行一次上传 下载没区别链接 picgo 可以直接复制相册里面的，不用去网页一个个点开 还支持各种格式切换，并且支持自定义 git 只能手动点开网页一个个去找 总结 PicGo确实对自己有帮助，就是链接不用一个个点开网页了 而且上传了的图片也可以按照每次重新设置不同的路径让文件放入不同的路径 git也可以通过先pull的方式继续让本地和远程仓库保持同步 总而言之还是挺好用的]]></content>
      <categories>
        <category>write</category>
      </categories>
      <tags>
        <tag>write</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第12周-12-521]]></title>
    <url>%2F2019%2F07%2F14%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC12%E5%91%A8-12-521%2F</url>
    <content type="text"><![CDATA[Algorithm虽然刷了一些题，写了篇priority_queue入门，但还是太少了呀，下周得好好加油 ReviewHow to define you snippets in VScode? TipsPicGo官方文档 Sharemakedown写作超方便的图片使用方式]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下雪啦(#^.^#)]]></title>
    <url>%2F2019%2F07%2F11%2Ftest%2F</url>
    <content type="text"><![CDATA[下雪啦(#^.^#) The winter is here ,让我们一起超越小姐姐吧 留个纪念 因为比较烧显卡，而且对访问速度影响比较大，所以就关掉了]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[priority_queue使用坑点和题集]]></title>
    <url>%2F2019%2F07%2F09%2Fpriority-queue%E4%BD%BF%E7%94%A8%E5%9D%91%E7%82%B9%E5%92%8C%E9%A2%98%E9%9B%86%2F</url>
    <content type="text"><![CDATA[2019年7月9日23:27:19 更第一波 priority使用pair比较的坑点所以用pair的priority_queue只能使用struct的重载比较，why?! 重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。—&gt; 所以不能使用node型的priority_queue的函数重载操作符的方法 node可以函数操作符重载 pair不支持重载运算符 priority_queue定义不支持”嵌入式”函数重载的方法，即 priority_queue&lt;P, vector, cop&gt;，这样会报错 sort(a,a+n,cop)可以 比较区只有strut定义 嵌入式函数重载报错 综上：不能函数重载了，那么就只能struct的自定义重载了咯 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt; // std::cout#include &lt;queue&gt; // std::priority_queueusing namespace std;struct node &#123; int x, y;&#125;;bool operator&lt;(const node&amp; a, const node&amp; b)&#123; return a.y &gt; b.y; //less默认大顶堆，改为小顶堆&#125;bool cop(const P&amp; a, const P&amp; b) &#123; return a.second &gt; b.second; &#125;typedef pair&lt;int, int&gt; P;struct cmp1 &#123; // 就是说在cmp里面，当两个P使用 ()的时候，他们使用的下面的函数，也就是创建了一个自定义的函数 /* 使用时 大概是这样的 cmp1 A, A(a,b) 就类似 非strut的自定义函数了 bool cmp(P a,P b)&#123; return a.second&lt;b.second;&#125; */ bool operator()(P a, P b)&#123; // 重载() 的函数 叫 仿函数--&gt;紫书找到的 return a.second &gt; b.second; //小顶堆 &#125;&#125;;int main()&#123; std::cout &lt;&lt; "Popping out elements..."; // priority_queue&lt;node, vector&lt;node&gt;, less&lt;node&gt;&gt; test; priority_queue&lt;P, vector&lt;P&gt;, cmp1&gt; test; test.push(&#123; 3, 2 &#125;); test.push(&#123; 1, 6 &#125;); test.push(&#123; 2, 8 &#125;); test.push(&#123; 5, 10 &#125;); while (!test.empty()) &#123; std::cout &lt;&lt; ' ' &lt;&lt; test.top().second; // std::cout &lt;&lt; ' ' &lt;&lt; test.top().y; test.pop(); &#125; cout &lt;&lt; endl; return 0;&#125; 题集注: 为了统一性，所以一般链接地址都是用的Virtual Judge的链接地址，只有VJ上没有的才用其他链接 2019年7月13日第一更 poj3190 牛客重现2019矿大省赛G题 附录priority_queue各种实现方式的时间复杂度对比]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第11周-11-521]]></title>
    <url>%2F2019%2F07%2F07%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC11%E5%91%A8-11-521%2F</url>
    <content type="text"><![CDATA[Algorithm最近难的考试都考完了，整理了一段时间，接下来开始算法刷题冲刺 ReviewVScode remote/ssh#_getting-started 最近下载了VScode Insiders 折腾了一手Remote SSH发现还是有很多坑的 ssh只能密钥连接 ssh只能连接22端口 许多文件都无法打开 许多工作区间都无法建立文件文件夹 当然上面3，4也可能是我技术太菜了，对linux的shell管理不太懂，导致自己没有像有些大佬一样建立了命令行的连接,所以最近一直在学linux，等我学完，可能可以捞自己一手 TipsGit学习–&gt;如何通过Shell脚本自动定时将Gitlab备份文件复制到远程服务器?扩展efi分区 Share技术分享git备份wordpress 读书分享怎样成为精力管理的高手-听书有感]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎样成为精力管理的高手-听书有感]]></title>
    <url>%2F2019%2F07%2F07%2F%E6%80%8E%E6%A0%B7%E6%88%90%E4%B8%BA%E7%B2%BE%E5%8A%9B%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E6%89%8B-%E5%90%AC%E4%B9%A6%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[2019年7月2日22:08:39 00 你为什么需要管理精力 各种时间管理 工作法，有一定的改善，但是还是没有根本性的解决问题 时间总是不能扩张的，而时间质量可以扩张，这种就需要精力管理！ 作者发现一个很牛逼的人，就是全职工作者，然后还是学生，还是3个孩子的爸爸！！！然后他就和那个黄同学学习了精力管理！然后就各种人生开挂！！！ 所以学完了前几天的时间管理后，现在开始学习精力管理！那么我也可以成为大佬，成为一个真正的大佬01 精力管理的金字塔模型 精力好不是天分 你只要掌握了方法，你就能锻炼你的精力 金字塔如下 意义感 –&gt; 目标,使命(人为什么活着!)–&gt;&gt;创造美好的生活 注意力 –&gt; 专注,聚焦(很重要,人可控) 情绪 –&gt; 感恩,乐观,兴奋 体能–&gt; 饮食,运动,睡眠,健康 02 怎样设计最佳运动方案 运动是改善体能的最佳方式 —&gt; 疾病则反之 人有氧运动得越多，这样人的大脑就可以获得更多氧气，这样大脑就反应很快 长期静坐，可能导致死亡 进化论: 好吃懒做的祖先更容易活下来–保留精力 找到喜欢和享受的运动，一周5天，每天30mins-1小时 — &gt; 脚伤了，可以游泳！ —&gt; 多多冥想运动的好处 中等强度220-年龄=200*(60-70%)=130 心率达30mins 设定明确的目标，设定具体的时间，运动量的目标 每天走到8000步 反馈！游戏之所以上瘾，是因为反馈快，所以运动一定要反馈 没时间的话，高轻度间歇训练(每天一分钟都可以!) 刷牙可以单腿站立，下蹲 站立的工作 跑步可以了解一个新的城市 放大回来记一下运动量的要求 得到的 高效学习，时间管理，现在又学精力管理，加油，一定可以竞赛，项目，成绩，健康都做好的，加油 2019年7月3日22:45:5503 吃对了，就不会累 睡眠: 昼夜节律 内生平衡节律(睡得久想醒,醒得久想睡) 下午2-3会报警，所以就困 白天多嗮太阳和晚上多睡会,多喝水 想要获得好的精力少吃多餐高碳水化合物，会发饭晕(所以主要控制血糖水平的波动) 少吃多餐 3顿-&gt; 5顿 (早中午少吃主食，多吃蔬菜，间隙可以加水果) 上午补充坚果水果 一天大致安排 早上高蛋白高纤维 上午补充坚果水果 10点-11点 中午6-7分饱,大量蔬菜，或者鸡肉鱼肉高质量蛋白质 下午3-4点 水果坚果，蓝莓草莓等 晚上可以相对多一点碳水化合物，谷物或者杂粮 总结: 少吃多餐，让血糖尽可能保持平衡 吃低糖,营养质量高的食物NQI(食堂营养占比/热量占比)&gt;=1 才好 作者建议 &gt;=2 水果蔬菜 — 特别是深绿色的蔬菜 加工的 薯片等 + 白米白面都是 NQI&lt;1 的 蛋白质per/碳水化合物percent 约= NQI 多喝水,让身体充分水化缺水带给你疲劳的感觉 — &gt; 夏困 判断喝水够不够 体重/32 == 55/32 = 1.7 L = 3瓶水 排尿判断—两小时左右一次,而且尿颜色很浅 咖啡每天4杯内不会死…茶也行但是不要加糖！ 2019年7月4日23:12:1304 睡得好，能提升你的决策水平 1w个小时刻意练习 天才的平均睡眠时间，8小时16mins 和正常人差不多 睡多久合适，成年人7-9小时 如何提高睡眠质量 没事别上床–&gt;建立上床是睡觉的条件反射，醒着躺床上20mins不能入睡就要起床看书，按时起床！每天必须要同一时刻起床，不能赖床 重视白天的活动.日光下的活动更好–可以合成褪黑素(焦虑也会睡不好，就想我那天石膏21天去复查前夜3,4,5,6点都醒过) 睡前做准备:创造入睡的环境和心情(屋子黑暗+睡前别看显示屏),降低身体体温(体温下降过程),加入白噪音(风雨,动物音),让大脑进入睡眠状态(看难的书) 酒精和打鼾,酒精会绕乱深睡眠,呼吸睡眠暂停综合症,打鼾超5s,要去看医生,大脑会缺氧,损伤大脑,高血压等等 2019年7月6日00:41:28 05 击退消磨意志的疾病 坐姿要好 节律饮食 2019年7月7日16:14:03把所有的都学完了，现在直接做总结吧 #重温并记住精力管理的金子塔 意义感 –&gt; 目标,使命(人为什么活着!)–&gt;&gt;创造美好的生活 注意力 –&gt; 专注,聚焦(很重要,人可控) 情绪 –&gt; 感恩,乐观,兴奋 体能–&gt; 饮食,运动,睡眠,健康 找到自己的人生意义这要自己不断去尝试，去寻找 注意力和情绪通过呼吸练习和冥想练习来做到[讲真的，我第一练习的时候，我哭了] ==分享给你== 链接：https://pan.baidu.com/s/1wsDsFvFbJNrqIoIYVo-I9Q 提取码：undp]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git备份wordpress]]></title>
    <url>%2F2019%2F07%2F07%2Fgit%E5%A4%87%E4%BB%BDwordpress%2F</url>
    <content type="text"><![CDATA[git备份wordpress登陆网站目录初始化git仓库 并且 与远程仓库对接上传首先使用ssh工具(Xshell或者putty等)登入之后进入到自己wordpress网站的根目录然后初始化仓库git init 在远程coding或gitee上面新建私有仓库上面，土豪可以在在GitHub上面建私有仓库 把自己网站所在的vps的公钥放到coding或gitee的ssh密钥管理里面添加公钥 把本地仓库文件传到远程仓库123456# 一定要把下面的ssh路径改成你的ssh路径啊，然后origin也可以改成其他名字(对应本地对远程的一种称呼)git remote add origin git@git.dev.tencent.com:username/wordpreessbackup.git# git 本地远程推送三连击git add --allgit commit -m "你的注释"git push -u origin master 我们想把数据库也备份怎么办？那就干啊，直接在网站根目录下面执行数据库备份，先来看看数据库备份通用的语句12345678# hostname直接是本机，所以我们不用写# username是我们的数据库的用户名# mypwd是我们的数据库密码# databasename就是要备份的数据名字mysqldump -hhostname -uusername -pmypwd databasename &gt; /path to backup/bakname.sql# 所以我的语句应该是如下，你们也可以看着改动，这些数据的信息可以登陆宝塔面板看，或者找到你以前建网站的时候保存的一些重要信息mysqldump -uwolfdanDB -ppassword wolfdanDB &gt; wolfdanDB2019_7_6.sql 然后就成功了，再次推送到远程即可 如果你出了一些问题可以看这里，否则可以直接看下一步：注: 其实wolfdan我是先犯了下面的错误然后才有上面一条龙正确的，所以下面的这些错误修正意见基本上是说把上面步骤完善好，233 没有生成密钥且不会生成密钥的朋友可以看我以前发的文章，虽然当时写得比较水，但还是能看图解决问题的 更新仓库发现没有访问权限则检查自己有没有做上面 生成密钥 和 添加公钥 上传文件被告知src refspec master does not match any，我们使用git status检查发现是没有git add --all – &gt; 也就是说我们要先本地commit 写bash代码，并且使用crontab定时执行备份 并定时 清理一个月前备份的sql文件(节省内存呀) 如果每次都手动执行，难免会有忘记的时候，而且就算你博闻强识，你不嫌花时间吗？我们的追求当然是全自动化！当然现在不想折腾了可以保存页面下次来继续折腾 写出backup.sh文件–&gt;** 当然要把一些变量改成你的 变量值**1234567891011121314151617181920212223242526272829303132333435363738#!/bin/bash#this is wherepath=/home/www/wolfdan.cn#数据库名称sqlName=wolfdanDB#用户名称userName=wolfdanDB#用户密码userPasswd=root#当前时间DATE=`date +"%Y-%m-%d"`#Log存放路径LogFile=$path/backupLog/$DATE.log#新建日志文件touch $LogFile#追加日志到日志文件echo "wolfdan.cn git auto backup to coding server, start at $(date +"%Y-%m-%d %H:%M:%S")" &gt;&gt; $LogFileecho "---------------------------------------------------------------------------" &gt;&gt; $LogFile# 原本我以为执行bash会自动把目录切换，直到crond自动检测bash的log文件，并在log文件中告知我没有 .git文件，我才知道要自己手动cdcd $pathmysqldump -u$userName -p$userPasswd $sqlName &gt; wolfdanDB$DATE.sqlgit add --allgit commit -m "`date '+%Y-%m-%d %H:%M:%S'`"git push origin masterecho -e "---Have a nice day in www.wolfdan.cn----welcome to contact me by VX:wolf_dan2--------\n"&gt;&gt; $LogFile 赋予backup.sh执行权限并且测试一下chmod 777 backup.sh sh backup.sh 我自己之前bash没写好出现的一些问题bash变量赋值不能为空 数据库名称和密码什么的不能出错使用crontab定时vim /etc/crontab 没有vim可以sudo apt-get install vim(Debian/Ubuntu用户)-sudo yum install vim(CentOS用户)下载或者暂时用 vi 代替在注释下面添加你要的任务就行1234567891011121314151617181920SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed# 我的wolfdan.cn 每周备份0 3 * * 0 root /home/www/wolfdan.cn/backup.sh# 自动删除一个月前的sql，下周git的时候会同步到云端删除0 4 * * 0 root /home/www/wolfdan.cn/auto_rm.sh 重载配置并启让配置生效1234#重新加载cron配置文件sudo /usr/sbin/service cron reload#重启cron服务sudo /usr/sbin/service cron restart crontab测试和auto_rm.sh放一起了，所以不妨继续往下看写auto_rm.sh文件编码bash文件一定要小心写cpp时的习惯性变量赋值的空格！ 1234567891011121314151617181920212223#!/bin/bash# 路径Dir=/home/www/wolfdan.cn#当前时间DATE=`date +"%Y-%m-%d"`#Log存放位置LogFile=$Dir/backupLog/$DATE.log#新建日志文件(其实backup的脚本已经建立了，不过建立同名的会直接输出到那里，所以没有关系)touch $LogFile#追加日志信息echo "wolfdan,cn auto_rm .sql file a monoth ago. Start at $(date +"%Y-%m-%d %H:%M:%S")" &gt;&gt; $LogFileecho "------------------------------------------------------------------------------" &gt;&gt; $LogFile# 查找备份路径下，超过30天 且文件后缀为.sql 的 sql备份文件 然后删除find $Dir -type f -mtime +30 -name '*.sql*' -exec rm &#123;&#125; \;echo -e "----Done!Welcome to www.wolfdan.cn and add my VX:wolf_dan2---have a nice day!-------\n" &gt;&gt; $LogFile 赋予权限并且测试执行chmod 777 auto_rm.sh 12345678910# 这里我们先创建1些一个月前的文件touch -t 201905011230 test1.sqltouch -t 201906011230 test2.sqltouch -t 201907011230 test3.sql# 查看目录下文件 当然也可以用 ll 详细查看带时间的文件信息ls# 然后 测试sh auto_rm.sh# 再次查看 当然也可以用 ll 详细查看带时间的文件信息ls crontab定时测试细心用户可能看到我定时文件里面以及写上了auto_rm.sh任务了，没有写上的朋友快去写上吧 先修改crontabe配置vim /etc/contab假设我们现在是11:15,那么我们把日，月，周全打成*号，然后min设置成17，hour设置成11，这样就定时在2mins后了，然后auto_rm设置比backup多1mins 1234567891011121314151617181920SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed# 我的wolfdan.cn 每周备份17 11 * * * root /home/www/wolfdan.cn/backup.sh# 自动删除一个月前的sql，下周git的时候会同步到云端删除18 11 * * root /home/www/wolfdan.cn/auto_rm.sh 当然要重载并重启服务啦啦啦1234#重新加载cron配置文件sudo /usr/sbin/service cron reload#重启cron服务sudo /usr/sbin/service cron restart 当然我们又要创建一个月前的测试文件 1234# 这里我们先创建1些一个月前的文件touch -t 201905011230 test1.sqltouch -t 201906011230 test2.sqltouch -t 201907011230 test3.sql 然后在11:18的时候去ls查看是否还有test1.sql 和 test2.sql 以及输出日志 输出日志是以前的，ball ball 你们动手试试给个反馈吧…不妨把你们的结果发到评论区，谢谢你们也可以加微信拉群讨论，我会经常发一些朋友圈 wolf_dan2参考的大佬文章: https://blog.csdn.net/ouyang_peng/article/details/77334215]]></content>
      <categories>
        <category>wordpress</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脚踝韧带拉伤经历分享]]></title>
    <url>%2F2019%2F07%2F06%2F%E8%84%9A%E8%B8%9D%E9%9F%A7%E5%B8%A6%E6%8B%89%E4%BC%A4%E7%BB%8F%E5%8E%86%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[想看经验的同学直接拉到最下面第一天 上午足球踢远考试前训练摔得，我对面那兄弟踢得老远，我去捡球，一时间兴奋，跳起来踩住球,自己却没稳住脚踩在球上面落地摔，脚内侧接近80度内弯，外侧剧痛，手肘擦地出血，屁股处的骨头感觉要断了，(看着我摔的同学没一个人过来？？？良久，还是没有一个人过来？？？excuse me?)然后感觉自己还能动的时候走到了厕所 (感觉良好)，在厕所洗手..然后动一下腿都两眼全黑，差点晕倒在厕所!赶紧老实了不动了，让自己紧紧扶住墙靠着洗漱台，然后用小爱同学打电话给了室友zy，结果zy的手机在寝室 然后等了好久眼睛能模糊看点字的时候打电话给了yzh，结果yzh手机在别人包里面— &gt; 人间悲剧 好不容易扶着墙跌跌撞撞走到了操作入口处，向一个同学qhz挥手，没有理我…向来上WC的电三同学求助，让他帮我叫一下yzh，他说先上厕所，让一个高高瘦瘦的人叫老师，他说老师在测成绩应该不会过来—&gt; what’s your problem?你看不到我快要死掉的样子吗？ 感想以上都是我没有体现出自己的受伤情况的严重性,所以他们都视若无睹 — &gt; 以后我一定要多多关注别人的表情细节,因为很可能别人急需帮助 然后就是叫来了yzh，然后yzh把我背到了校医院，帮我挂号(校医院收款处竟然因为最近大四学长学姐毕业退款导致自己垫了钱啥的然后不能用支付宝了，只能现金) 然后也不先急救… mdzz(原来是不会死的情况下就不会先救你，而是按照交钱和挂号排队慢慢来，当然急诊的照片什么的都会提前，然后也会无需挂号)—&gt;不过我去校医院等待治病，他还在和别人(一个以前的病人)互喷一些钱的东西—&gt;让我对校医院产生了比较不好的印象… 后面yzh又帮我去买冰棍让我冷敷，然后买了牛奶和面包 然后又体育测试完又背我从校医院到了901，太感谢了，明显感觉他背我很累 中午资询了以前有脚踝扭伤经验的同学xjy，ta详细地和我说各种就诊操作-&gt;现在想想，必须感谢ta 下午zy不上课陪我去看医生，然后还好他带了身份证，全程用他的身份来就医的(在医院遇到的很多人的情况都比我严重,心疼他们) 然后zy陪着我打石膏，细心地带我去厕所帮我询问什么的 回来后感谢xjy和bh的看望，我叫xj帮忙带饭，xj的叫bb帮带饭，bb和kcn的慰问，然后中途碰到 zy学长 的细心慰问，感觉世上还是很多爱的 自己装B不用轮椅回寝室，结果累死，然后叫zy来帮我，zy叫孙崇山来帮忙，然后孙把我背了上楼，感谢 晚上大家教我如何单腿上床，如何单腿下床 尴尬: 被yzh背着自己不好意思看前面，感觉自己好没尊严 下午坐着轮椅很尴尬 下午因为不好意思出去上厕所，憋了好久的尿的尴尬 晚上发现想上大厕，发现要单脚蹲大然后憋着的尴尬 晚上想洗澡却只能擦一擦的尴尬 晚上回去因为到时候没人给我抬轮椅而直接用拐杖回去的尴尬 晚上要没有贴止血贴，手肘满是血，然后脚上是石膏睡觉的尴尬 明天要考电磁场电磁波了，自己6章只复习了前3章的部分的的尴尬,但是晚上复习的时候又老想着这几天怎么过的尴尬 认为没有什么比活着更重要，然后又想要记下此篇生活，所以就干脆不复习了 2019年6月13日23:24:49 回去吧，大家都在准备明天的考试，所以不能最后一个走，不然可能又要麻烦别人了，所以自己回去吧 不想告诉家里人我腿受伤了的强忍，以及自己感到孤独和无助的尴尬(其实自己是很想很想要一个人来帮助我的,但是又不想打扰身边同学的生活,也不好意思让他们帮我但又想他们帮我的尴尬)(更不想让家里人知道了担心，虽然我觉得可以轻易接收家里人的爱，但我也爱他们，我不想让他们为我太担心，所以我还时是不能告诉他们) 感想:以后一定多多帮助身边的人以后一定多多观察身边的人是否需要真的帮助以后一定多多观察身边的人是否需要帮助但又不好意思，学会假装碰巧去帮助别人第二天 感谢zy早起去帮我去901门口拿轮椅回到寝室楼下接我 感谢zy把我推到考场 感谢xj给我带午饭(以后对任何身边的人都当亲人一样地给予帮助，因为不这样做的话，说不定你那天就腿瘸了，然后大家都不帮你是最恐怖的，而且你平常不对别人好的话，在你为难的时候你也不好意思向别人寻求帮助，比如你想要xj给你带饭，但你又想到前段时间你拒绝了帮xj装内存条！所以你会无比愧疚，所以将心比心原来不是这么容易学会的，而是要经历生活的磨炼才能学会的，感谢生活) 以后一定要多多关注别人的难处，帮助别人 今天第一次成功单脚蹲厕(右腿小麻) 然后zy晚上带我会寝室 今天擦澡，洗身体，洗头发，换衣服，结果一屁股坐下去，直接右膝盖关节直接抽筋，现在每次膝盖收缩性略弯都会痛，一个人在厕所里面坐立不安地换衣服，真的好难，没想到残障人士生活这么难，这么苦，我才发现四肢健全的生活是多么难能可贵 妈妈突然打电话过来了，吓死我了，我还以为导员告诉我妈我咋了呢，还好没告诉，当妈妈问我最近怎么样，让我注意个人卫生，等等的时候，我差点没忍住，差点哭出来…因为我没办法洗澡，只能搽澡😭，然后有那么一瞬间好想告诉妈妈我受伤了，我好想妈妈给我安慰，但是我不能，不能让妈妈担心，对不起，妈妈，我不能让你知道，之后也不能让你知道，否则你以后一定会总觉得我有事没有告诉你，对不起，妈妈，我爱你(忍住泪水) 第三天 感谢zy推我去实验室 2019年6月15日08:15:01发现自己过来实验没有带电脑，然后发现自己上次CV好久的数字钟的代码在电脑里面，算了，腿伤了不方便，所以直接再搞一次吧(xj本来说要回寝室所以不帮我带饭，结果还是来了901，可能东西在这边吧，不怪她) 感谢gpc主动帮我带饭 2019年6月15日15:56:42 下午拉肚子了然后回来时拐杖蹦蹦蹦声音太响，门口那几个都看着我，尤其是jmq学长(那个有188的博士生学长)然后我和他对视了一会，轻声念叨:绝了 下次记得微笑回视！ 不要总想着尝试走，一周后再尝试走，遵从医嘱！ 因为我差劲的社交，导致我现在要别人带个饭都这么困难(因为大家今天考完英语6级了，都直接出去浪了，所以也不好要别人给带饭…)，有些时候，真的很无奈，很伤心，很无助…只能少吃几顿……….但其实病了不能少吃…哎，算了，忍受3周吧 [ 现在才过了22 天,都有点感受不太到当时的感觉，不行，保持原汁原味的记录 ] 不要这么没有出息，谁都会有无助的时候，在自己被自己之前的愚蠢导致一手烂牌的时候只能努力恢复，然后吸取教训，以后避免风险 –&gt; 不准哭,杀不死只会让你更加坚强 受伤之后还敢爱————&gt;做自己的真正的英雄(不要把精力浪费在这里了!花了30mins发呆了,这样毫无意义) (如果你不保持经历苦难,新的苦难出现的可能性就越来越大) 所以等痊愈之后坚持健身锻炼，坚持看书，坚持写项目，坚持社交和口才锻炼 2019年6月15日18:25:33庆幸自己没有死掉，我一定要好好活着，等到痊愈之后更加要好好活着，上帝一定会让勤奋的人站在他面前！ what is dead may never die,but rises again harder and stronger. 逝者不死，必将再起，其势更烈 第四天一天呆在寝室，中午晚上wdc都给我送饭，然后就是晚上wdc还帮我锁大锁，真好，这是我腿受伤以来最开心的一天 第五天 今天又是待在寝室的一天，然后10点吃了zy给我带的早餐…为啥他不带中餐呢他也很尴尬 下午饿了吃了多包辣条 然后晚上让zy给我带了一个酸菜肉堡 想到明天周二突然陷入了极度痛苦不愿 面对 “明天下雨，中午饭不怎么好让别人带，上三楼上课的尴尬境地之中”—&gt; 算了，办法一定比苦难多，只有不可预测的一些因素才让生命更加丰富多彩 下午吃的辣条在空调的袭击下导致肚子很痛了，然后就等晚点人少再去拉屎，先洗头吧 然后又折腾了许久，不过比上次好多了，加油，别人四肢全断都在认真生活 第六天 由于室友大家没有早起，导致没有吃早餐，2019年6月18日10:44:45 饿了，难受 2019年6月18日12:42:41 今天中午xj帮我带饭，然后自己也直接带饭到了9楼，她出去吃的，很抱歉…… 所以以后除了周二和周四,都直接待在寝室…因为跑腿腿可以直接送到寝室门口 [之后因为羞愧再也没有要xj带过饭了…—&gt; 以后如果真心帮助别人也要尽量不动声色得帮助，别让别人难堪，导致别人下次再也不敢找你帮助了 ] 多了一种视角，你是否会麻烦别人却没有给与相应的价值(比如让xj带饭，麻烦了别人)，所以还是尽量使用服务业提供的服务 我的包–&gt;5本大书-&gt;knotex电脑 感谢下午lky给我带饭，帮我带包上3楼 感谢超哥吃完饭理完发推我从C座到寝室并且帮我带包上6楼感谢啊感谢 第七天 睡了10小时，emmmm第一次把腿垫高睡，有点不适应，然后梦到自己腿好了，石膏都被自己撑坏了，梦醒之后，石膏依旧 就不该看《胡广生》的MV，导致自己哭的稀里糊涂，不成样子 刚刚想在寝室上个厕所，结果蹦蹦蹦，右脚踩入茅坑，不过还好只是轻微砸了一下关节骨，没有其他伤害，左脚还好有石膏，所以只是震了一下，还好 试了一下，左脚能够比较好的动了，只是不能承重，所以还得一段时间静养—&gt;结果今天折腾过了头，反而造成了一定损伤。mdzz 又看了40mins脚踝如何恢复，佛了，然后认真做实验(EDA实验) 真是疯狂折腾受伤的韧带！小心后遗症！所以每次去厕所都小心点!好吧 —&gt; 1、 伤情被自己整到恶化 2. 然后大家这段时间都很忙很累，心情很烦，所以还是最好自力更生吧，天将降大任于斯人也！ 晚上我没有问清楚就让zy和wdc带饭，结果可能他们因为忙都来不及去吃饭，所以还锁他妈的大锁，所以他们就没有回来，没有给我带饭，理解别人的难处，别人都已经仁至义尽了，谢谢，真的谢谢 2019年6月19日20:27:25 留寝被查，真好，生活再难，也能活过去，脚伤期间，各种事情的重要性会变的，让我变成最差的学生吧，I don’t care！ 太浪了，花了太多精力去抱怨生活不公！第八天 昨天瞎折腾，导致伤愈情况表得糟糕了，艹，犯错难免，以后警惕 习主席说的对，只有经历了大风大浪还不倒的才是大海，才能看淡其他风雨，才不会想一个小池塘，遇到大风浪是会倒下，所以接受脚伤现状，努力改善，积极变得更好，我治愈之后会更加强大(就像高考前的一段慢性肠炎，然后运动了好长一段时间，这次，我将运动到我不在的那一天，文明精神，野蛮体魄) 放下手机，认真生活 暴雨，然后VHDL课后孙先没走，先问我要不要帮忙，我说等雨小，你们先去吃饭，别管我 然后下雨被困11教，发现11教很多教室不开，沃日，于是先在一个人少的楼梯那里等雨停，看书，之后小雨再回去 后面楼道开始有蚊子…日 感谢一个阿姨提建议让我 和学校反应让我去申请住一楼 [ 当然我没有去申请 ] 成长 今天成长还是很大的，首先是在zy帮忙打伞的作用下，在中雨中从寝室走到英语课教室 然后晚上在11教等雨停了，自己又拄着拐杖慢吞吞地走回了寝室，其实自己还是很叼的哦 第九天 拄拐去打水泡咖啡，自己爱护自己的身体，然后才能为全人类贡献80年！(100岁退休，工作过程也可以享受生活) —&gt; change the world , make some difference! 2019年6月21日12:50:59，我问zy还回来吗，然后zy说他在星达，以后自己不要把鸡蛋放在同一个篮子，风险太大，早上他答应我给我带饭，于是就一直等他，结果我笑了，算了吧，别人帮你，你得感谢，别人不帮你，那是理所应当… 从来不想给别人造成麻烦，可是现在自己腿伤了只能给别人造成麻烦，难受 喝完那碗胡辣汤[是跑腿腿送餐到寝买的,我的整个思想是 朋友不会永远帮你，但是有钱可以一直买到服务 , 当时的思想也很有趣]，我整个的思维全被 跨越阶层 所占据，我一定要成为一个高阶层人士，实现财务自动增长，看遍世界各地的各种世间百态，成为一个独立，自律，无往不利的我(不要幼稚，活成一个普通人在很多方面都会受到巨大的限制，你永远无法获取更多更好的资源，你永远要忍受别人的压迫，每一天接受残忍社会的教育，在你现在还有机会的时候，努力跨越出你的阶层，成为自己的英雄，然后再去改变你想要改变的世界) 发现自己前天的折腾导致脚踝肿起来了，今天才发现，我服了，下次再也不折腾了！慢慢养吧，一个暑假，不急，到时候人就少了，而且没有关系，慢慢养 然后查资料发现是脚下垂太久，血液不流通导致的，而且绑带有点紧，所以晚上抬高会勒住，所以也会有影响，把腿架起来就好多了 15点开始又认真学习如何治疗韧带拉伤 学了1小时如何恢复，zy回来了，让他教我AD，然后zy20mins解决了我可能几天都解决不了的问题，真好 发现抬腿坐着屁股剧痛，然后不抬腿脚又浮肿，自闭了，所以今天先早点躺着吧 第十天 感谢炒饭阿姨把饭端到桌子上去给我吃[当时10点我去错峰吃饭] 感谢一个微胖小姐姐看到我出一食堂马上快步过来给我拉帘子 WC是我避开密集人流的避难所，所以感谢学校的厕所多[终于理解为什么厕所是社会的包容发泄所避免所了] 回9楼的时候遇到了hsj老师，他好像才知道我伤了 想着不要去看复查干什么，但是身体却很诚实地去干了…看了一个小时，基本上都是看过的，算了，不看了，认真学习，晚上吃鸡后睡觉，明天养足精神去复查 今天拄拐正常生后一整天，然后上帝都奖励我的乐观和勤劳，让我到楼下想掏出手机时正好快递电话来了，这快递比预计时间早20mins，真好，大吉大利，今晚吃鸡，庆祝脚伤但坚挺到了第10天 吃了一个小时的晚饭，然后直接上床休息，看视频，看书，争取明天复查有个好状态 晚上偷偷拆开一点点脚内测石膏，发现一片紫色，绝了，才发现，再撑拐杖10天吧，然后发现屁股那块骨头也没太好，还是痛–不过那应该只是轻微摔伤骨头，应该没有大碍，主要是脚 讲真的,自己当时每次复查前都极度渴望复查时能卸掉石膏,是石膏生活的不便以及麻烦别人的尴尬让我有了这种超强的欲望第十一天 凌晨涂了本草精华液，结果没想到药效如此猛烈，直接吸血一般，导致我左边大腿的血管都有明显地感觉到左脚关节处在抢血！！！左脚关节更是风起云涌！ 5点50梦醒，6点50起床 感谢司机看我不方便开到校门接我后倒车，7点35在车上 第一个就诊，结果去打石膏搞了好久好久，真TM慢 脚部抬高好像真有用，因为脚有时候好烦一阵一阵的翻涌 那个医生说让我加固石膏，下周继续复查。然后那个帮我拆石膏的人说让我走一下，我愣了半天，他说，你怕啥，我才走，发现竟然可以走，就是有点小痛，我惊了，然后那打石膏的医生让我多躺着 先学习吧，晚上再想吃饭的事[基本上每到饭点必定发愁] 发现脚抬高过久也不行，因为脚后跟会有痛感 感谢zy带的酸辣粉，不过一吃肚子就有反应了，我去WC 第十二天(含巨量的腿伤的日志及感想)摔伤日志 我会告诉你我跑到双子楼11去请假再去综合楼盖章，再去食堂买饭，再爬6楼回寝室吗？我会告诉你途中我去二食堂上个电梯摔了一下伤腿吗？我买14块的饭菜不好在那吃而错过好喝的酸梅汤吗？ 不，我不会！我只会在人多的时候走快点，在没人的时候先停下来休息一会继续上路，我只会在没站稳后立马调整，只会在摔倒后立马起来，之后在悲伤的时候劝说自己积极乐观，勤奋坚强，只会每天偷偷扯开一点点绷带偷偷看自己的恢复情况，只会每天梦到自己腿好了，又变回了那个走路像一阵风的骚年，只会…… 虽然有时候也会在心里诉苦， 啊，我的酸梅汤没喝，亏了！ 啊，为啥用剪刀剪掉绷带的所谓石膏拆除费要27块？下次我带把剪刀过去自己拆好不好啊？ 啊，别人不帮你是理所应当，别人帮你你得感激涕零，是啊，世态炎凉啊，还好还有那么几个好朋友愿意在他们方便的情况下帮帮我，感谢了… 懂得: 别人不帮你是理所应当，别人帮你你得感激涕零 努力赚钱，因为别人不能帮你的，你可以通过用钱去买到送饭到寝的服务 那些不愿在你痛苦时给你施以援手的朋友都是所谓的朋友而已，不要太较真 以前发现妈妈只会通过分数对你严管或者松管，总结出的”价值决定一切”其实用在这个现实的社会更加合适不过，所以，我要努力创造价值，make a difference，让绝大多数人都希望我健康地活着，不管是真诚的还是价值捆绑的 珍惜那些真正的朋友，努力报答他们，耐心帮助那些真正需要帮助的人 不要把太多时间浪费在抱怨上面，真的没用 表现得越强大，获取的帮助就越少，但之后你会成为真的强大！ ？？？ 说来有点奇怪，第一次叠完衣服，不放柜子，放床上，竟然是为了:垫高脚 :-) 第十三天 感谢中午余镇榜给我带饭到实验室 [当时在做模电课设] 第十四天 下午吃饭到1点半，然后看别人伤病恢复记录，发现别人恢复了好久好久，莫名害怕，还说软骨损伤不可再生，哭了，还好及时制动，2点33开始认真写完硬件作业，然后上床复习模电吧 第十五天[2019.6.27] 伤腿告诉我，我没必要花时间做不必要的社交，比如寝室去K歌，很蠢，因为大家都很个人化，所以你也无需牺牲自己去迎合大家，你就是你 老师让我过来，结果大家踢比赛，老师做裁判，我在这看着，老师还没理我，emmmm，算了，先坐着看书吧 [ 后面老师看在我平时成绩还不错的份上，但是又不能让我分数高过其他人，所以折中给我了80，感谢 ] 背电脑回寝室… 第十八天 7点21拼命走快点，4号楼6楼到3教302拼死用了21mins，你真棒！ [去考大物实验笔试] 再撑3天3夜就可以洗澡了，身上好多地方可以戳出生推瞪眼丸 [尽管有搽澡] 在厕所躲避人流20mins回寝室，不想去食堂了，很累，回去吃面吧 然后花了1小时回寝室(走得路长了，右脚关节痛…)休息，浪，吃面(大脑都缺氧了，才吃早午餐，下不为例) 感谢晚上zxb帮我带板子送归实验楼，并且帮我带饭 [后面才知道他先去吃饭，然后带饭回6楼给我，然后再去实验楼] 第二十天 考完模电提前40mins交卷，实在写不出了，和翟老师说明情况，她让我再看会，我说有点地方没复习，实在写不出了，就走了 [ 其实当时还有一个很重要的原因是自己需要去错峰吃饭…] 第二十一天(第二次复查之日,也是医生说的3周之日) 凌晨3点，3:00噩梦醒，噩梦是医生说不做拆线检查，应该是多余的担心，继续睡 [ 没想到当天真的没让我做核磁共振检查 ] 艹，4点28又以为7点了 5点14天亮了，6点，6点半 都醒了 日 还没7点 绝了，看来积攒了21天的期望值，情绪有点激动啊 5:59逼我设置6点半闹钟 7点25在校门口遇到vhdl老师，叫他没听见，就一直看着他没叫第二次，他戴着墨镜.. 等了接近20mins，然后自闭了，然后一个识货的知道学生腿伤都是踢球导致的私家车司机过来说10元，比出租车多2元，等到自闭的我管不了这么多了就做了，和他交流，他说这个点大家都上班，本来就很难打车 唯一不爽是他抽烟了… 然后这人看我好像不识货8元给他10元(要不是打不到车，我会多给你2元？)..想让我在对面下，我拒绝了，还好我没有继续傻 8点16苟到了等候就诊区 那老医生一脸不屑，让他的小助理给我开单……就问我骨折没，多少天，然后肿不肿，片也只看了一小会，我说我左边也痛，要不要核磁共振，他看着我不说话，我去，20块，就这样没了… 然后我回家自己拆掉，牛逼！温水泡脚，再拄拐两三个星期 完成了小时候长期不洗澡的梦想，也完成了这21天的梦想，我要洗澡，回来的路上，每走一步就在心里默念一下我要洗澡我要洗澡(受够了搽澡) 今天洗了可能有生之年最快乐，最充满期待的一次澡今天解锁:先左脚下一节台阶楼(伤腿)，后右脚跟上[上楼其实比下楼简单，因为不要比较大的关节弯曲，终于理解为什么这么都伤腿分享的小伙伴都说下楼痛了] 第二十二天(拆石膏第二天)解锁踱步下楼(左下一，右不用跟左脚，可以下下一节台阶，但是有点痛)之后2019年7月6日11:10:34今天是拆石膏第4天，也就是第24天 就是每天做康复训练，网上找的 热水泡脚 搽活血的药物 总结以及学到的 伤腿的日子里面自己也看各大平台的经验贴，基本上每天都看，有些贴子都看了好多遍了，分享一个写得比较搞笑的贴子截图—以及对单腿蹲厕的网友体验 以后设计产品一定要尽可能多的考虑一下是否有少量人士使用我的产品会产生不便 学会了换位思考 更珍惜健康和时间(生命) 更加珍惜那些在困难中帮助我的朋友们(yzh,zy,wdc,yzb,zxb等) 经验 尽量多休息，把脚抬高 不要轻易尝试走动 过程大概是:红肿-&gt; 消肿(打着石膏容易产生已经好了的心理,此时千万别做出过激的尝试) -&gt; 微肿,脚面发紫(就是很多毛细血管损伤的那种) -&gt; 肿越来越少，然后发紫也变少 -&gt; 小腿肌肉恢复 -&gt; 能够单腿平衡很久 康复训练多锻炼小腿，这样才能早日走路 祝愿 伤病的时间确实有点难熬，不妨利用此段时间多多看书，提升自己，加油，祝愿你们能够早日恢复到日常走路带风的样子!]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第十周(10-521)]]></title>
    <url>%2F2019%2F06%2F30%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC%E5%8D%81%E5%91%A8-10-521%2F</url>
    <content type="text"><![CDATA[Algorithm最近考试加腿伤,刷题太少,惭愧 ReviewDecrypting Blockchain最近facebook发行了Libra币的白皮书，这是一件世界级的大事，因为它可能影响全世界的货币格局，也可能是美国想用新的技术手段来巩固他们的美元地位，而且可能造成货币垄断，所以这周给大家分享区块链的科普，更深入的可以自行搜索Libra然后多多关注 TipsLIBRA, EXPLAINED 最近一直在极客时间学linux，所以Tips本应该是极客时间的文章，但是想到你们看不了，所以放了对Libra币的讨论文章 Share最近一直在极客时间和得到学习，而且也在忙考试，和腿伤休息，所以这周的分享比IT技术分享高一个维度，是人生管理分享如何快乐生活,忙而不碌]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎么成为时间管理的高手-听书有感]]></title>
    <url>%2F2019%2F06%2F29%2F%E6%80%8E%E4%B9%88%E6%88%90%E4%B8%BA%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E6%89%8B-%E5%90%AC%E4%B9%A6%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[第一讲 规划与备忘1. 项目管理表 做计划，细分计划，不重不漏，然后头脑中要有想象，设置截止日期！(不要不设置截止日期) deadline可以用来反馈，若此次没做完，下次做相同任务量任务可以更好设置截止日期————主要目的是让自己对时间有个概念 设置进度提示:进展不顺的子项目要标红 ， 正常进行的标绿 2. 所以要有日历表,日程表日历表 先做重要的事情，先放石头，再放沙子—&gt;长期投资的事情，巨大红利(技术长期积淀) 好的日历计划不是填满每个小时，而是留有20%缓冲，截止日期也是20%缓冲 日程表 每天事项划掉是感觉很爽的 第二讲 行动:把时间变成产出1. 把事项改成动作把事项改成动作,而非一个大任务,若是大任务,就分解成小动作,让每个当下只有一个动作 2. 干扰多，事情杂怎么办? 悬而未决会让你受羁绊—所以4板斧解决 1.转让别人帮忙做，若这件事情有人比你做的更好，而且不是必须需要你在场，那么就可以让别人帮忙做，让这个任务更好地被完成 2.做 虽然说要事优先，但如果一个动作只要2-3mins，那就马上做掉，防止占据大脑内存 比如: 一个实验之后，马上和别人探讨写完报告总结。因为这时候印象最深，效率最高，就算当时很累，也很值得 3.存存起来(马上放日程表)，以后做–注意不要放在大脑里面,否则会影响自己全情投入 4.扔不重要的，可以直接扔掉 总结： 不要让自己的大脑被占据担心自己做不好而拖延怎么办? 面对大人物做报告，也把对方当做自己的学生，因为你是专家 反正要做，不如找个积极的心理暗示 和别人交流，听取别人的建议 2019年6月29日 学完上面并做笔记 2019年6月30日15:38:22 开始下面的学习 第三讲 敏捷工作法:让计划赶上变化不要把时间浪费在努力工作中完美主义的时间浪费完美有代价，把一件80分的事做到了100分，导致其他很多应该做到60分的事情没有做 范围蔓延别人要求帮不是你要做的事情的时候,不断让步,结果自己帮别人做了好多事情 返工没有沟通好，需求没有谈好 敏捷工作法最小可交付,持续迭代把自己的每个输入，处理，要想做自己的输出，自己要干什么 最小可交付，就是做一个小demo，然后大家提出反馈，让你可以调整，这样就不用大的返工 别人给你任务，你给别人的deadline为第一次交付的时间 交互一个小交付后，你就可以做下一个任务了 如果多个项目重要的事情多迭代，紧急的事情先迭代 敏捷工作法， 不要进行多个任务，让手里只有一个项目 第四讲 管理合作者的时间透明的沟通习惯 做决策的时候就拉大家过来一起决策 同步站会，让大家站着开会同步进度 让自己的任务进度能被看见 尽量当面沟通！能见面就别打电话…能打电话就别发邮件… 敢于和上级沟通时间 管理者只会记得上面的任务,不记得给下属的任务 主动给上级反馈你的进度，让其对你的任务进行重要度排序，这个也很受上级欢迎 团队领导如何管理上级 不要把下属的事情自己做,不要所有事都亲力亲为 下属不是因为成长而能做事情，而是因为做事情而能力成长 下属让你帮忙做，你要思考最终责任人是你还是他 担心下属能力，就从小的任务开始训练他，比如给讲PPT，一次给他3mins等等，然后慢慢渐渐增加 第五讲 如何与忙碌相处 忙碌的人完成事情更快，而且不容易错过deadline，闲的人反之 我们要避免内卷化忙碌就是被自己忙死，但是恶性循环，没有时间提升自己 改善:要做到自驱模式的忙碌确定计划确定自己的人生计划 这种计划一般是除了本来要做的事情外 开创新领域 自己想做的 这种事情会让自己很快乐的，会产生积极的情绪，然后良性循环也会让自己做本职工作的时候效率更高想象自己定的目标是给未来的简历 给学习留出足够的投入 在学习上，投入自己心痛的钱(可以自我提升的比肩自己每天工作赚取的钱)这样自己就会非常地重视，并且努力学习，并且会积极主动地学以致用 最后发现人生最大的成本其实是时间 跑出自己的良性循环让自己的技能提升，然后马上使用自己提升的技能 对于制定人生计划:自己10年想要什么是想不明白的或者说很难想明白，要做的是不断迭代自己，在自己本职工作上面，尝试自己的兴趣点的一个小任务的迭代，每次如果都有好的结果，那么就多迭代一次，多多探索，直到自己发现自己学习到了有能力胜任新的职位的时候就可以对自己的人生进行一次大的迭代，就是找到本职工作和新技能工作的能力交叉的工作，然后就这样持续地迭代自己的人生 注: 当然如果你一开始就有一个人生目标，然后你的每一次小的迭代都是往这方面进行的小迭代，小进步，这样就更好了，有目标地探索，能让你走得更有方向感，离成功更加容易到达，因为一直在向着目标走啊！ 总结 管理时间就是管理人生时间就是生命，管理好时间就是管理好人生 让时间服务于你，而不是你服务于时间，这样你就能过上自驱的快乐忙而不碌的生活，然后就能有充沛的精力去陪伴家人，去享受生活 最后祝愿大家能幸福健康，职场节节高升!过出自己想要的人生! 单林敏(wolfdan) 2019年6月 于合肥]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第九周(9-521)]]></title>
    <url>%2F2019%2F06%2F23%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC%E4%B9%9D%E5%91%A8-9-521%2F</url>
    <content type="text"><![CDATA[Algorithm最近踢球脚扭了，不能走路，要休息，所以刷题较少 ReviewThe Internet is changing your brainWe can remember the things that we need to remember but, forget the things that we rarely use. That is not a problem, it is entirely sensible and should be expected.我们要在变化快速适应，要积极求变，不断进步，终身学习 Tips 当然要推荐且必须要放耗子叔最近新发的文章啦 如何超过大多数人 就是不管干啥都要多多访问官网，比如配置next，官网才是最新的资讯因为自己对busuanzi统计的折腾，发现还是官网好啊 NexT 使用文档 Share在另一个终端上同步写HEXO AD14.2如何安装各种库 安装破解Altium Designer14.2]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AD14.2如何安装各种库]]></title>
    <url>%2F2019%2F06%2F17%2FAD14-2%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E5%90%84%E7%A7%8D%E5%BA%93%2F</url>
    <content type="text"><![CDATA[AD14.2如何安装各种库我们先以安装NSC Amplifier.IntLib为例子安装文件由于我不知道NSC Amplifier.IntLib在哪,所以我直接搜索找到了这个官方网站的一直文档分支链接进入之后看图操作下载吧下载 使AD软件链接路径 开心食用 下载各种库？当然是找官网啦啦啦官网老库 注意:你清楚你要的库是哪个大文件包–&gt;否则1.谷歌搞清楚2.自己下载整个库解压后搜索 最后注好像又是重复造轮子，搬运工，所以大家多多了解这种解决方案的思路啦，以后多多触类旁通啦 谢谢大家的浏览啦]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>总有一些事情值得</tag>
        <tag>hardware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在另一个终端上同步写Hexo]]></title>
    <url>%2F2019%2F06%2F17%2F%E5%9C%A8could-studio%E5%90%8C%E6%AD%A5%E5%86%99Hexo%2F</url>
    <content type="text"><![CDATA[在另一个终端上同步写Hexo用Cloud Studio做示范,其他非linux可以适当借鉴 2019年6月17日20:49:03发现Cloud Studio发布的环境也没有保存npm！所以只能每次都重新安装，所以小编将会加急写个脚本出来–&gt;结果发现在cloudstudio运行脚本各种奇葩bug，所以大家要用cloudstudio写hexo的话可以每次粘贴一下下面的程序段，当然建议直接在本地装吧，这种免费但不怎么稳定的东西用着心累1234567echo "-------CloudStudioWriteHexoOnce-------"curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | shwget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | shexport NVM_DIR="$HOME/.nvm" &amp;&amp; [ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh" # This loads nvmnvm install stablenpm install -g hexo-clinpm install 1. 添加密钥并且Git pull你自己的仓库由于本着不重复造轮子的心态,所以不会云备份Hexo的朋友们可以看某大佬写的文章 2. 安装node.js安装 Node.js 的最佳方式是使用 nvm cURL: $ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh Wget: $ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh 配置nvm环境 export NVM_DIR=&quot;$HOME/.nvm&quot; &amp;&amp;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 安装完成后，重启终端并执行下列命令即可安装 Node.js $ nvm install stable 3. 在blog的根目录安装依赖 注意:blog的根目录就是你之前hexo init &lt;folder&gt;的这个foldernpm i 然后测试hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 4. 写新文章测试 5. 发布自己的环境 这一步十分重要！！！ 博主就是由于之前这一步没做，导致了环境重置 因为cloud studio的工作目录和环境是分离的！ 丢失环境只能重建 发布自己的环境 谢谢大家的浏览啦]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装破解Altium Designer14.2]]></title>
    <url>%2F2019%2F06%2F16%2F%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3Altium-Designer14-2%2F</url>
    <content type="text"><![CDATA[安装破解Altium Designer 14.2.3 http://pandownload.com/ 百度云盘第三方不限速版软件(小单推荐) 欢迎访问wolfdan.cn AD软件链接：https://pan.baidu.com/s/1m6mNk_uqHGb3q6Moc1zqQA 提取码：eqyo 2.1用1打开这个链接，然后下载，只下载两个压缩包就行了， 2.2然后一起解压到当前目录 2.3看视频安装 个人分享链接:https://pan.baidu.com/s/1EHtVTZWtefQwVn6GVleE6g 提取码：zhf1(防止上面失效用的) 注:不好意思，好像重复造轮子了,dbq,但希望能帮到你…用完即走就好(毕竟是工具性质,分享性质的网站)]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>总有一些事情值得</tag>
        <tag>hardware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第八周(8-521)]]></title>
    <url>%2F2019%2F06%2F16%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC%E5%85%AB%E5%91%A8-8-521%2F</url>
    <content type="text"><![CDATA[ARST打卡第八周(8/521)探险就要做好面对乌云密布的准备注·最近因为踢球脚韧带拉伤了,所以最近喜欢看比较悲壮的图片,希望大家多多注意身体健康 AlgorithmARST第八周的刷题 ReviewDevOps: Tools vs. MindsetAnd it is so true: without developing a collaborative environment within the teams, and a culture to adapt to continuous change, no organization can claim to have achieved DevOps implementation success, no matter what tools or technologies you use.对的，通力合作才是最棒的DevOps Tips一个大佬的求职逆袭 Share如何使用一个域名同时构建Hexo和WordPress]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用一个域名同时构建Hexo和WordPress]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%9F%9F%E5%90%8D%E5%90%8C%E6%97%B6%E6%9E%84%E5%BB%BAHexo%E5%92%8CWordPress%2F</url>
    <content type="text"><![CDATA[两把椅子，看见同一片美景 wolfdan blog主本人的配置:其他配置可以灵活参考 BT面板管理的WordPress 腾讯云管理域名 Hexo分布在github page和coding.me pages上面 使用的wolfdan.cn做WordPress的域名，www.wolfdan.cn做Hexo的域名（主要是因为之前我的WordPress就是用的wolfdan.cn的域名,所以如果我想要反过来操作的话–&gt;那么1. 数据库里面不太好改的，2. 容易出一些文章链接不正常，3. 网站SEO会很奇怪–&gt;好奇的朋友可以自己尝试一下） 操作一.给coding重新绑定域名 我的是绑定www.wolfdan.cn，你们参考一下 去腾讯云解析,把github的pages解析关闭掉，然后www.wolfdan.cn只留下pages.coding.me的CNAME的解析(详细操作请看图) 这样做是为了顺利申请www.wolfdan.cn的域名的SSL，因为如果还开着github的那个解析会申请失败(可以解决问题:coding申请SSL失败) pages解析 二.绑定好其他域名 去github.io仓库的setting设置custom domain的域名绑定 Hexo的你的博客根目录下的source根目录下新建一个CNAME文件，里面写上你刚刚绑定的域名，这样是为了防止每次发布后重新绑定github的域名 用@记录绑定自己vps的地址 最后解析的画面 在bt面板添加网站并申请ssl 添加网站申请ssl 修改wp-config（看情况是否需要操作） 开始测试玩耍收工咯注： 测试效果的时候，谷歌浏览器要输入网址的话，域名最后一定要加/,比如blog主的https://www.wolfdan.cn/，否则很可能出现谷歌智能跳转到以前访问过的https://wolfdan.cn上面去(我就在上面花了好久时间…) 提前谷歌了一下，发现自己应该没有重复造轮子，才写下此篇，2019年6月15日19:03:53应该没有重复造轮子，感谢大家浏览 由于自己是5天后才写的，所以难免会有很多纰漏，如果大家有哪里看不懂的可以给我评论留言，谢谢大家的浏览和支持]]></content>
      <categories>
        <category>域名</category>
      </categories>
      <tags>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[许岑老师的《如何成为有效学习的高手》读书有感]]></title>
    <url>%2F2019%2F06%2F12%2F%E8%AE%B8%E5%B2%91%E8%80%81%E5%B8%88%E7%9A%84%E3%80%8A%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E6%9C%89%E6%95%88%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%AB%98%E6%89%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[高效学习关关键词适合自己、学习方法、短时间、注意力、解决难题、设定目标，以及名师 找到适合你的学习方法 自然主义核心在于模仿，结构主义为的是创造 模仿类的学习–比如语言等,就是不断地模仿,不要花过多的时间去死扣结构 而学习创造性的学科时，比如艺术类，设计类，那么就要学好基础结构，这样才能有效创造 练习不必顾全大局，练习的时候就可以把练习的东西先拆解反复练习，之后在组合练习的时候再顾全大局 不要收藏，而是多碎片化学习(没有整块学习时间的情况下)，当然碎片化学习的前提是你要有一定的知识体系(比如你要会1+1=2吧) 不谈兴趣,用任务驱动学习 生活驱动,工作驱动,以教为学 生活工作中的一些事情推动你学习,那种就是很强的驱动 每次学习都要有教别人的任务心态去学习,比如写分享文章等,这样就能使得自己的学习变成一个强的任务驱动的学习过程，进而让自己成为一个高效的学习者 你99.999999999%没有拖延症 事情的重要程度决定了你的行动力,所以给自己要学习的任务的重要性加码 精致地对待自己的生活 买贵的学习工具(贵到让你心痛),那么你就会刻意学习了,因为这么贵,怎么舍得不好好利用,不每天都用几下,感觉少用一下都是亵渎钱财 平时生活中要有仪式感,比如好好吃饭 使用射灯,让自己有一种在舞台表演的感觉 进入高质量的睡眠,白天累到自己,比如超认真工作一天,睡前几小时锻炼身体,或者超级专注地玩游戏 设定有效的目标 首先要有足够明确的目标，强烈的任务驱动欲望，而不是自己的白日梦那种偶尔幻想级别的任务，否则太容易半途而废了，比如你要出国留学,你现在迫在眉睫地需要练习好口语,还比如你下学期要打ICPC比赛了,你要急速提升你的算法竞赛能力 直奔大师 在明确了自己的目标也就是自己要去到哪里之后，然后先来一次直奔你要去的地方的模仿(因为这里涵盖了兴趣和任务驱动),然后再是扎实地练习基础功，然后就不断地向着真正意义的大师慢慢进发 怯场是最糟糕的自觉。一个人他胆子变得比之前的大一点，能走的路可能就长一点 制造反馈 当学东西的时候，一定要想办法把学习的成功展示出来，应用出来 比如文字类的，写个总结(就是自己看着文章用自己的话来表述) 口语类的就给自己录音反复练习 动作类的就给自己拍视频然后看自己的动作是否规范，然后反复练习 突破瓶颈 解决自己的心态问题,在排除了技术问题后,要足够地自信 扩大涉猎范围,在你的专业里面,你要不断地积累 更加专注,请教名师 结语 如果自信来自于自律，那就是扎扎实实的自信。如果自信来源于幻想，那就是盲目的自信]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于认知,财富,阶层的听书blog记]]></title>
    <url>%2F2019%2F06%2F10%2F%E5%85%B3%E4%BA%8E%E8%AE%A4%E7%9F%A5-%E8%B4%A2%E5%AF%8C-%E9%98%B6%E5%B1%82%E7%9A%84%E5%90%AC%E4%B9%A6blog%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[洛克菲勒行事准则: 绝对不要把精力发在不可逆转的事情上面！(所以不要花时间去抱怨) 记录读书笔记以及学习技术的blog，让自己忘了详细细节的时候能够快速查找到，也让自己加深理解—&gt;然后想想怎么让人们能够轻松地给语音知识做笔记，这可能是一个爆点(脑电波？) 我们必须面对现实，现实就是没有那么多时间让你搞清楚一切，你必须做出当前限制下的选择！所以我们一般情况下是定好目标，选好方法，合适取舍！而非一直死磕！因为一般你不会一直做嗑盐，除非你是科学家，但你的梦想是伟大的工程师啊，所以你必须学会转变思维方式，确立目标，选好方法，合适取舍！ 虽然你喜欢一直搞通全部，但这是不可能的，你要接受现实，但你必须努力去达成目标，目标域内关键的东西必须搞清楚 围棋智慧，两只眼活，所以让自己算法能力练习到前25%，演讲沟通管理写作技能练习到前25%，那你就可以成为伟大的工程师，好的就是这样 多只眼更爽 自己需要表达+算法+思维不断强化 中国族群给哈佛这些私立学校捐款才能提高我们中国族群的哈佛入学率，而中国大学国家资助，所以只要多多纳税就好 美国自由，福利到，导致穷人不自控不自制，然后穷人很找就乱性生了孩子又容易单亲然后教育就不好，并且天天和穷人待在一起，思维觉得这样也好，然后穷人循环，然而富人反之，中国却可以让你有机会接触富人，让你在没有很强自制力前强制压迫你学习的机制，所以反而贫富流动性很好 中国也有分层，各处都有分层，但是分层的本质来自于思维方式导致的分层！你的思维是否就只是一个中产阶级的思维？ 底层用技术教育，中层用素质教育，精英层用决策教育(你说1+1=3，那其他人同意吗？) 顶级精英，培养你自行决策，让你学会选择，中产是提供作业，让你多样化完成 所以多练习自己的决策能力！！！选择去改变世界，永远不按套路出牌，成为英雄，超越自己的命运 跨阶层的人才是英雄 不知道自己知道是经验！是认知最高境界 人和人唯一差别是认知 提升认知1.自我否定(不能对任何事确定地说我知道)2.行动(知行合一，认知到重要的马上行动)(早死早超生)3.和认知比你高的人待在一起！！(找职业就找认知比你高的老板或同事)(腾讯开放各平台就可以和各大佬交流认知！！！) 风险投资人 == 用概率算法，是一种精密算法的概率游戏，富人思维，好的亲友环境可以给你这种思维]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARST打卡第七周(7/521)]]></title>
    <url>%2F2019%2F06%2F09%2FARST%E6%89%93%E5%8D%A1%E7%AC%AC%E4%B8%83%E5%91%A8-7-521%2F</url>
    <content type="text"><![CDATA[AlgorithmAlgorithm ReviewLearning Containers In addition to all the traditional work of a DBA, I’ll be adding a bunch of information on containers as I learn it. For good or for ill, a lot of stuff like query tuning, backups, HA/DR, and more, is NOT going away. 我认为:是的，容器化改变了运维现状，以后的运维师将会变少，但不会消失，极度优秀的运维师反而还会出现新的供不应求—从古至今，市场从而不缺技术人员，只缺技术人才，所以我相信对于运维职业消失的担忧其实和当下的CV程序员对于自己是否会被裁掉的担忧是一样的,因此，我们面对技术变革，唯一需要做的，也是一辈子都需要做的就是：终身学习，我也喜欢这个行业带给我终身学习的习惯 Tips:V2ray问题合集Hexo搭建个性化next主题 Share:Hexo和WordPress]]></content>
      <categories>
        <category>ARST</category>
      </categories>
      <tags>
        <tag>ARST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo和wordpress的选择]]></title>
    <url>%2F2019%2F06%2F08%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BD%BF%E7%94%A8Hexo%2F</url>
    <content type="text"><![CDATA[Hexo和wordpress的选择 1. 原来的服务器ip被墙了 因为原来自己的网站是搭建在国外的一台服务器上面，然后最近一段时间网络整顿，然后我的ip被ban了,然后我抢救了4天整,好不容易救活了,但是访问速度极其不友好,所以为了让我的读者能有最后的体验,我必须努力啊,然后我就想到了境内境外分流(其实也是受到一个学长的启发) 2. 因为维护vps太麻烦了 记得自己是最喜欢配置各种生产环境的一个人,前段时间还想过要做一个运维工程师来着,但是最近头铁了4天整,发现维护vps实在是太麻烦了,而且自己还有很多其他的事要处理,所以这种比较吃时间,可以做到的,但做慢了却会影响用户体验而导致自己熬夜也要肝的事情还是尽量少发生比较好一点,所以自己觉得让网站托管在大厂微软的github和腾讯的coding上面 3. Hexo的美化度比较高(个人感觉) 不知道是自己没有认真地看wordpress的主题还是怎么样,我感觉Hexo的美化度是比较高的,然而我看到的比较好看的wordpress的主题都是收费版的更好看,这让暂时没什么钱的我有点难受,而且觉得不太值得 4. 免费 真的,买vps不管国内国外,就连学生机都要至少10RMB/月左右,所以对于这种Hexo的部署分流方式，真是又快又好又便宜又省事,何乐而不为呢? 注: 虽然有些大佬可以薅到谷歌云和亚马逊云的羊毛免费使用一段时间,但是时间是有限的,而且还是有第一二个问题—网站容易被墙和维护vps困难 感言当然我不是说不能用wordpress，wordpress其实也是有很多好处的，比如 可以云端写文章(因为它是在网页端写作的特性) 可以搭建好了之后让一些没有计算机相关背景的作家使用(就是只要有技术的人定期维护一下就好)(当然这也不一定) 技术历史长，就是很多问题在谷歌百度上都能找到(而Hexo是一个相对来说新一点的东西) 做好真正重要的—————— 学习和创作 这些东西其实都是一些工具，我们最应该做的还是在自己感兴趣的地方多多努力，然后创造价值，再分享给大家，这才是最重要的，也才是我们写作的最主要的目的–&gt;帮助更多的人 2019年6月9日21:07:21 当我今天用着wordpress写文档的时候，想着以后再有不用这个了，心里有说不出的难受，毕竟这真是我亲儿子一样，养了几个月了，难以割舍的情感，而且云端写作的体验也是妙不可言，所以我决定还是wordpress和hexo都使用 然后2019年6月9日21:49:40 发现Hexo是组件化，然后很多都是链接别处的东西，所以很容易挂掉某个组件，很惨的那种，然而WordPress就是只要你的vps不死掉，ip不死掉，基本上是没有任何事情会出大故障的]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
