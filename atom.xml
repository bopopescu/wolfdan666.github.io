<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>狼胆</title>
  
  <subtitle>wolfdan&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wolfdan.cn/"/>
  <updated>2019-09-17T13:51:59.376Z</updated>
  <id>http://www.wolfdan.cn/</id>
  
  <author>
    <name>单林敏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CF123D_SAM_算法日常[27/100]</title>
    <link href="http://www.wolfdan.cn/2019/09/17/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-27-100/"/>
    <id>http://www.wolfdan.cn/2019/09/17/算法日常-27-100/</id>
    <published>2019-09-17T13:39:26.000Z</published>
    <updated>2019-09-17T13:51:59.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://vjudge.net/problem/CodeForces-123D" target="_blank" rel="noopener">VJ</a><br><a href="https://codeforces.com/problemset/problem/123/D" target="_blank" rel="noopener">CF</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><ul><li>如果字符串y在字符串x中出现n次，那么F(x,y)=n<em>(n+1)/2   <em>*(可以看做是一个长为n的区间,求滑动区块的总个数)</em></em></li><li>现在给一个字符串，求所有的F(s,x)的和，x为字符串的所有不相同的子串．</li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul><li>直接SAM</li><li>right[v]就是SAM上状态表示的所有字符串出现的次数</li><li>那么每个状态的答案就是right<a href="right[v]+1">v</a>/2*(st[v].len-st[st[v].link].len)</li><li>前面right<a href="right[v]+1">v</a>/2是串的组合</li><li>后面是 st[v].len - st[st[v].link].len是后缀的前缀长度，是本质不同的串的贡献</li><li>也即后缀的前缀每个字母的贡献—-&gt;就是 <strong>每个后缀节点t跳父亲节点fa跳掉的那部分t的前缀</strong> 中的 <strong>以每一个字母开头的串t的后缀</strong> 都是和串t所在状态节点出现次数(前面的串的组合数)相同的！</li><li>累加答案完成计算</li></ul><h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a, x) memset(a, x, sizeof(a))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXALP 30</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> len, link, nxt[MAXALP];</span><br><span class="line">        <span class="keyword">int</span> leftmost; <span class="comment">//某个状态的right集合中r值最小的</span></span><br><span class="line">        <span class="keyword">int</span> rightmost; <span class="comment">//某个状态的right集合的r的最大值</span></span><br><span class="line">        <span class="keyword">int</span> Right; <span class="comment">//right集合大小</span></span><br><span class="line">    &#125;;</span><br><span class="line">    state st[N * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> S[N];</span><br><span class="line">    <span class="keyword">int</span> sz, last, rt;</span><br><span class="line">    <span class="keyword">char</span> s[N];</span><br><span class="line">    <span class="keyword">int</span> cnt[<span class="number">2</span> * N], rk[<span class="number">2</span> * N]; <span class="comment">//for radix sort</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>)</span><br><span class="line">            <span class="keyword">return</span> c - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'A'</span> + <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sz = <span class="number">0</span>;</span><br><span class="line">        ms(st, <span class="number">0</span>);</span><br><span class="line">        last = rt = ++sz;</span><br><span class="line">        st[<span class="number">1</span>].len = <span class="number">0</span>;</span><br><span class="line">        st[<span class="number">1</span>].link = <span class="number">-1</span>;</span><br><span class="line">        st[<span class="number">1</span>].rightmost = <span class="number">0</span>;</span><br><span class="line">        ms(st[<span class="number">1</span>].nxt, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = ++sz;</span><br><span class="line">        st[cur].len = st[last].len + <span class="number">1</span>;</span><br><span class="line">        st[cur].leftmost = st[cur].rightmost = head;</span><br><span class="line">        <span class="built_in">memset</span>(st[cur].nxt, <span class="number">-1</span>, <span class="keyword">sizeof</span>(st[cur].nxt));</span><br><span class="line">        <span class="keyword">int</span> p;</span><br><span class="line">        <span class="keyword">for</span> (p = last; p != <span class="number">-1</span> &amp;&amp; st[p].nxt[c] == <span class="number">-1</span>; p = st[p].link)</span><br><span class="line">            st[p].nxt[c] = cur;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">-1</span>) &#123;</span><br><span class="line">            st[cur].link = rt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> q = st[p].nxt[c];</span><br><span class="line">            <span class="keyword">if</span> (st[p].len + <span class="number">1</span> == st[q].len) &#123;</span><br><span class="line"></span><br><span class="line">                st[cur].link = q;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> clone = ++sz;</span><br><span class="line">                st[clone].len = st[p].len + <span class="number">1</span>;</span><br><span class="line">                st[clone].link = st[q].link;</span><br><span class="line">                <span class="built_in">memcpy</span>(st[clone].nxt, st[q].nxt, <span class="keyword">sizeof</span>(st[q].nxt));</span><br><span class="line">                st[clone].leftmost = st[q].leftmost;</span><br><span class="line">                st[clone].rightmost = st[q].rightmost;</span><br><span class="line">                <span class="keyword">for</span> (; p != <span class="number">-1</span> &amp;&amp; st[p].nxt[c] == q; p = st[p].link)</span><br><span class="line">                    st[p].nxt[c] = clone;</span><br><span class="line">                st[q].link = st[cur].link = clone;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, _len = <span class="built_in">strlen</span>(S); i &lt; _len; i++) &#123;</span><br><span class="line">            st[sz + <span class="number">1</span>].Right = <span class="number">1</span>;</span><br><span class="line">            extend(idx(S[i]), i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ms(cnt, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; i++) cnt[st[i].len]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; i++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//rk[1]是len最小的状态的标号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; i++) rk[cnt[st[i].len]--] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跑拓扑序，预处理一些东西</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sz; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = rk[i];</span><br><span class="line">            <span class="keyword">int</span> fa = st[v].link;</span><br><span class="line">            <span class="keyword">if</span> (fa == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            st[fa].rightmost = max(st[fa].rightmost, st[v].rightmost);</span><br><span class="line">            st[fa].Right += st[v].Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LL ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sz; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = rk[i];</span><br><span class="line">            <span class="keyword">if</span> (st[v].link == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 前面是串的组合</span></span><br><span class="line">            <span class="comment">// 后面是 st[v].len - st[st[v].link].len是后缀的前缀，是本质不同的串的贡献</span></span><br><span class="line">            <span class="comment">// 每个字母的贡献---&gt;就是每个后缀节点t跳父亲节点fa跳掉的那部分t的前缀中的每一个字母开头的后缀都是和串t出现次数相同的！</span></span><br><span class="line">            ans = ans + <span class="number">1L</span>L * st[v].Right * (st[v].Right + <span class="number">1</span>) / <span class="number">2</span> * (st[v].len - st[st[v].link].len);</span><br><span class="line">            <span class="comment">// cout&lt;&lt;"TEST: "&lt;&lt;st[v].len - st[st[v].link].len&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; A;</span><br><span class="line"><span class="keyword">char</span> B[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, A.S);</span><br><span class="line">    A.build();</span><br><span class="line">    A.topo();</span><br><span class="line">    A.pre();</span><br><span class="line">    A.solve();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://111qqz.com/2017/11/cf-123d/" target="_blank" rel="noopener">111qqz</a></p><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p><strong>路还长，别太狂，以后指不定谁辉煌</strong></p>]]></content>
    
    <summary type="html">
    
      CF123D_SAM_算法日常[27/100] 现在给一个字符串，求所有的F(s,x)的和，x为字符串的所有不相同的子串 路还长，别太狂，以后指不定谁辉煌
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="SAM" scheme="http://www.wolfdan.cn/tags/SAM/"/>
    
  </entry>
  
  <entry>
    <title>2019上海网络赛G-Substring_字符串Hash+自建Hashmap_算法日常[26/100]</title>
    <link href="http://www.wolfdan.cn/2019/09/16/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-26-100/"/>
    <id>http://www.wolfdan.cn/2019/09/16/算法日常-26-100/</id>
    <published>2019-09-16T13:33:16.000Z</published>
    <updated>2019-09-16T14:21:31.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://nanti.jisuanke.com/t/41415" target="_blank" rel="noopener">计蒜客走你(<del>揍你</del>)</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><ul><li>定义<code>匹配</code> : 两个串首尾字母相同,中间整个串相同或者是相同数量的各字符组成的不同排列</li><li>给你一个原串S，然后给你m个子串t，求这些子串在原串S中<code>匹配</code>的个数</li><li><del>无关题意的个人吐槽:众所周知，2019最后一场网络赛-上海网络赛是一场让你自闭的计数场</del></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>长度种类数是O($\sqrt n$)的</li><li>然后就是离线暴力处理—&gt;hash字符串</li><li>对hash字符串比较匹配</li><li>但是如果使用unordered_map会超时</li><li>使用数组会超内存</li><li>只有使用自建hash才能过</li><li>详见代码注释</li><li>代码是借鉴一个大佬同学的</li></ul><h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;=n;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pre(i,a,n) for(int i=n;i&gt;=a;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e2</span>+<span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N],p[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bas = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function">ull <span class="title">get</span><span class="params">(<span class="keyword">int</span> *a)</span> </span>&#123;</span><br><span class="line">    ull ret = <span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">27</span>) &#123;</span><br><span class="line">        ret = ret*bas+a[i]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ull sta;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; g[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line">ull fac[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> clk;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手写的Hash,因为unorder_map&lt;int,int&gt; f[26][26]被卡时间</span></span><br><span class="line"><span class="keyword">namespace</span> Hash&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> hashmod = <span class="number">218357</span>;</span><br><span class="line">  <span class="keyword">int</span> v[hashmod];</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> h[hashmod];</span><br><span class="line">  <span class="keyword">int</span> vis[hashmod];</span><br><span class="line">  <span class="function"><span class="keyword">int</span> &amp;<span class="title">get</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t2 = S % hashmod, i;</span><br><span class="line">    <span class="comment">// vis[i]是访问过的(clk恒为1)，所以也要走下一个</span></span><br><span class="line">    <span class="comment">// h[i] = S.则发生了hash crash(哈希碰撞)，就要走到下一个，也就是h[i] != S 走下一个</span></span><br><span class="line">    <span class="comment">// i = t2-1说明走了一个轮回了，就不用再走了，再走就是重复走t2位置了,所以i!=t2-1</span></span><br><span class="line">    <span class="keyword">for</span> (i = t2; vis[i]==clk &amp;&amp; h[i] != S &amp;&amp; i != t2 - <span class="number">1</span>; i = (i + <span class="number">1</span>) % hashmod);</span><br><span class="line">    <span class="comment">// 从未访问过的要初始化计数值为0</span></span><br><span class="line">    <span class="keyword">if</span> (vis[i]!=clk) h[i] = S, vis[i] = clk, v[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> v[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) g[i].clear();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,p+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(p+<span class="number">1</span>);</span><br><span class="line">        node ret;</span><br><span class="line">        ret.id = i;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">28</span>]&#123;&#125;;</span><br><span class="line">        rep(i,<span class="number">1</span>,len) ++cnt[p[i]-<span class="string">'a'</span>];</span><br><span class="line">        cnt[<span class="number">26</span>] = p[<span class="number">1</span>];</span><br><span class="line">        cnt[<span class="number">27</span>] = p[len];</span><br><span class="line">        ret.sta = get(cnt);</span><br><span class="line">        g[len].pb(ret);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,m) ans[i] = <span class="number">0</span>;</span><br><span class="line">    rep(len,<span class="number">1</span>,n) <span class="keyword">if</span> (g[len].size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">28</span>]&#123;&#125;;</span><br><span class="line">        <span class="comment">// 中间的字母是按照字母顺序来的，所以就是可以的，然后最后两个是按照直接首尾字母来的</span></span><br><span class="line">        rep(i,<span class="number">1</span>,len) ++cnt[s[i]-<span class="string">'a'</span>];</span><br><span class="line">        cnt[<span class="number">26</span>] = s[<span class="number">1</span>];</span><br><span class="line">        cnt[<span class="number">27</span>] = s[len];</span><br><span class="line">        ull sta = get(cnt);</span><br><span class="line">        ++clk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L=<span class="number">1</span>,R=len; R&lt;=n; ++L,++R) &#123;</span><br><span class="line">            ++Hash::get(sta);</span><br><span class="line">            <span class="comment">// 左边字符基底为一个fac,而右边为fac^0=1</span></span><br><span class="line">            sta = sta+(s[L+<span class="number">1</span>]-s[L])*fac[<span class="number">1</span>];</span><br><span class="line">            sta = sta+(ll)(s[R+<span class="number">1</span>]-s[R]);</span><br><span class="line">            <span class="comment">// 下面是右移一位整体的字母表的hash值变化</span></span><br><span class="line">            sta = sta-fac[<span class="number">27</span>-(s[L]-<span class="string">'a'</span>)];</span><br><span class="line">            sta = sta+fac[<span class="number">27</span>-(s[R+<span class="number">1</span>]-<span class="string">'a'</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个t长度下,把各次提问的ans更新</span></span><br><span class="line">        <span class="comment">// hash是这个头尾相同，中间的串是不同排列的  询问串(key) ————&gt; 原串中的个数(value)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;t:g[len]) ans[t.id] = Hash::get(t.sta);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,<span class="number">30</span>) fac[i]=fac[i<span class="number">-1</span>]*bas;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--) solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p><strong>所有的胜利，与征服自己的胜利比起来，都是微不足道。所有的失败，与失去自己的失败比起来，更是微不足道</strong></p>]]></content>
    
    <summary type="html">
    
      思维题 手写HashMap StringHash 串按长度分类讨论 2019上海网络赛G-Substring_字符串Hash+自建Hashmap 所有的胜利，与征服自己的胜利比起来，都是微不足道。所有的失败，与失去自己的失败比起来，更是微不足道
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="思维题" scheme="http://www.wolfdan.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/"/>
    
      <category term="手写HashMap" scheme="http://www.wolfdan.cn/tags/%E6%89%8B%E5%86%99HashMap/"/>
    
      <category term="StringHash" scheme="http://www.wolfdan.cn/tags/StringHash/"/>
    
      <category term="串按长度分类讨论" scheme="http://www.wolfdan.cn/tags/%E4%B8%B2%E6%8C%89%E9%95%BF%E5%BA%A6%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>ARST打卡第21周(21/521)</title>
    <link href="http://www.wolfdan.cn/2019/09/15/ARST%E6%89%93%E5%8D%A1%E7%AC%AC21%E5%91%A8-21-521/"/>
    <id>http://www.wolfdan.cn/2019/09/15/ARST打卡第21周-21-521/</id>
    <published>2019-09-15T13:51:25.000Z</published>
    <updated>2019-09-15T14:10:30.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p><a href="https://www.wolfdan.cn/2019/09/10/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-24-100/">2019南昌网络赛Hello 2019(cf 750E)线段树_算法日常[24/100]</a><br><a href="https://www.wolfdan.cn/2019/09/15/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-25-100/">2019上海网络赛B_Light bulbs_算法日常[25/100]</a></p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p><a href="https://medium.com/s/please-advise/youre-not-meant-to-do-what-you-love-you-re-meant-to-do-what-you-re-good-at-4e8e6b8e929d" target="_blank" rel="noopener">You’re Not Meant to Do What You Love</a><br>是啊，如果你揣测自己喜欢做某件事情，然后没做好，就会产生极大的挫败感，所以不妨先做好你擅长地事情，然后慢慢进化你喜欢的事情</p><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p><a href="https://mzz.pub/2017/12/22/justplay/mobileubuntu/" target="_blank" rel="noopener">把Ubuntu16.04装进移动硬盘的惨痛实战</a></p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p><a href="https://www.wolfdan.cn/2019/09/12/%E5%B0%86Deepin-linux%E8%A3%85%E8%BF%9B%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E5%88%B0%E4%BB%BB%E4%BD%95%E5%85%B6%E4%BB%96%E7%94%B5%E8%84%91%E4%B8%8A%E4%BD%BF%E7%94%A8/">将Deepin-linux装进移动硬盘到任何其他电脑上使用</a><br><a href="https://www.wolfdan.cn/2019/09/13/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81wp%E7%AB%99%E5%81%9C%E7%AB%99-%E4%B8%93%E6%B3%A8hexo%E7%AB%99/">为什么要wp站停站,专注hexo站</a></p>]]></content>
    
    <summary type="html">
    
      ARST打卡 2019南昌网络赛Hello 2019(cf 750E)线段树 2019上海网络赛B_Light bulbs You’re Not Meant to Do What You Love 把Ubuntu16.04装进移动硬盘的惨痛实战 将Deepin-linux装进移动硬盘到任何其他电脑上使用 为什么要wp站停站,专注hexo站
    
    </summary>
    
      <category term="ARST" scheme="http://www.wolfdan.cn/categories/ARST/"/>
    
    
      <category term="ARST" scheme="http://www.wolfdan.cn/tags/ARST/"/>
    
  </entry>
  
  <entry>
    <title>2019上海网络赛B_Light bulbs_算法日常[25/100]</title>
    <link href="http://www.wolfdan.cn/2019/09/15/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-25-100/"/>
    <id>http://www.wolfdan.cn/2019/09/15/算法日常-25-100/</id>
    <published>2019-09-15T13:09:09.000Z</published>
    <updated>2019-09-15T13:38:08.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://nanti.jisuanke.com/t/41399" target="_blank" rel="noopener">计蒜客传送门</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一排N个全灭的灯泡，然后进行M次区间翻转，T组测试</p><ul><li>1≤T≤1000</li><li>1≤N≤$10^6$</li><li>1≤M≤1000</li><li>0≤$L_i$ ≤$R_i$ ≤N−1</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>因为是多次区间修改，然后求区间的特性，我们可以很自然地想到使用差分+前缀和或者线段树</li><li>不过这里发现8192K，N为$10^6$,$10^6$的int是4*$10^6$Byte=4*$10^3$K.然后线段树要开两倍N(节点2*N),而且一般是一个struct结构(一般几个int)，而非一个int，所以线段树否决</li><li>然后求前缀和O(T*N)在$10^9$量级，时间限制为1s，所以我们要观察M在1000的量级，所以可以通过离散化来解决</li><li>注意，<strong>这题超级卡时间，所以使用快读(独立缓冲的cin T了)以及各位置用完及时归0而非使用memset</strong></li></ul><h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[M],T,n,m,l,r,ans,sum;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();<span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar())<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;<span class="built_in">isdigit</span>(ch);ch=getchar())x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;<span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line">    T = read();</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        n = read(),m = read();</span><br><span class="line">        <span class="keyword">if</span>(!b.empty()) b.clear();</span><br><span class="line">        ans = <span class="number">0</span>,sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            l = read(),r = read();</span><br><span class="line"></span><br><span class="line">            l++,r++;</span><br><span class="line"></span><br><span class="line">            a[l]--;a[r+<span class="number">1</span>]++;</span><br><span class="line">            b.push_back(l),b.push_back(r+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先排序，因为unique只从左到右顺序查重，然后unique得到最后一个被删除的位置，用erase搽除尾部</span></span><br><span class="line">        sort(b.begin(), b.end());</span><br><span class="line">        b.erase(unique(b.begin(), b.end()),b.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sz = b.size();</span><br><span class="line">        sum+=a[b[<span class="number">0</span>]];</span><br><span class="line">        a[b[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;sz;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&amp;<span class="number">1</span>) ans+=b[i]-b[i<span class="number">-1</span>];</span><br><span class="line">            sum+=a[b[i]];</span><br><span class="line">            a[b[i]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&amp;<span class="number">1</span>) ans+=n+<span class="number">1</span>-b[sz<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>,kase++,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p>人生总有很多东西无法挽留，比如走远的时光，比如枯萎的情感;总有很多东西难以割舍，比如追逐的梦想，比如心中的深爱。所以你一定要珍惜眼前。</p>]]></content>
    
    <summary type="html">
    
      思维题 差分 前缀和 离散化 2019上海网络赛B_Light bulbs 这题超级卡时间，所以使用快读(独立缓冲的cin T了)以及各位置用完及时归0而非使用memset 人生总有很多东西无法挽留，比如走远的时光，比如枯萎的情感;总有很多东西难以割舍，比如追逐的梦想，比如心中的深爱。所以你一定要珍惜眼前。
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="思维题" scheme="http://www.wolfdan.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/"/>
    
      <category term="差分" scheme="http://www.wolfdan.cn/tags/%E5%B7%AE%E5%88%86/"/>
    
      <category term="前缀和" scheme="http://www.wolfdan.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="离散化" scheme="http://www.wolfdan.cn/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>为什么要wp站停站,专注hexo站</title>
    <link href="http://www.wolfdan.cn/2019/09/13/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81wp%E7%AB%99%E5%81%9C%E7%AB%99-%E4%B8%93%E6%B3%A8hexo%E7%AB%99/"/>
    <id>http://www.wolfdan.cn/2019/09/13/为什么要wp站停站-专注hexo站/</id>
    <published>2019-09-13T07:41:59.000Z</published>
    <updated>2019-09-13T08:45:35.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><ul><li>维护两个网站有点耗时间</li><li>访问速度慢</li><li>wp站由于网站的vps在国外，然后在百度收录方面很差劲</li><li>中文内容，加上自己知识有限，所以在谷歌也没什么访问量</li><li>wp站有点重</li><li>Hexo站可以满足我的写作所有的愿望</li></ul><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><ul><li>少就是多，把时间节省下来，专注做好一件事情</li><li>好好刷题，好好学习，好好写作</li><li>争取让我的小站能够对大家产生一点帮助</li><li>当然也希望自己通过写作成为更好的自己</li></ul><h1 id="搬家的一些痛"><a href="#搬家的一些痛" class="headerlink" title="搬家的一些痛"></a>搬家的一些痛</h1><ul><li>之前有些老文章是富文本写的…还好有wp-markdown.md，把那些转成html了</li><li>图片文件链接要重新搞一下，有点麻烦—-&gt;所以放弃了一些图片</li><li>wolfdan.cn域名的安全证书过期了，要多点好几下才能看到内容…</li></ul><h1 id="一些hexo不太爽的点解决"><a href="#一些hexo不太爽的点解决" class="headerlink" title="一些hexo不太爽的点解决"></a>一些hexo不太爽的点解决</h1><h2 id="posts太多，找文件有点难"><a href="#posts太多，找文件有点难" class="headerlink" title="_posts太多，找文件有点难"></a>_posts太多，找文件有点难</h2><ul><li>先发<code>new draft &quot;文章名&quot;</code>，之后<code>hexo publish &quot;文章名&quot;</code></li><li>分类的话，直接在网站看</li></ul>]]></content>
    
    <summary type="html">
    
      我为什么要关掉wp站，专注hexo站 _posts太多，找文件有点难如何解决
    
    </summary>
    
      <category term="Hexo" scheme="http://www.wolfdan.cn/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://www.wolfdan.cn/tags/Hexo/"/>
    
      <category term="wordpress" scheme="http://www.wolfdan.cn/tags/wordpress/"/>
    
  </entry>
  
  <entry>
    <title>将Deepin-linux装进移动硬盘到任何其他电脑上使用</title>
    <link href="http://www.wolfdan.cn/2019/09/12/%E5%B0%86Deepin-linux%E8%A3%85%E8%BF%9B%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E5%88%B0%E4%BB%BB%E4%BD%95%E5%85%B6%E4%BB%96%E7%94%B5%E8%84%91%E4%B8%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.wolfdan.cn/2019/09/12/将Deepin-linux装进移动硬盘到任何其他电脑上使用/</id>
    <published>2019-09-12T08:49:24.000Z</published>
    <updated>2019-09-12T14:26:47.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>最近买了一块480G的移动固态硬盘，天生的折腾性格，我哪闲得住…然后早就听闻有linux装到移动硬盘的操作，然后又听说deepin很牛*，所以我想要把deepin装到移动固态，然后实现系统插在任何电脑都是一样的配方，一样的味道，一样的我的数据和工具(在机房使用就是真香…虽然还没去机房试过)，不过在自己的电脑上跑得很high，然后插在朋友的电脑上成功了,看下图</p><h2 id="我的high图"><a href="#我的high图" class="headerlink" title="我的high图"></a>我的high图</h2><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/SSD/deepin/high1.png" alt="high1"><br><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/SSD/deepin/high2.png" alt="high2"></p><h2 id="在朋友电脑上点亮"><a href="#在朋友电脑上点亮" class="headerlink" title="在朋友电脑上点亮"></a>在朋友电脑上点亮</h2><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/SSD/deepin/amazing.jpg" alt="amazing"></p><h1 id="准备材料"><a href="#准备材料" class="headerlink" title="准备材料"></a>准备材料</h1><ul><li>电脑一台(环境是windows)</li><li>移动硬盘或者大容量的高速U盘一个</li><li>普通8G以上大小的U盘一个(用于制作启动盘)</li></ul><h1 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h1><h2 id="下载镜像并制作启动盘"><a href="#下载镜像并制作启动盘" class="headerlink" title="下载镜像并制作启动盘"></a>下载镜像并制作启动盘</h2><ol><li><p><a href="https://www.deepin.org/download/" target="_blank" rel="noopener">官网链接下载镜像</a>,推荐选择一个地区位置离你比较近的地方的iso仓库下载</p></li><li><p>下载完成将压缩包中的<code>deepin-boot-maker.exe</code>和<code>deepin-boot-maker.zip</code>移动到一个文件夹下，然后运行.exe文件按照提示制作启动盘</p></li></ol><h2 id="压缩SSD磁盘空间"><a href="#压缩SSD磁盘空间" class="headerlink" title="压缩SSD磁盘空间"></a>压缩SSD磁盘空间</h2><p>右键windows图标，选择 磁盘管理<br><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/SSD/deepin/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86.jpg" alt="磁盘管理"></p><p>选择SSD，压缩卷(其实是取出一块的意思)，然后删除卷(其实是把它设置成可分配的意思)达到一定的大小(一定是没有数据的空间，你不要把你有数据的磁盘压缩删除了)，<strong>让你的的未分配的空间大小达到你想要的系统空间大小，比如我的设置的是100G，你们看到的20G，80G，300M的那三个就是对应我的deepin系统的<code>/分区</code>,<code>/home分区</code>,<code>efi分区</code></strong></p><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/SSD/deepin/%E5%8E%8B%E7%BC%A9%E5%8D%B7.jpg" alt="压缩卷"></p><h2 id="关闭快速启动"><a href="#关闭快速启动" class="headerlink" title="关闭快速启动"></a>关闭快速启动</h2><p>右键电源图标，点击电源选项<br><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/SSD/deepin/%E7%94%B5%E6%BA%90%E9%80%89%E9%A1%B9.jpg" alt="电源选项"></p><p>选择电源功能<br><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/SSD/deepin/%E9%80%89%E6%8B%A9%E7%94%B5%E6%BA%90%E5%8A%9F%E8%83%BD.jpg" alt="选择电源功能"></p><p>禁用快速启动<br><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/SSD/deepin/%E7%A6%81%E7%94%A8%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8.jpg" alt="禁用快速启动"></p><h2 id="设置启动项并关闭安全启动"><a href="#设置启动项并关闭安全启动" class="headerlink" title="设置启动项并关闭安全启动"></a>设置启动项并关闭安全启动</h2><p>进入windows的设置-&gt; 更新和安全 -&gt; 恢复 -&gt; 高级启动 -&gt; 立即重启<br><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/SSD/deepin/%E6%81%A2%E5%A4%8D%E8%AE%BE%E7%BD%AE.jpg" alt="恢复设置"></p><p>重启后会自动进入一个蓝屏的界面，然后选择 <code>疑难解答</code> -&gt; <code>UEFI固件设置</code></p><p>进入bios界面后找到安全启动，然后disable<br><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/SSD/deepin/disable.jpg" alt="disable安全启动"></p><p>然后将Boot设置成  <strong>U盘为第一启动项</strong></p><p>保存，重启</p><h2 id="分区-最重要"><a href="#分区-最重要" class="headerlink" title="分区(最重要!)"></a>分区(最重要!)</h2><p>一步步进行到分区,<strong>然后选择高级模式，找到自己的移动硬盘，点击右侧的编辑</strong><br>我的分区大小是</p><ul><li>efi 300M(<strong>一定要有efi!!!uefi安装模式必要的分区，否则可能无法在别的电脑启动</strong>)</li><li>/   20G</li><li>/home  80G (剩下的全部都行,因为之后用的东西都在这里)</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装完就是体验咯，取下U盘，慢慢使用</p><h2 id="双显卡导致开机卡logo的解决方案"><a href="#双显卡导致开机卡logo的解决方案" class="headerlink" title="双显卡导致开机卡logo的解决方案"></a>双显卡导致开机卡logo的解决方案</h2><ul><li>在grub选择界面按e进入编辑</li><li>找到这一行<br><code>linux /vmlinuz-4.15.0-29deepin-generic root=UUID=************9-466c-bc12-6bb801e45901 ro splash quiet</code></li><li>在quiet后面加上<code>acpi_osi=! acpi=&quot;windows 2009&quot;</code>，然后按F10保存即可.这时会重新开始登录deepin系统，耐心等待进入桌面即可</li><li>开机后<code>Ctrl+Alt+T</code>进入打开终端，输入以下代码来打开grub配置文件：sudo vi /boot/grub/grub.cfg</li><li><code>/quiet</code>查找quiet位置，回车找到第一个，然后<code>i</code>进行编辑，同样加入<code>acpi_osi=! acpi=&quot;windows 2009&quot;</code></li><li><code>Esc</code>退出编辑，<code>:wq!</code>强制保存退出</li></ul><h2 id="高光时刻-跑在别人电脑上"><a href="#高光时刻-跑在别人电脑上" class="headerlink" title="高光时刻-跑在别人电脑上"></a>高光时刻-跑在别人电脑上</h2><p>在朋友电脑上进入界面按键进入bios选择，选择自己的ssd启动，然后完美进入自己的deepin，看一下，数据都在，完美</p><h1 id="自己对于deepin的一些体验"><a href="#自己对于deepin的一些体验" class="headerlink" title="自己对于deepin的一些体验"></a>自己对于deepin的一些体验</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>界面真好看</li><li>命令行界面有好多好多种配色，真好，而且默认的就是我最爱的绿色</li><li>比起他的爸爸Ubuntu，他在系统上对微信，qq进行了优化，不用手动去调节wine-qq，wine-微信的一些兼容性问题(虽然还是有时候会出现卡死现象，无可厚非)</li><li>截图功能极其强大(弥补了wine-qq，wine-微信不能截图的缺憾)</li><li>设置简洁</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p><strong>主要是因为deepin15.11是2019.7.20发布，还存在一些bug</strong></p><ul><li>网络自动代理设置不生效(Ubuntu中可以)(<strong>新版本对我的致命伤害,所以这个bug不解决，我就用windows去</strong>)</li><li>双屏中的副屏不能右键呼出菜单</li></ul><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p><strong>万事万物由心生，如果累了，就把不重要的事情都推掉，然后做真正最重要的事情！</strong></p><p><strong>还有，少折腾！</strong>比如你这三天就没有好好刷题，搞这个破deepin…然后浪费大把的赛前训练的时间！你已经后悔了…呜呜呜，对不起，我明天一定好好刷题</p>]]></content>
    
    <summary type="html">
    
      将Deepin-linux装进移动硬盘到任何其他电脑上使用 我想要把deepin装到移动固态，然后实现系统插在任何电脑都是一样的配方，一样的味道，一样的我的数据和工具  双显卡导致开机卡logo的解决方案
    
    </summary>
    
      <category term="瞎折腾" scheme="http://www.wolfdan.cn/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="瞎折腾" scheme="http://www.wolfdan.cn/tags/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
      <category term="装系统" scheme="http://www.wolfdan.cn/tags/%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Deepin" scheme="http://www.wolfdan.cn/tags/Deepin/"/>
    
  </entry>
  
  <entry>
    <title>2019南昌网络赛Hello 2019(cf 750E)线段树_算法日常[24/100]</title>
    <link href="http://www.wolfdan.cn/2019/09/10/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-24-100/"/>
    <id>http://www.wolfdan.cn/2019/09/10/算法日常-24-100/</id>
    <published>2019-09-10T11:51:49.000Z</published>
    <updated>2019-09-11T14:14:50.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目小趣事"><a href="#题目小趣事" class="headerlink" title="题目小趣事"></a>题目小趣事</h1><p>我在比赛一开场就开始看这题，然后没想出怎么写，12:07我校一个大佬lxc说他拿下了这题的一血，这是一个原题，cf 750E(我只能说:大佬都是移动题库!)然后做完另一个签到题之后，成为第一名，带榜了</p><h2 id="赛后发现1"><a href="#赛后发现1" class="headerlink" title="赛后发现1"></a>赛后发现1</h2><p>Hello 2019 的提交情况如下:<br><strong>通过率：5.66%   正确提交 / 总提交：217 / 3837</strong></p><p>达成学校带崩他校节奏的成就</p><h2 id="赛后发现2"><a href="#赛后发现2" class="headerlink" title="赛后发现2"></a>赛后发现2</h2><p>这题<strong>tourist(codeforces霸榜第一，ACM world final 4小时ak第一人，被评为全球最厉害的十个程序员之一(和c语言之父这些人在一个榜单！))</strong>当年比赛的时候也没有做出来！然后大家说自己竟然尝试了一下当年T神都没有做出来的题目</p><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8/cf%20750E_hello2019_%E5%8D%97%E6%98%8C2019%E7%BD%91%E7%BB%9C%E8%B5%9B/Tshen.png" alt="Tshen"></p><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://nanti.jisuanke.com/t/41350" target="_blank" rel="noopener">计蒜客传送门</a><br><a href="https://codeforces.com/problemset/problem/750/E" target="_blank" rel="noopener">codeforces 750E</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一个串，然后多次询问左右区间，看删除多少个字符能使得这个区间内有9102，而没有8102的subsequence(codeforces中是有2017而没有2016)</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>肉眼做法,表层理解,很容易看出只要删除8</li><li>因为8放在第一个不好处理，所以改成翻转string，并且翻转l,r,从而变成判断有2019没有2018，</li><li>因为每次询问一个区间，所以需要把dp状态扔到某个数据结构上,所以我们考虑线段树</li><li>线段树更新的时候是拿两段的信息合并，所以不能像做1~n的dp那样记录状态</li></ul><p>考虑2017之间的间隔:</p><p>|　2　|　0　|　1　|　9　|</p><p>0　 　1　 　2　 　3　 　4</p><ul><li><p>线段树的每个节点存一个矩阵A.$mat_{ij}$表示使原串的子序列包含2019中第i个间隔到第j个间隔组成的子串，但不严格包含它的子序列最少需要删除的数字、</p></li><li><p>转移是显然的，和区间dp一样。枚举区间，枚举中间点，然后转移就好了。</p></li><li><p>考虑初值问题，显然的是非2、0、1、9、8的数字对答案不影响，所以令$a_{ii}$=0,$a_{ij}$=N(取不到就行)   (i!=j)</p></li><li><p>考虑当前数字是2的时候，如果我希望只包含子串[0,0]（这里表示两个间隔间的子串），那么就必须删掉这个2，故$a_{00}$=1(<strong>可以理解为不想要成为2019是不思进取的行为，所以付出代价—&gt;这样可以在后面处理的时候淘汰掉这些大的状态值</strong>),如果希望包含子串[0,1]，那么什么都不用做，所以$a_{01}$=0。对于0、1、7同理。</p></li><li><p>考虑当前数字是8的时候，那么遇到子串[i,3]希望转移回自己(<strong>不想接受8来到达4状态</strong>)，那么需要付出1的代价，因为否则会包含子序列”2018”，同样如果遇到子串[i,4]希望转移回自己(<strong>不想接受8来到达4状态</strong>)，那么也需要付出1的代价(区间如果询问到这里就是真正要删除的数字了，因为4达到状态终点了)。</p></li></ul><h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">200005</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mat[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">    Node <span class="keyword">operator</span> + (Node x) &#123;</span><br><span class="line">        Node ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;++j) &#123;</span><br><span class="line">                ans.mat[i][j]=N;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">5</span>;++k) &#123;</span><br><span class="line">                    ans.mat[i][j]=min(ans.mat[i][j],mat[i][k]+x.mat[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;++j) &#123;</span><br><span class="line">                a[x].mat[i][j]=(i==j)?<span class="number">0</span>:N;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[l]==<span class="string">'2'</span>) a[x].mat[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>,a[x].mat[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[l]==<span class="string">'0'</span>) a[x].mat[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">0</span>,a[x].mat[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[l]==<span class="string">'1'</span>) a[x].mat[<span class="number">2</span>][<span class="number">3</span>]=<span class="number">0</span>,a[x].mat[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[l]==<span class="string">'9'</span>) a[x].mat[<span class="number">3</span>][<span class="number">4</span>]=<span class="number">0</span>,a[x].mat[<span class="number">3</span>][<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[l]==<span class="string">'8'</span>) a[x].mat[<span class="number">3</span>][<span class="number">3</span>]=<span class="number">1</span>,a[x].mat[<span class="number">4</span>][<span class="number">4</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l,m,x&lt;&lt;<span class="number">1</span>);build(m+<span class="number">1</span>,r,x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    a[x]=a[x&lt;&lt;<span class="number">1</span>]+a[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> a[x];</span><br><span class="line">    <span class="keyword">int</span> m=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;L) <span class="keyword">return</span> query(m+<span class="number">1</span>,r,L,R,x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(m&gt;=R) <span class="keyword">return</span> query(l,m,L,R,x&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> query(l,m,L,R,x&lt;&lt;<span class="number">1</span>)+query(m+<span class="number">1</span>,r,L,R,x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,q;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;n,&amp;q,s+<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            swap(s[i],s[n-i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">            <span class="keyword">int</span> l,r;<span class="keyword">int</span> tl,tr;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;tl,&amp;tr);</span><br><span class="line">            r = n-tl+<span class="number">1</span>,l = n - tr + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> ans=query(<span class="number">1</span>,n,l,r,<span class="number">1</span>).mat[<span class="number">0</span>][<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">if</span>(ans==N) ans=<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/yyf0309/p/8475433.html" target="_blank" rel="noopener">阿波罗2003</a></p><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p><strong>这个世界，想不想要永远不是最重要的，重要的，是要不要得起。</strong></p><p><strong>就像每个人都想成功，但是不是每个人都承担得起成功的代价</strong></p>]]></content>
    
    <summary type="html">
    
      思维题 线段树 tourist当年比赛的时候也没有做出来 这个世界，想不想要永远不是最重要的，重要的，是要不要得起。就像每个人都想成功，但是不是每个人都承担得起成功的代价
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="线段树" scheme="http://www.wolfdan.cn/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="思维题" scheme="http://www.wolfdan.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/"/>
    
      <category term="subsequence" scheme="http://www.wolfdan.cn/tags/subsequence/"/>
    
  </entry>
  
  <entry>
    <title>2019南昌网络赛E.Magic Master_算法日常23[23/100]</title>
    <link href="http://www.wolfdan.cn/2019/09/08/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-23-100/"/>
    <id>http://www.wolfdan.cn/2019/09/08/算法日常-23-100/</id>
    <published>2019-09-08T13:38:46.000Z</published>
    <updated>2019-09-10T12:10:29.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://nanti.jisuanke.com/t/41352" target="_blank" rel="noopener">计蒜客传送门</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>魔法洗牌，洗完牌后进行1,2,2,2…2..操作，使得最终在John手上的牌是递减的</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>看这个题目的数据范围我们可以猜测出这题是一个找规律的题目，那我们要怎么构造这个串呢？</li><li>观察题目给的M=1，发现1,2,3都间隔了一个，然后我们推测是间隔M个放置，然后再继续推测之后得到下面的规律</li><li>走M次空格，第M+1次落下，第一个先填1，<strong>循环走</strong></li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>比如N = 5, M = 4;<br>一开始是 1 _ _ _ _<br>然后走4次空格，第5次落下 变成 1 2 _ _ _<br>之后同理得到 1 2 _ 3 _ ==&gt; 1 2 _ 3 4 ==&gt; 1 2 5 3 4</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>通过模拟链表实现走M次空格(详见代码)</p><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><p>时间复杂度 O(T*N*M) ,接近 O(4*$10^9$) ,6s时间限制，按理1秒 2*$10^8$ 也只够跑 1.2*$10^9$ ,所以要么计蒜客评测机太快，要么数据不够强大,233</p><h2 id="写作小收获"><a href="#写作小收获" class="headerlink" title="写作小收获"></a>写作小收获</h2><p>用转义符<code>\</code>来保持某些符号不成为markdown的标记符，比如我要用多个*,就要防止变成markdown的斜体</p><h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> pos[N], nxt[N], pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m, q, u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) nxt[i] = i+<span class="number">1</span>, pre[i] = i<span class="number">-1</span>;</span><br><span class="line">        nxt[n] = <span class="number">2</span>; pre[<span class="number">2</span>] = n;</span><br><span class="line">        pos[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m+<span class="number">1</span>;j++) &#123;</span><br><span class="line">                cur = nxt[cur];</span><br><span class="line">            &#125;</span><br><span class="line">            pos[cur] = i;</span><br><span class="line">            u = pre[cur]; v = nxt[cur];</span><br><span class="line">            nxt[u] = v; pre[v] = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">        <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;u);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pos[u]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p><strong>别人撞了南墙才回头，而我撞了也不回头，我要跨过去</strong></p>]]></content>
    
    <summary type="html">
    
      2019南昌网络赛E.Magic Master_算法日常23 魔法洗牌，洗完牌后进行1,2,2,2...2..操作，使得最终在John手上的牌是递减的 走M次空格，第M+1次落下，第一个先填1，循环走 用转义符`\`来保持某些符号不成为markdown的标记符，比如我要用多个\*,就要防止变成markdown的斜体 别人撞了南墙才回头，而我撞了也不回头，我要跨过去
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="思维题" scheme="http://www.wolfdan.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ARST打卡第20周[20/521]</title>
    <link href="http://www.wolfdan.cn/2019/09/08/ARST%E6%89%93%E5%8D%A1%E7%AC%AC20%E5%91%A8-20-521/"/>
    <id>http://www.wolfdan.cn/2019/09/08/ARST打卡第20周-20-521/</id>
    <published>2019-09-08T12:52:21.000Z</published>
    <updated>2019-09-17T06:24:30.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p><a href="https://www.wolfdan.cn/2019/09/05/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-20-100/">SPOJ-LCS,SPOJ-LCS2-后缀自动机SAM专题训练_算法日常[20/100]</a></p><p><a href="https://www.wolfdan.cn/2019/09/06/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-21-100/">spoj_nsubstr_sam后缀自动机_算法日常[21/100]</a></p><p><a href="https://www.wolfdan.cn/2019/09/07/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-22-100/">2019 徐州网络赛 M Longest subsequence_算法日常[22/100]</a></p><p><a href="https://www.wolfdan.cn/2019/09/08/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B823-23-100/">2019南昌网络赛E.Magic Master_算法日常23[23/100]</a></p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p><a href="https://elemental.medium.com/how-to-take-the-perfect-nap-397ee26a64c7" target="_blank" rel="noopener">How to Take the Perfect Nap</a></p><p>其实自己之前看过这篇报告的中文版，现在看一遍英文版，又温习了一下，也拯救一下从暑假归来后每天要睡9个小时的自己，让自己能恢复战斗状态，每天6小时+30mins咖啡盹</p><ul><li>晚上6小时，正好是4个完整的睡眠周期，完成4次慢波睡眠期处理记忆和信息和4次快速动眼期促进创造力，然后白天再来一个30mins的咖啡盹睡眠恢复精力和警觉(不要进入慢波睡眠，否则在慢波睡眠的时候醒来会很困)就够了，固定下来就好，如果长期不适应4个睡眠周期就加到5个</li><li>咖啡盹就是快速喝完咖啡马上睡30mins</li><li>固定睡眠时间，让生物钟适应</li></ul><h2 id="再附上一篇中文的把"><a href="#再附上一篇中文的把" class="headerlink" title="再附上一篇中文的把"></a>再附上一篇中文的把</h2><p><a href="https://36kr.com/p/5130961" target="_blank" rel="noopener">怎么睡觉，工作效率最高？</a></p><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p><a href="https://blog.csdn.net/lewky_liu/article/details/82432045" target="_blank" rel="noopener">Coding Pages申请SSL/TLS证书错误</a></p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p><a href="https://www.wolfdan.cn/2019/09/06/Hexo-Next-Gemini%E4%B8%BB%E9%A2%98%E9%80%8F%E6%98%8E%E5%8C%96%E4%BB%A5%E5%8F%8A%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E7%9A%84%E6%9B%B4%E6%94%B9/">Hexo-Next-Gemini主题透明化以及背景图片的更改和获取</a></p>]]></content>
    
    <summary type="html">
    
      ARST打卡 SPOJ-LCS,SPOJ-LCS2-后缀自动机SAM专题训练 spoj_nsubstr_sam后缀自动机 2019 徐州网络赛 M Longest subsequence  2019南昌网络赛E.Magic Master How to Take the Perfect Nap 怎么睡觉，工作效率最高？ Coding Pages申请SSL/TLS证书错误 Hexo-Next-Gemini主题透明化以及背景图片的更改和获取
    
    </summary>
    
      <category term="ARST" scheme="http://www.wolfdan.cn/categories/ARST/"/>
    
    
      <category term="ARST" scheme="http://www.wolfdan.cn/tags/ARST/"/>
    
  </entry>
  
  <entry>
    <title>2019 徐州网络赛 M Longest subsequence_算法日常[22/100]</title>
    <link href="http://www.wolfdan.cn/2019/09/07/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-22-100/"/>
    <id>http://www.wolfdan.cn/2019/09/07/算法日常-22-100/</id>
    <published>2019-09-07T13:21:24.000Z</published>
    <updated>2019-09-07T14:05:40.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://nanti.jisuanke.com/t/41395" target="_blank" rel="noopener">计蒜客传送</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>求s中字典序大于t的<strong>最长子序列</strong>长度</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>sebsequence是子序列，可以不连续，substring才是子串，必须连续</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对于答案来说，一定是</p><ol><li>前i-1个字符和t的前i个一样，然后第i个字符比t的大</li><li>前缀为t，然后长度比t长</li></ol><p>对于第一种情况，枚举这个 i ，然后找最小的 p 可以使得从(s[1]~s[p]) 中产生($t_1$,$t_2$ 到 $t_{i-1}$) ,然后在(s[p+1,n])中找最左边的比(t[i]) 大的字符，假如 找到了(s[pos])，那么后面的(s[pos+1,n]) 都可以加到答案后面（因为(s[pos] &gt; t[i]) 已经保证答案大于t了)</p><p>对于第二种，根据求第一种的方法，不难求出</p><p>如何找最小的p？预处理一个(sf[i][c]) 数组，表示(s[i]) 后面第一个字符(c)在哪里即可</p><p>如何找pos? 也是用预处理的数组循环最多26次即可</p><p>复杂度(O(n*26))</p><h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> sf[N][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N],t[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,s+<span class="number">1</span>,t+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) sf[n][i] = n+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理一个(sf[i][c]) 数组，表示(s[i]) 后面第一个字符(c)在哪里</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(sf[i],sf[i+<span class="number">1</span>],<span class="keyword">sizeof</span> sf[i]);</span><br><span class="line">        sf[i][s[i+<span class="number">1</span>]-<span class="string">'a'</span>] = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>,res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=t[i]-<span class="string">'a'</span>+<span class="number">1</span>;j&lt;<span class="number">26</span>;j++)&#123;</span><br><span class="line">            pos = min(pos,sf[p][j]);<span class="comment">//找到最近的那个s[pos] &gt; t[i];</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos != n+<span class="number">1</span>)</span><br><span class="line">            res = max(res,i+n-pos);<span class="comment">//(n-pos)为后面还可以加的长度</span></span><br><span class="line">        <span class="comment">// p在s中找到与t相同的"前缀"(不连续子串可以跳跃)</span></span><br><span class="line">        p = sf[p][t[i]-<span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">if</span>(p == n+<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果完全相同，那就要严格更大，所以p&lt;n</span></span><br><span class="line">    <span class="keyword">if</span>(p &lt; n) res = max(res,n-p+m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="借鉴"><a href="#借鉴" class="headerlink" title="借鉴"></a>借鉴</h1><p><a href="https://www.codetd.com/article/7223660" target="_blank" rel="noopener">https://www.codetd.com/article/7223660</a></p><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p>有时候不试一下，永远都不知道自己有多垃圾！不过没有关系，至少我永远向上生长，这就是生命！保持乐观，积极生活，因为人相对于宇宙来说是很渺小的，所以静静观察自己的生活，享受生活吧！</p>]]></content>
    
    <summary type="html">
    
      2019 徐州网络赛 M Longest subsequence_算法日常[22/100]
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>spoj_nsubstr_sam后缀自动机_算法日常[21/100]</title>
    <link href="http://www.wolfdan.cn/2019/09/06/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-21-100/"/>
    <id>http://www.wolfdan.cn/2019/09/06/算法日常-21-100/</id>
    <published>2019-09-06T14:43:08.000Z</published>
    <updated>2019-09-07T10:45:33.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="http://www.spoj.com/problems/NSUBSTR/" target="_blank" rel="noopener">spoj</a><br><a href="https://vjudge.net/problem/SPOJ-NSUBSTR" target="_blank" rel="noopener">VJ</a></p><p>2019年9月6日22:46:10VJ挂了…只能在spoj(所以注册了一手)上交先了，明天来补这个链接</p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一个串,求出出现次数最多的长度为i(属于[1,|S|])的字串,输出它的出现次数</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>每个节点的endpos集合就是它自己代表的子串在串中出现的次数,然后以这个子串为后缀的更长的串出现的位置通过拓扑排序累加上来了,<strong>存到了r[i]中表示这个节点代表的子串在整个串中所有出现的位置总个数！&lt;==&gt;节点i代表的字串的出现次数</strong>,所以r[i]和F[len[i]]用max维护就行了</li><li>然后拓扑排序可以用基数排序来操作，SAM中常用(不用怕，我注释很多)</li><li>因为长度较短的串的F[i]值维护出来之后有可能是比F[i+1]小的，这样的话最优策略是取i+1长的串的后i长的串，这样F[i]值能变大，所以f[i] = max(F[i],F[i+1])</li></ul><h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">250010</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> r[N&lt;&lt;<span class="number">1</span>],id[N&lt;&lt;<span class="number">1</span>],b[N],F[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sam</span>&#123;</span></span><br><span class="line">    <span class="comment">// 注意N是题目给的n的两倍,因为节点数最多有2*n-1个</span></span><br><span class="line">    <span class="keyword">int</span> p,q,np,nq,cnt,last,a[N&lt;&lt;<span class="number">1</span>][<span class="number">26</span>],l[N&lt;&lt;<span class="number">1</span>],f[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">    sam()&#123;cnt=<span class="number">0</span>;last=++cnt;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cnt=<span class="number">0</span>;last=++cnt;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="built_in">memset</span>(l,<span class="number">0</span>,<span class="keyword">sizeof</span>(l));</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        p=last;np=last=++cnt;l[np]=l[p]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!a[p][c]&amp;&amp;p)a[p][c]=np,p=f[p];</span><br><span class="line">        <span class="keyword">if</span>(!p)f[np]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            q=a[p][c];</span><br><span class="line">            <span class="keyword">if</span>(l[p]+<span class="number">1</span>==l[q])f[np]=q;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    nq=++cnt;l[nq]=l[p]+<span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">memcpy</span>(a[nq],a[q],<span class="keyword">sizeof</span>(a[q]));</span><br><span class="line">                    f[nq]=f[q]; f[np]=f[q]=nq;</span><br><span class="line">                    <span class="keyword">while</span>(a[p][c]==q)a[p][c]=nq,p=f[p];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)extend(s[i]-<span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给主链的right值先+1.因为他们都是叶子节点(从构造算法就可以看出来,虽然这个性质我做了这个题才知道)</span></span><br><span class="line">        <span class="comment">// 源点就是1号节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>,i=<span class="number">0</span>;i&lt;n;i++) p=a[p][s[i]-<span class="string">'a'</span>],r[p]++;</span><br><span class="line">        <span class="comment">// 按照len[x]从小到大基数排序，相当于对SAM图进行拓扑排序(源点也是加入排序的)</span></span><br><span class="line">        <span class="comment">// 第一for先按照长度计数，然后第二for再对长度赋予排名，最后第三for让节点长度排名对应于节点</span></span><br><span class="line">        <span class="comment">// 同长度下，先出现的节点排名大(数值小)--&gt;这个没有多大关系,因为同长度的必定不在同一条拓扑链上</span></span><br><span class="line">        <span class="comment">// 因为从源点出发的每一条链的长度都是递增的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) b[l[i]]++;</span><br><span class="line">        <span class="comment">// 下面的for的i表示的是长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i]+=b[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) id[b[l[i]]--]=i;</span><br><span class="line">        <span class="comment">// 从后往前for,自底向上更新parent的right大小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=cnt;i&gt;=<span class="number">1</span>;i--) r[f[id[i]]]+=r[id[i]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新答案</span></span><br><span class="line">        <span class="comment">// 每个节点的endpos集合就是它自己代表的子串在串中出现的次数</span></span><br><span class="line">        <span class="comment">// 然后以这个子串为后缀的更长的串出现的位置通过拓扑排序累加上来了,</span></span><br><span class="line">        <span class="comment">// 存到了r[i]中表示这个节点代表的子串在整个串中所有出现的位置！&lt;==&gt;出现次数</span></span><br><span class="line">        <span class="comment">// 所以r[i]和F[len[i]]用max维护就行了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) F[l[i]]=max(F[l[i]],r[i]);</span><br><span class="line">        <span class="comment">// 因为长度较短的串的F[i]值有可能是比F[i+1]小的，这样的话最优策略是取i+1长的串的后i长</span></span><br><span class="line">        <span class="comment">// 所以f[i] = max(F[i],F[i+1])</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) F[i]=max(F[i],F[i+<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,F[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; sam;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sam.solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p>有时候状态差，但你不能放弃，因为算法不经历撕心裂肺的思考和试错，是没有生命力的</p>]]></content>
    
    <summary type="html">
    
      SAM后缀自动机刷题笔记 spoj_nsubstr_sam后缀自动机_算法日常 有时候状态差，但你不能放弃，因为算法不经历撕心裂肺的思考和试错，是没有生命力的
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="后缀自动机" scheme="http://www.wolfdan.cn/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-Next-Gemini主题透明化以及背景图片的更改和获取</title>
    <link href="http://www.wolfdan.cn/2019/09/06/Hexo-Next-Gemini%E4%B8%BB%E9%A2%98%E9%80%8F%E6%98%8E%E5%8C%96%E4%BB%A5%E5%8F%8A%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E7%9A%84%E6%9B%B4%E6%94%B9/"/>
    <id>http://www.wolfdan.cn/2019/09/06/Hexo-Next-Gemini主题透明化以及背景图片的更改/</id>
    <published>2019-09-06T01:57:11.000Z</published>
    <updated>2019-09-06T11:07:59.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景图片的更改"><a href="#背景图片的更改" class="headerlink" title="背景图片的更改"></a>背景图片的更改</h1><h2 id="自动变化背景图片或者固定背景图"><a href="#自动变化背景图片或者固定背景图" class="headerlink" title="自动变化背景图片或者固定背景图"></a>自动变化背景图片或者固定背景图</h2><p>找到路径下的custom.styl文件：<br>hexo/themes/next/source/css/_custom/<br>在该文件中加入如下代码(其实next中有这个代码，只是开发团队默认注释掉了)</p><p><strong>自动背景使用的是unsplash.com提供的API链接，感谢</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (min-width:<span class="number">1200px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        background-image:url(https://source.unsplash.com/random/1600x900);      //这一行的括号里填背景图片的路径，将图片重命名为background.jpg放在\themes\next\source\images下</span><br><span class="line">        // background-image:url(/images/background.jpg);      //这一行的括号里填背景图片的路径，将图片重命名为background.jpg放在\themes\next\source\images下</span><br><span class="line">        <span class="selector-tag">background-repeat</span>: <span class="selector-tag">no-repeat</span>;</span><br><span class="line">        <span class="selector-tag">background-attachment</span><span class="selector-pseudo">:fixed</span>;</span><br><span class="line">        <span class="selector-tag">background-position</span><span class="selector-pseudo">:50</span>% 50%;</span><br><span class="line">        <span class="selector-tag">background-size</span><span class="selector-pseudo">:100</span>% 100%;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-id">#footer</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">coler</span>: <span class="number">#eee</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码注解"><a href="#代码注解" class="headerlink" title="代码注解"></a>代码注解</h2><ul><li>background:url为图片路径，也可以直接使用链接</li><li>background-repeat：若果背景图片不能全屏，那么是否平铺显示，充满屏幕</li><li>background-attachment：背景是否随着网页上下滚动而滚动，fixed为固定</li><li>background-position：就是调整图片的位置</li><li>background-size：图片展示大小，这里设置100% 100%的意义为：如果背景图片不能全屏，那么是否通过拉伸的方式将背景强制拉伸至全屏显示。(<strong>让背景图铺满整个页面，<del>简直就是强迫症的解药啊!!!</del></strong>)</li><li>若使用固定图片，那么要将<strong>图片重命名为background.jpg</strong>放在\themes\next\source\images下(<del>说实话，小编一开始不知道要重命名成background，写文章的时候才发现，写文章还是有用呀</del>)</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果很在意网站打开速度的话，不建议使用特别大的背景图片或者是自动变化的背景，因为网站会由于图片太大会拖慢整个网站的载入速度!!</p><h1 id="Gemini主题透明化"><a href="#Gemini主题透明化" class="headerlink" title="Gemini主题透明化"></a>Gemini主题透明化</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>Q:为什么要修改Pisces中的文件？</p><p>A:因为Gemini文件导入了Pisces文件夹中的4个文件</p><h2 id="内容板块透明"><a href="#内容板块透明" class="headerlink" title="内容板块透明"></a>内容板块透明</h2><ol><li>博客根目录 themes\next\source\css_schemes\Pisces_layout.styl 文件 .content-wrap 标签下 background: white修改为：<br><code>background: rgba(255,255,255,0.7); //0.7是透明度</code></li><li>博客根目录 themes\next\source\css_schemes\Gemini\index.styl文件 .post-block 标签下的 background: white修改为：<br><code>background: rgba(255,255,255,0.7); //0.7是透明度</code></li></ol><h2 id="分页-主页最下面的那一小块"><a href="#分页-主页最下面的那一小块" class="headerlink" title="分页(主页最下面的那一小块)"></a>分页(主页最下面的那一小块)</h2><p>博客根目录 themes\next\source\css_schemes\Gemini\index.styl 文件 .pagination 标签下的 background: white修改为：<br><code>background: rgba(255,255,255,0.7); //0.7是透明度</code></p><h2 id="菜单栏背景"><a href="#菜单栏背景" class="headerlink" title="菜单栏背景"></a>菜单栏背景</h2><ol><li>博客根目录 themes\next\source\css_schemes\Pisces_layout.styl 文件 .header-inner 标签下 background: white修改为：<br><code>background: rgba(255,255,255,0.7); //0.7是透明度</code></li><li>博客根目录 themes\next\source\css_schemes\Pisces_sidebar.styl 文件  .sidebar 标签下 增加一行:<br><code>opacity: 0.7; // 0.7透明度自己选择</code></li></ol><h2 id="站点概况背景"><a href="#站点概况背景" class="headerlink" title="站点概况背景"></a>站点概况背景</h2><ol><li>博客根目录 themes\next\source\css_schemes\Pisces_sidebar.styl 文件 .sidebar-inner 标签下 background: white修改为：<br><code>background: rgba(255,255,255,0.7); //0.7是透明度</code></li><li>然后修改博客根目录 themes\next\source\css_schemes\Pisces_layout.styl 文件 .sidebar 标签下 background: $body-bg-color修改为：<br><code>background: rgba(255,255,255,0.7); //0.7是透明度</code></li></ol><h2 id="评论区背景"><a href="#评论区背景" class="headerlink" title="评论区背景"></a>评论区背景</h2><ol><li>博客根目录 themes\next\source\css_schemes\Gemini\index.styl文件 .comments 标签下的 background: white修改为：<br><code>background: rgba(255,255,255,0.7); //0.7是透明度</code></li></ol><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><a href="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/hexo%E4%BC%98%E5%8C%96/%E4%B8%BB%E9%A2%98%E9%80%8F%E6%98%8E%E4%BB%A5%E5%8F%8A%E8%83%8C%E6%99%AF%E5%9B%BE/%E6%95%88%E6%9E%9C%E5%9B%BE1.png" data-fancybox="images" target="_blank" rel="noopener noreferrer"><br>    <img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/hexo%E4%BC%98%E5%8C%96/%E4%B8%BB%E9%A2%98%E9%80%8F%E6%98%8E%E4%BB%A5%E5%8F%8A%E8%83%8C%E6%99%AF%E5%9B%BE/%E6%95%88%E6%9E%9C%E5%9B%BE1.png" width="50%" height="50%" target="_blank"></a><br><a href="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/hexo%E4%BC%98%E5%8C%96/%E4%B8%BB%E9%A2%98%E9%80%8F%E6%98%8E%E4%BB%A5%E5%8F%8A%E8%83%8C%E6%99%AF%E5%9B%BE/%E6%95%88%E6%9E%9C%E5%9B%BE.png" data-fancybox="images" target="_blank" rel="noopener noreferrer"><br>    <img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/hexo%E4%BC%98%E5%8C%96/%E4%B8%BB%E9%A2%98%E9%80%8F%E6%98%8E%E4%BB%A5%E5%8F%8A%E8%83%8C%E6%99%AF%E5%9B%BE/%E6%95%88%E6%9E%9C%E5%9B%BE.png" width="50%" height="50%" target="_blank"></a><br><a href="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/hexo%E4%BC%98%E5%8C%96/%E4%B8%BB%E9%A2%98%E9%80%8F%E6%98%8E%E4%BB%A5%E5%8F%8A%E8%83%8C%E6%99%AF%E5%9B%BE/%E6%95%88%E6%9E%9C%E5%9B%BE2.png" data-fancybox="images" target="_blank" rel="noopener noreferrer"><br>    <img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/hexo%E4%BC%98%E5%8C%96/%E4%B8%BB%E9%A2%98%E9%80%8F%E6%98%8E%E4%BB%A5%E5%8F%8A%E8%83%8C%E6%99%AF%E5%9B%BE/%E6%95%88%E6%9E%9C%E5%9B%BE2.png" width="50%" height="50%" target="_blank"></a></p><h1 id="看到精美背景想要保存？"><a href="#看到精美背景想要保存？" class="headerlink" title="看到精美背景想要保存？"></a>看到精美背景想要保存？</h1><h2 id="比如我看到了这张背景和我的3D雪花特效的叠加效果简直惊艳"><a href="#比如我看到了这张背景和我的3D雪花特效的叠加效果简直惊艳" class="headerlink" title="比如我看到了这张背景和我的3D雪花特效的叠加效果简直惊艳"></a>比如我看到了这张背景和我的3D雪花特效的叠加效果简直惊艳</h2><p><a href="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/hexo%E4%BC%98%E5%8C%96/%E4%B8%BB%E9%A2%98%E9%80%8F%E6%98%8E%E4%BB%A5%E5%8F%8A%E8%83%8C%E6%99%AF%E5%9B%BE/%E6%95%88%E6%9E%9C%E5%9B%BE3%E7%95%99%E5%BD%B1%E4%BD%86%E6%9A%82%E6%9C%AA%E5%B1%95%E7%A4%BA.png" data-fancybox="images" target="_blank" rel="noopener noreferrer"><br>    <img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/hexo%E4%BC%98%E5%8C%96/%E4%B8%BB%E9%A2%98%E9%80%8F%E6%98%8E%E4%BB%A5%E5%8F%8A%E8%83%8C%E6%99%AF%E5%9B%BE/%E6%95%88%E6%9E%9C%E5%9B%BE3%E7%95%99%E5%BD%B1%E4%BD%86%E6%9A%82%E6%9C%AA%E5%B1%95%E7%A4%BA.png" width="50%" height="50%" target="_blank"></a></p><h2 id="好，我教你啊！"><a href="#好，我教你啊！" class="headerlink" title="好，我教你啊！"></a>好，我教你啊！</h2><ol><li>按F12进入开发者，<strong>然后移动开发者模块和页面之间的分隔线让页面宽度变大到显示背景图</strong>(因为之前设置中设置了只有达到一定宽度才会显示图片)</li><li>在source栏目下找到image.unsplash文件夹下的图id,当然可以立马保存啦(操作详见下图)</li></ol><p><a href="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/hexo%E4%BC%98%E5%8C%96/%E4%B8%BB%E9%A2%98%E9%80%8F%E6%98%8E%E4%BB%A5%E5%8F%8A%E8%83%8C%E6%99%AF%E5%9B%BE/%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E6%9C%AC%E7%AB%99%E7%9C%8B%E5%88%B0%E7%9A%84%E7%B2%BE%E7%BE%8E%E7%9A%84random%E7%85%A7%E7%89%87.png" data-fancybox="images" target="_blank" rel="noopener noreferrer"><br>    <img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/hexo%E4%BC%98%E5%8C%96/%E4%B8%BB%E9%A2%98%E9%80%8F%E6%98%8E%E4%BB%A5%E5%8F%8A%E8%83%8C%E6%99%AF%E5%9B%BE/%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E6%9C%AC%E7%AB%99%E7%9C%8B%E5%88%B0%E7%9A%84%E7%B2%BE%E7%BE%8E%E7%9A%84random%E7%85%A7%E7%89%87.png" width="50%" height="50%" target="_blank"></a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://wiki.johnhao.tech/%E7%BB%99Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87/" target="_blank" rel="noopener">大佬-http://wiki.johnhao.tech</a><br><a href="https://www.jianshu.com/p/30bf702f533c" target="_blank" rel="noopener">大佬-芒果浩明</a><br><a href="https://zhuanlan.zhihu.com/p/30836436" target="_blank" rel="noopener">大佬-路人S</a></p>]]></content>
    
    <summary type="html">
    
      Hexo-Next-Gemini主题透明化以及背景图片的更改 更改成自动变化背景图片或者固定背景图 背景铺满整个页面
    
    </summary>
    
      <category term="Hexo" scheme="http://www.wolfdan.cn/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://www.wolfdan.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>SPOJ-LCS,SPOJ-LCS2-后缀自动机SAM专题训练_算法日常[20/100]</title>
    <link href="http://www.wolfdan.cn/2019/09/05/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-20-100/"/>
    <id>http://www.wolfdan.cn/2019/09/05/算法日常-20-100/</id>
    <published>2019-09-05T06:20:17.000Z</published>
    <updated>2019-09-05T13:58:59.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LCS"><a href="#LCS" class="headerlink" title="LCS"></a>LCS</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://vjudge.net/problem/SPOJ-LCS" target="_blank" rel="noopener">VJ上的LCS</a><br><a href="https://www.spoj.com/problems/LCS/en/" target="_blank" rel="noopener">spoj上的LCS</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你两个串，求两个串的最长公共字串</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>大佬:<br>对A建后缀自动机，然后用B去匹配，若能匹配上就转移到儿子，否则沿着parent树向上跳</p><p>我的补充:<br>先看当下B串中新加的字符x是否能通过上次匹配的后缀来转移，如果能转移就直接加，<br>否则就要跳到fa树上去匹配更短endpos为p的后缀(为了找到新加入的字符x的转移)，<br>然后在匹配到之后就是匹配到的长度+1(要加上刚进入的x字符的一个长度)</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">250010</span>;</span><br><span class="line"><span class="keyword">char</span> s1[N],s2[N];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sam</span>&#123;</span></span><br><span class="line">    <span class="comment">// 注意N是题目给的n的两倍,因为节点数最多有2*n-1个</span></span><br><span class="line">      <span class="keyword">int</span> p,q,np,nq,cnt,last,a[N&lt;&lt;<span class="number">1</span>][<span class="number">26</span>],l[N&lt;&lt;<span class="number">1</span>],f[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">      sam()&#123;cnt=<span class="number">0</span>;last=++cnt;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">          cnt=<span class="number">0</span>;last=++cnt;</span><br><span class="line">          <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">          <span class="built_in">memset</span>(l,<span class="number">0</span>,<span class="keyword">sizeof</span>(l));</span><br><span class="line">          <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">            p=last;np=last=++cnt;l[np]=l[p]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(!a[p][c]&amp;&amp;p)a[p][c]=np,p=f[p];</span><br><span class="line">            <span class="keyword">if</span>(!p)f[np]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                  q=a[p][c];</span><br><span class="line">                  <span class="keyword">if</span>(l[p]+<span class="number">1</span>==l[q])f[np]=q;</span><br><span class="line">                  <span class="keyword">else</span>&#123;</span><br><span class="line">                        nq=++cnt;l[nq]=l[p]+<span class="number">1</span>;</span><br><span class="line">                        <span class="built_in">memcpy</span>(a[nq],a[q],<span class="keyword">sizeof</span>(a[q]));</span><br><span class="line">                        f[nq]=f[q]; f[np]=f[q]=nq;</span><br><span class="line">                        <span class="keyword">while</span>(a[p][c]==q)a[p][c]=nq,p=f[p];</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">          init();</span><br><span class="line">          <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s1);<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s2);</span><br><span class="line">          <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s1);</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)extend(s1[i]-<span class="string">'a'</span>);</span><br><span class="line">          ans = <span class="number">0</span>;n=<span class="built_in">strlen</span>(s2);</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,p=<span class="number">1</span>,tp=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = s2[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[p][x]) tp++,p = a[p][x];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(;p&amp;&amp;!a[p][x];p=f[p]);</span><br><span class="line">                <span class="keyword">if</span>(!p) tp=<span class="number">0</span>,p=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> tp = l[p] + <span class="number">1</span>,p = a[p][x];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,tp);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans );</span><br><span class="line">      &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sam.solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LCS2"><a href="#LCS2" class="headerlink" title="LCS2"></a>LCS2</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://vjudge.net/problem/SPOJ-LCS2" target="_blank" rel="noopener">VJ上的LCS2</a><br><a href="https://www.spoj.com/problems/LCS2/" target="_blank" rel="noopener">spoj上的LCS2</a></p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给你多个串，求他们的最长公共字串</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>　　<a href="https://www.cnblogs.com/mjtcn/p/9335863.html" target="_blank" rel="noopener">超级感谢大佬的博文</a></p><p>　　大佬的想法(果然就是多种值维护一下,但是我竟然没有勇气想下去…-&gt;弱鸡下次勇敢点):</p><p>　　poj2774或者就是LCS那道题，对一个串建立后缀自动机，另一个在上面匹配。</p><p>(<strong>下面的方法一在代码中有详细注释，建议复制代码后结合起来看</strong>)<br>　　这道题是对多个串求。那么同样，让每个串在后缀自动机上匹配，然后记录在后缀自动机的每个节点上记录，当前串在这个位置和第一个串的最大匹配数，h数组。</p><p>　　然后mn数组，每次对于这所有的节点的h取小，为从第2个串到现在所有的串，都能在这个节点上匹配的长度。</p><p>　　因为一旦某个节点匹配上了，那么它的父节点（parent树）的父节点都会匹配上（因为父节点是当前点的后缀），<br>　　所以按拓扑倒序，更新父节点的h，为父节点的len，（即最大长度）。</p><p>　　第二种写法是对n-1个字符串建立SAM，然后用最后一个串在n-1个串上匹配，每个自动机上都有一个当前的指针cur，当前答案ans。对最后一个串从头开始扫，求出最后一个串和每个串以当前字符结尾的最大匹配长度，在这里面取小，每次加入一个字符，可以直接判断cur的下一位，不需要从头开始。空间太大。</p><p>　　</p><p>　　总结:两种写法大同小异，只枚举举的顺序不同而已。</p><p>　　其实方法更简洁，更容易看懂，比解法一的缺点是多花了很多空间</p><h2 id="方法一AC代码"><a href="#方法一AC代码" class="headerlink" title="方法一AC代码"></a>方法一AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一 80ms 25.6MB</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();<span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar())<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;<span class="built_in">isdigit</span>(ch);ch=getchar())x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;<span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Suffix_Automaton</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa[N&lt;&lt;<span class="number">1</span>], trans[N&lt;&lt;<span class="number">1</span>][<span class="number">26</span>], len[N&lt;&lt;<span class="number">1</span>], Last, Index;</span><br><span class="line">    <span class="keyword">int</span> v[N], sa[N&lt;&lt;<span class="number">1</span>], mn[N&lt;&lt;<span class="number">1</span>], h[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> P = Last,NP = ++Index;</span><br><span class="line">        len[NP] = len[P] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; P&amp;&amp;!trans[P][c]; P=fa[P]) trans[P][c] = NP;</span><br><span class="line">        <span class="keyword">if</span> (!P) fa[NP] = <span class="number">1</span>; <span class="comment">//-</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> Q = trans[P][c];</span><br><span class="line">            <span class="keyword">if</span> (len[P] + <span class="number">1</span> == len[Q]) fa[NP] = Q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> NQ = ++Index;</span><br><span class="line">                fa[NQ] = fa[Q];</span><br><span class="line">                len[NQ] = len[P] + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">memcpy</span>(trans[NQ], trans[Q], <span class="keyword">sizeof</span> trans[Q]);</span><br><span class="line">                fa[Q] = NQ;</span><br><span class="line">                fa[NP] = NQ;</span><br><span class="line">                <span class="keyword">for</span> (; P&amp;&amp;trans[P][c]==Q; P=fa[P]) trans[P][c] = NQ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Last = NP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Last = Index = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) extend(s[i] - <span class="string">'a'</span>);</span><br><span class="line">        <span class="comment">// index和第一个串s1的下标大致是对应的，但是中间还有克隆的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=Index; ++i) v[len[i]] ++;</span><br><span class="line">        <span class="comment">// 确实是只有n种长度..前缀的后缀--&gt;所有的串--&gt;所以只用n</span></span><br><span class="line">        <span class="comment">// 这里求前缀和只是为了下面能够求出排名数组,让他们按照深度占比权值(有点像权值线段树的那种)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) v[i] += v[i<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">// sa[i] 排名为i的节点。按深度排名（拓扑用）</span></span><br><span class="line">        <span class="comment">// i号节点按照它的len在v中前缀和减减---&gt;其实就是排名,按照节点的长度(也就是深度)---&gt;因为越深越长</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=Index; ++i) sa[ v[len[i]]-- ] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calcc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s+<span class="number">1</span>), now = <span class="number">0</span>, p = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (trans[p][c]) p = trans[p][c], now ++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (; p&amp;&amp;!trans[p][c]; p=fa[p]);</span><br><span class="line">                <span class="keyword">if</span> (!p) now = <span class="number">0</span>, p = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> now = len[p] + <span class="number">1</span>, p = trans[p][c];</span><br><span class="line">            &#125;</span><br><span class="line">            h[p] = max(h[p], now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拓扑倒序，parent树中从深度深的到浅的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=Index; i&gt;=<span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = sa[i];</span><br><span class="line">            mn[t] = min(mn[t], h[t]);</span><br><span class="line">            <span class="comment">// t节点有匹配,并且它的父节点(后缀link)不为源点---&gt;那么让它的父节点的匹配值等于父节点的长度</span></span><br><span class="line">            <span class="comment">// 因为前面的操作是对最长的适配，所以没有管较短串的匹配,所以这里管一下</span></span><br><span class="line">            <span class="comment">// 但是为什么只对父节点，而不对更爷爷节点什么的呢，因为这个拓扑排序从底部向上，所以父节点在之后会出现</span></span><br><span class="line">            <span class="comment">// 所以爷爷节点由后面出现的父节点去管理就行了 ====》 太精妙了，amazing！</span></span><br><span class="line">            <span class="keyword">if</span> (h[t] &amp;&amp; fa[t]) h[fa[t]] = len[fa[t]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        build();</span><br><span class="line">        <span class="built_in">memset</span>(mn, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(mn));</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>) != EOF) calcc();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=Index; ++i) ans = max(ans, mn[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sam.solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二AC代码"><a href="#方法二AC代码" class="headerlink" title="方法二AC代码"></a>方法二AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法二---N-1个自动机 130ms 175.1MB</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();<span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar())<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;<span class="built_in">isdigit</span>(ch);ch=getchar())x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;<span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Last, Index, res, cur, fa[N], trans[N][<span class="number">26</span>], len[N];</span><br><span class="line">    SuffixAutomaton() &#123;Last = Index = cur = <span class="number">1</span>; res = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> P = Last, NP = ++Index;</span><br><span class="line">        len[NP] = len[P] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; P&amp;&amp;!trans[P][c]; P=fa[P]) trans[P][c] = NP;</span><br><span class="line">        <span class="keyword">if</span> (!P) fa[NP] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> Q = trans[P][c];</span><br><span class="line">            <span class="keyword">if</span> (len[P] + <span class="number">1</span> == len[Q]) fa[NP] = Q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> NQ = ++Index;</span><br><span class="line">                fa[NQ] = fa[Q];</span><br><span class="line">                len[NQ] = len[P] + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">memcpy</span>(trans[NQ], trans[Q], <span class="keyword">sizeof</span> trans[Q]);</span><br><span class="line">                fa[Q] = NQ;</span><br><span class="line">                fa[NP] = NQ;</span><br><span class="line">                <span class="keyword">for</span> (; P&amp;&amp;trans[P][c]==Q; P=fa[P]) trans[P][c] = NQ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Last = NP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (trans[cur][c]) &#123;cur = trans[cur][c]; res++; <span class="keyword">return</span> res;&#125;</span><br><span class="line">        <span class="keyword">for</span> (; cur&amp;&amp;!trans[cur][c]; cur=fa[cur]);</span><br><span class="line">        <span class="keyword">if</span> (!cur) res = <span class="number">0</span>, cur = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> res = len[cur] + <span class="number">1</span>, cur = trans[cur][c];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">char</span> str[N&gt;&gt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>,t = <span class="number">0</span>,len;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>)!=EOF) &#123;</span><br><span class="line">        len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len; ++i)</span><br><span class="line">            sam[t].extend(s[i] - <span class="string">'a'</span>);</span><br><span class="line">        t ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    len = <span class="built_in">strlen</span>(str+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;t; ++j)</span><br><span class="line">            tmp = min(tmp, sam[j].solve(str[i] - <span class="string">'a'</span>));</span><br><span class="line">        ans = max(ans, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p><strong>没有自闭，何来爆爽！向自闭的日子致敬！</strong></p>]]></content>
    
    <summary type="html">
    
      SAM后缀自动机刷题笔记 SPOJ-LCS,SPOJ-LCS2-后缀自动机SAM专题训练 没有自闭，何来爆爽！向自闭的日子致敬！
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="后缀自动机" scheme="http://www.wolfdan.cn/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>ARST打卡第19周[19/521]</title>
    <link href="http://www.wolfdan.cn/2019/09/01/ARST%E6%89%93%E5%8D%A1%E7%AC%AC19%E5%91%A8-19-521/"/>
    <id>http://www.wolfdan.cn/2019/09/01/ARST打卡第19周-19-521/</id>
    <published>2019-09-01T10:50:39.000Z</published>
    <updated>2019-09-01T11:35:16.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p><a href="https://github.com/wolfdan666/WolfEat3moreMeatEveryday/tree/master/2019.8/2019.8.30" target="_blank" rel="noopener">这段时间生活有点动荡，刷得题就少了</a></p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p><a href="https://onezero.medium.com/the-huawei-sanction-might-just-pop-the-tech-bubble-f7e800e3174" target="_blank" rel="noopener">The Huawei Sanction Might Just Pop the Tech Bubble</a><br>对华为的制裁应该不会引发这个外国科技大佬所说的互联网圈泡沫，但是下跌确实是很可能，所以科技界的朋友们也要赶紧学会华为的危机意识—永远为”冬天”和”黑天鹅事件”做准备</p><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p><a href="https://www.luogu.org/blog/Kesdiael3/hou-zhui-zi-dong-ji-yang-xie" target="_blank" rel="noopener">后缀数组学习资料</a></p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p><a href="https://www.wolfdan.cn/2019/08/30/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-19-100/">SAM后缀自动机学习路线</a></p>]]></content>
    
    <summary type="html">
    
      ARST打卡 对华为的制裁应该不会引发这个外国科技大佬所说的互联网圈泡沫，但是下跌确实是很可能，所以科技节的小伙伴也要学习华为的危机意识--永远为&quot;冬天&quot;和&quot;黑天鹅事件&quot;做准备   SAM后缀自动机学习路线
    
    </summary>
    
      <category term="ARST" scheme="http://www.wolfdan.cn/categories/ARST/"/>
    
    
      <category term="ARST" scheme="http://www.wolfdan.cn/tags/ARST/"/>
    
  </entry>
  
  <entry>
    <title>SAM后缀自动机学习路线_算法日常[19/100]</title>
    <link href="http://www.wolfdan.cn/2019/08/30/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-19-100/"/>
    <id>http://www.wolfdan.cn/2019/08/30/算法日常-19-100/</id>
    <published>2019-08-30T10:08:12.000Z</published>
    <updated>2019-09-05T13:13:49.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习路径推荐"><a href="#学习路径推荐" class="headerlink" title="学习路径推荐"></a>学习路径推荐</h1><p>　　网上有很多的学习SAM的资料，但是很多资料写得比较全面，导致一开始看可能看不懂(<del>可能只是因为博主自己比较菜</del>)，然后博主自己整理了一个学习路线，希望对大家有点帮助</p><ol><li><a href="http://hihocoder.com/problemset/problem/1441" target="_blank" rel="noopener">简介版本的SAM</a></li><li><a href="https://oi-wiki.org/string/sam/" target="_blank" rel="noopener">比较全面的SAM版本</a><ul><li>个人感觉这里的后缀链接初次看有点难懂</li><li>还有那个算法的思路也会有点懵逼，懵逼的话建议可以先看紧接在下面的<code>算法正确性证明</code>，不然很容易自闭</li><li>建议先看<code>简介版本的SAM</code>的后缀链接的介绍先然后再来看这个比较好_大佬请无视</li></ul></li><li><a href="https://www.cnblogs.com/zinthos/p/3899679.html?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">经典题集</a></li></ol><hr><p>2019年9月5日14:21:10 补充，建议参考链接增加以及自己学习历程的一些心得</p><ul><li>增加的参考链接: <a href="https://www.luogu.org/blog/Kesdiael3/hou-zhui-zi-dong-ji-yang-xie" target="_blank" rel="noopener">史上最通俗的后缀自动机详解</a></li><li>学习历程: 我比较菜，所以断断续续地看了5天(主要是看不懂然后就总发呆…(雾))，然后第6天重新看了一遍oi-wiki的教程，发现自己看得懂了！(得益于前几天不断地看简介版和通俗易懂版的，让自己重新看的时候感觉许多都会，然后就有了一个比较全面的认识，然后就终于看懂了SAM算法，自闭6天后要不要这么爽)</li><li>学习心得:<ul><li>找一个安静的环境，让自己能够保持专注</li><li>抽出一整块的时间来看SAM专题</li><li>一次没有看懂没关系，反复看，找各种不同的资料看</li><li>手动笔记，写写画画</li><li>最终总结出自己的笔记</li></ul></li><li>避坑提醒: oi-wiki给的板子中用的是map映射的next，<strong>建议改成<code>int next[符号集大小]</code></strong>，因为我做题时map，unordered_map都TLE了…</li></ul><hr><h1 id="送一个bug-free的注释"><a href="#送一个bug-free的注释" class="headerlink" title="送一个bug_free的注释"></a>送一个bug_free的注释</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *　　　　　　　 ┏┓　 ┏┓+ +</span></span><br><span class="line"><span class="comment"> *　　　　　　　┏┛┻━━━┛┻┓ + +</span></span><br><span class="line"><span class="comment"> *　　　　　　　┃　　　 ┃ 　</span></span><br><span class="line"><span class="comment"> *　　　　　　　┃　　　 ┃ ++ + + +</span></span><br><span class="line"><span class="comment"> *　　　　　　 ████━████┃+</span></span><br><span class="line"><span class="comment"> *　　　　　　　┃　　　 ┃ +</span></span><br><span class="line"><span class="comment"> *　　　　　　　┃　┻　　┃</span></span><br><span class="line"><span class="comment"> *　　　　　　　┃　　　 ┃ + +</span></span><br><span class="line"><span class="comment"> *　　　　　　　┗━┓　 ┏━┛</span></span><br><span class="line"><span class="comment"> *　　　　　　　　┃　 ┃　　　　　　　　　　　</span></span><br><span class="line"><span class="comment"> *　　　　　　　　┃　 ┃ + + + +</span></span><br><span class="line"><span class="comment"> *　　　　　　　　┃　 ┃　　　　Code is far away from bug with the animal protecting　　　　　　　</span></span><br><span class="line"><span class="comment"> *　　　　　　　　┃　 ┃ + 　　　　神兽保佑,代码无bug　　</span></span><br><span class="line"><span class="comment"> *　　　　　　　　┃　 ┃</span></span><br><span class="line"><span class="comment"> *　　　　　　　　┃　 ┃　　+　　　　　　　　　</span></span><br><span class="line"><span class="comment"> *　　　　　　　　┃　 ┗━━━┓ + +</span></span><br><span class="line"><span class="comment"> *　　　　　　　　┃  　　 ┣┓</span></span><br><span class="line"><span class="comment"> *　　　　　　　　┃  　　 ┏┛</span></span><br><span class="line"><span class="comment"> *　　　　　　　　┗┓┓┏━┳┓┏┛ + + + +</span></span><br><span class="line"><span class="comment"> *　　　　　　　　 ┃┫┫ ┃┫┫</span></span><br><span class="line"><span class="comment"> *　　　　　　　　 ┗┻┛ ┗┻┛+ + + +</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"厉Hello World哥!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p> <a href="https://www.xinpianchang.com/a10477709" target="_blank" rel="noopener">生活或许很苦，但我偏要酷</a></p><p> <strong>认清生活的残酷然后依旧挣扎着往上爬，致平凡世界里的英雄们！</strong></p>]]></content>
    
    <summary type="html">
    
      SAM后缀自动机学习路线,学习资源 2019年9月5日14:29更新
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="后缀数组" scheme="http://www.wolfdan.cn/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
      <category term="后缀自动机" scheme="http://www.wolfdan.cn/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>ARST打卡第18周[18/521]</title>
    <link href="http://www.wolfdan.cn/2019/08/24/ARST%E6%89%93%E5%8D%A1%E7%AC%AC18%E5%91%A8-18-521/"/>
    <id>http://www.wolfdan.cn/2019/08/24/ARST打卡第18周-18-521/</id>
    <published>2019-08-24T08:01:29.000Z</published>
    <updated>2019-08-24T08:49:46.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p><a href="https://github.com/wolfdan666/WolfEat3moreMeatEveryday/tree/master/2019.8/2019.8.22" target="_blank" rel="noopener">后缀数组自学并题目训练</a></p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p><a href="https://medium.com/@zdravko/13-things-you-need-to-give-up-if-you-want-to-be-successful-44b5b9b06a26" target="_blank" rel="noopener">13 Things You Should Give Up If You Want To Be Successful</a></p><h2 id="Give-Up-On-Saying-YES-To-Things-That-Don’t-Support-Your-Goals"><a href="#Give-Up-On-Saying-YES-To-Things-That-Don’t-Support-Your-Goals" class="headerlink" title="Give Up On Saying YES To Things That Don’t Support Your Goals"></a>Give Up On Saying YES To Things That Don’t Support Your Goals</h2><p>Successful people know that in order to accomplish their goals, they will have to say NO to certain tasks, activities, and demands from their friends, family, and colleagues.<br>In the short-term, you might sacrifice a bit of instant gratification, but when your goals come to fruition, it will all be worth it.</p><p>是的，这也是杜月笙先生教给我的事情，成功需要代价</p><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p><a href="https://www.xinpianchang.com/a10477709" target="_blank" rel="noopener">生活很苦，我偏要酷</a></p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p><a href="https://www.wolfdan.cn/2019/08/19/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-14-100/">2019杭电多校9题解_算法日常[14/100]</a></p><p><a href="https://www.wolfdan.cn/2019/08/20/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-15-100/">后缀数组学习路径以及后缀数组板子推送_算法日常[15/100]</a></p><p><a href="https://www.wolfdan.cn/2019/08/21/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-16-100/">后缀数组基础题poj1743详解_算法日常[16/100]</a></p><p><a href="https://www.wolfdan.cn/2019/08/22/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-17-100/">HDU5008详解_后缀数组_二分_RMQ_算法日常[17/100]</a></p><p><a href="https://www.wolfdan.cn/2019/08/23/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-18-100/">2019CCPC网络预选赛1003题解_算法日常[18/100]</a></p>]]></content>
    
    <summary type="html">
    
      ARST打卡 生活很苦，我偏要酷 是的，这也是杜月笙先生教给我的事情，成功需要代价 13 Things You Should Give Up If You Want To Be Successful HDU5008详解_后缀数组_二分_RMQ CCPC1003后缀数组+主席树
    
    </summary>
    
      <category term="ARST" scheme="http://www.wolfdan.cn/categories/ARST/"/>
    
    
      <category term="ARST" scheme="http://www.wolfdan.cn/tags/ARST/"/>
    
  </entry>
  
  <entry>
    <title>2019CCPC网络预选赛1003 K-th occurrence 题解_算法日常[18/100]</title>
    <link href="http://www.wolfdan.cn/2019/08/23/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-18-100/"/>
    <id>http://www.wolfdan.cn/2019/08/23/算法日常-18-100/</id>
    <published>2019-08-23T01:51:13.000Z</published>
    <updated>2019-09-04T11:38:59.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="K-th-occurrence"><a href="#K-th-occurrence" class="headerlink" title="K-th occurrence"></a>K-th occurrence</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://vjudge.net/problem/HDU-6704" target="_blank" rel="noopener">VJ上面</a><br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6704" target="_blank" rel="noopener">HDOJ上面</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法一SAM解法"><a href="#解法一SAM解法" class="headerlink" title="解法一SAM解法"></a>解法一SAM解法</h3><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/%E6%AF%94%E8%B5%9B/%E7%BA%BF%E4%B8%8A/2019CCPC%E7%BD%91%E7%BB%9C%E9%A2%84%E9%80%89%E8%B5%9B/1003an.png" alt></p><hr><p>2019年9月4日19:24:25 补充，不好意思，博主太菜了，补SAM补了6天才看懂，现在第7天才看懂SAM的写法，所以补充一下</p><ol><li>对于题解中说的倍增数组就是代码中的Fa数组，构造极其精巧，建议看一下解法一注释版的代码</li><li>关于权值线段树(就是题解中说的给每种前缀设置一种权值)，其实就是建立线段树的时候，让主席树的每个点都有个权值，这样就可以在询问的时候方便的找到第k大了(具体见代码)</li></ol><hr><h3 id="解法二SA解法"><a href="#解法二SA解法" class="headerlink" title="解法二SA解法"></a>解法二SA解法</h3><p>ST表维护下 后缀排序后的公共长度 的最小值，然后二分找出左右符合的位置，主席树维护下排序后的序列，然后主席树查询第k大即可</p><hr><p>2019年8月27日19:23:14 补充(代码也补充为注释版)(<strong>发现写blog的时候自己的理解确实有明显加深!所以还是要坚持写blog,推荐大家也可以写点博客啥的</strong>)</p><hr><p>我们想要找到所有的字串s的第k个，就要找到所有字串出现的位置，用后缀数组去找的方法就是使用后缀的最长公共前缀长度相同来实现寻找，即找到height数组的一段连续区间的最小值都要是s的长度(当然前缀是s),这里可以用二分区间查找st表版本的rmq信息来确定最终的左右区间，然后再用可持久化线段树来找到这个排名区间里的第k个起始位置(之前建立可持久化线段树的时候就<strong>通过位置信息让每个rank字串在前一个rank字串所建立的线段树树上(最初为空树)新建一条分支树</strong>),rank1字串对应于版本1的主席树(可持久化线段树)，rank2字串对应于版本2的主席树，然后我们询问rank区间[l,r]的时候，就是直接用版本[l,r]的主席树的节点数差来看这里面的字串数是否达到了k个(之前已经保证了前缀相同)，是则继续访问左子树第k大，否则访问右子树第<code>k-左边的个数</code>大(<strong>可以注意到我们左右子树和位置的[l,mid],[mid+1,r]在建树的时候是假定了空间映射关系的!</strong>),这样就可以找到对应位置了</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h3 id="解法一SAM解法-1"><a href="#解法一SAM解法-1" class="headerlink" title="解法一SAM解法"></a>解法一SAM解法</h3><p>感谢CSU一个大佬提供代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> T[<span class="number">200010</span>][<span class="number">30</span>],fa[<span class="number">200010</span>],len[<span class="number">200010</span>],cnt,last,n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,p=last,np,q,nq;</span><br><span class="line">    last=np=++cnt;</span><br><span class="line">    len[np]=len[p]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p&amp;&amp;T[p][v]==<span class="number">0</span>;p=fa[p]) T[p][v]=np;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) fa[np]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        q=T[p][v];</span><br><span class="line">        <span class="keyword">if</span>(len[q]==len[p]+<span class="number">1</span>) fa[np]=q;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            nq=++cnt;</span><br><span class="line">            len[nq]=len[p]+<span class="number">1</span>;</span><br><span class="line">            fa[nq]=fa[q];</span><br><span class="line">            fa[q]=fa[np]=nq;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">27</span>;i++) T[nq][i]=T[q][i];</span><br><span class="line">            <span class="keyword">for</span>(;T[p][v]==q;p=fa[p]) T[p][v]=nq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root[<span class="number">200010</span>],num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> L,R,sum;</span><br><span class="line">&#125;A[<span class="number">8000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    A[++num]=A[x];</span><br><span class="line">    x=num;</span><br><span class="line">    A[x].sum++;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=mid) update(A[x].L,l,mid,k,v);</span><br><span class="line">    <span class="keyword">else</span> update(A[x].R,mid+<span class="number">1</span>,r,k,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mer</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>||b==<span class="number">0</span>) <span class="keyword">return</span> a+b;</span><br><span class="line">    <span class="keyword">int</span> z=++num,mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">         A[z].sum=A[a].sum|A[b].sum;</span><br><span class="line">         <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">    A[z].L=mer(A[a].L,A[b].L,l,mid);</span><br><span class="line">    A[z].R=mer(A[a].R,A[b].R,mid+<span class="number">1</span>,r);</span><br><span class="line">    A[z].sum=A[A[z].L].sum+A[A[z].R].sum;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qkth</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=A[A[x].L].sum) <span class="keyword">return</span> qkth(A[x].L,l,mid,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> qkth(A[x].R,mid+<span class="number">1</span>,r,k-A[A[x].L].sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;g[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> Fa[<span class="number">200010</span>][<span class="number">25</span>],pos[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,v;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">19</span>;i++) Fa[u][i]=Fa[Fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;g[u].size();i++)&#123;</span><br><span class="line">        v=g[u][i];</span><br><span class="line">        Fa[v][<span class="number">0</span>]=u;</span><br><span class="line">        dfs(v);</span><br><span class="line">        root[u]=mer(root[u],root[v],<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,m,t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">        cnt=last=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(T,<span class="number">0</span>,<span class="keyword">sizeof</span>(T));</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">200000</span>;i++) g[i].clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;s[i];i++) build(s[i]-<span class="string">'a'</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=cnt;i++) g[fa[i]].push_back(i);</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">1</span>,v;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(root,<span class="number">0</span>,<span class="keyword">sizeof</span>(root));</span><br><span class="line">        A[<span class="number">0</span>].L=A[<span class="number">0</span>].R=A[<span class="number">0</span>].sum=num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;s[i];i++)&#123;</span><br><span class="line">            v=s[i]-<span class="string">'a'</span>;</span><br><span class="line">            p=T[p][v];</span><br><span class="line">            pos[i]=p;</span><br><span class="line">            update(root[p],<span class="number">1</span>,n,i,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l,r,k,u,a;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;a);</span><br><span class="line">            p=pos[r];</span><br><span class="line">            k=r-l+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(len[Fa[p][i]]&gt;=k) p=Fa[p][i];</span><br><span class="line">            <span class="keyword">if</span>(a&gt;A[root[p]].sum) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                u=qkth(root[p],<span class="number">1</span>,n,a);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,u-k+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="SAM解法注释版"><a href="#SAM解法注释版" class="headerlink" title="SAM解法注释版"></a>SAM解法注释版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2019年9月3日20:44:23 开始看</span></span><br><span class="line"><span class="comment">2019年9月4日11:39:03 再看</span></span><br><span class="line"><span class="comment">主席树+SAM都是刚刚学了一点点皮毛，然后就要接受这种魔鬼题目训练，真是毒打</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">感觉后缀数组用的是各种后缀的前缀，而后缀自动机则是用前缀的后缀比较多，因为endpos就相当于前缀的感觉</span></span><br><span class="line"><span class="comment">后缀数组的LCP(Longest Common Prefix)问题等价于后缀树的最小公共祖先LCA(Least Common Ancestor)问题</span></span><br><span class="line"><span class="comment">前者是后缀的共同前缀，后者是前缀endpos的共同后缀(link)---&gt; 也即sam构成的后缀link树的lca</span></span><br><span class="line"><span class="comment">有一点点的融会贯通的感觉真他妈的爽啊！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">题意:</span></span><br><span class="line"><span class="comment">T组,N次询问,  l,r这个子串的第k次出现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> T[<span class="number">200010</span>][<span class="number">30</span>],fa[<span class="number">200010</span>],len[<span class="number">200010</span>],cnt,last,n;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这里是建立SAM.大佬的板子真滴简洁..*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,p=last,np,q,nq;</span><br><span class="line">    last=np=++cnt;</span><br><span class="line">    len[np]=len[p]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p&amp;&amp;T[p][v]==<span class="number">0</span>;p=fa[p]) T[p][v]=np;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) fa[np]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        q=T[p][v];</span><br><span class="line">        <span class="keyword">if</span>(len[q]==len[p]+<span class="number">1</span>) fa[np]=q;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            nq=++cnt;</span><br><span class="line">            len[nq]=len[p]+<span class="number">1</span>;</span><br><span class="line">            fa[nq]=fa[q];</span><br><span class="line">            fa[q]=fa[np]=nq;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">27</span>;i++) T[nq][i]=T[q][i];</span><br><span class="line">            <span class="keyword">for</span>(;T[p][v]==q;p=fa[p]) T[p][v]=nq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*root[i]数组表示的是endpos为i的节点*/</span></span><br><span class="line"><span class="keyword">int</span> root[<span class="number">200010</span>],num;</span><br><span class="line"><span class="comment">/*开了40倍的这里是主席树,若只考虑最大的大小和n次修改,每次log(n)的话,那么其实只要2n-1+nlog(n)就行</span></span><br><span class="line"><span class="comment">也就是只要19e5===&gt;也可以直接n &lt;&lt; 5 ,即(2^5)*n    */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> L,R,sum;</span><br><span class="line">&#125; A[<span class="number">8000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pos[i]=p;---&gt; pos数组就是endpos数组,不懂可以参考[oi-wiki/sam](https://oi-wiki.org/string/sam/)</span></span><br><span class="line"><span class="comment">update(root[p],1,n,i,1);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*下面三句话就是1. 获取之前的节点(之前也可能是空节点)信息</span></span><br><span class="line"><span class="comment">    2. 让当前的root[]等于新得到的id(sum)_3.然后在这个id上进行玩耍*/</span></span><br><span class="line">    <span class="comment">/*总体上就是记录一条新建的边上的所有信息,最主要的是维护权值--为了求出第k大*/</span></span><br><span class="line">    <span class="comment">/*我们从递归的角度看进去,发现每个node左右点都是从1开始一直加的，所以这就是权值主席树*/</span></span><br><span class="line">    A[++num]=A[x];</span><br><span class="line">    x=num;</span><br><span class="line">    A[x].sum++;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=mid) update(A[x].L,l,mid,k,v);</span><br><span class="line">    <span class="keyword">else</span> update(A[x].R,mid+<span class="number">1</span>,r,k,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*root[u]=mer(root[u],root[v],1,n);*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mer</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>||b==<span class="number">0</span>) <span class="keyword">return</span> a+b;</span><br><span class="line">    <span class="keyword">int</span> z=++num,mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="comment">/*因为sum要么一样,要么某一个为0,所以用'或'操作*/</span></span><br><span class="line">         A[z].sum=A[a].sum|A[b].sum;</span><br><span class="line">         <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">    A[z].L=mer(A[a].L,A[b].L,l,mid);</span><br><span class="line">    A[z].R=mer(A[a].R,A[b].R,mid+<span class="number">1</span>,r);</span><br><span class="line">    A[z].sum=A[A[z].L].sum+A[A[z].R].sum;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">u=qkth(root[p],1,n,a);</span></span><br><span class="line"><span class="comment">printf("%d\n",u-k+1);</span></span><br><span class="line"><span class="comment">返回的是endpos值...也就是返回的是串的右端点...也就是说答案是u-k+1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qkth</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=A[A[x].L].sum) <span class="keyword">return</span> qkth(A[x].L,l,mid,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> qkth(A[x].R,mid+<span class="number">1</span>,r,k-A[A[x].L].sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;g[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> Fa[<span class="number">200010</span>][<span class="number">25</span>],pos[<span class="number">200010</span>];</span><br><span class="line"><span class="comment">/*dfs(1)*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,v;</span><br><span class="line">    <span class="comment">/*这里i为什么是&lt;=19?...---&gt;每次插入主席树一条边需要log(n),这题就是约等18左右,开到19是为了保险</span></span><br><span class="line"><span class="comment">    这里的大的Fa不是sam中的fa*/</span></span><br><span class="line">    <span class="comment">/*最最开始这里的初始化都是0,后面就是链状的，用i来dp，真是太巧妙了！</span></span><br><span class="line"><span class="comment">    比如Fa[u][0]=0;Fa[v][0]=u;Fa[w][0]=v.  那么Fa[w][1]=Fa[v][0]=u</span></span><br><span class="line"><span class="comment">    这就是dp叠层数了===&gt; 所以后面使用的时候就直接用Fa[p][i]就行了*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">19</span>;i++) Fa[u][i]=Fa[Fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;g[u].size();i++)&#123;</span><br><span class="line">        v=g[u][i];</span><br><span class="line">        <span class="comment">/*v的直接父亲是u...*/</span></span><br><span class="line">        Fa[v][<span class="number">0</span>]=u;</span><br><span class="line">        dfs(v);</span><br><span class="line">        root[u]=mer(root[u],root[v],<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,m,t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">        cnt=last=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(T,<span class="number">0</span>,<span class="keyword">sizeof</span>(T));</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">200000</span>;i++) g[i].clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*构建SAM*/</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;s[i];i++) build(s[i]-<span class="string">'a'</span>);</span><br><span class="line">        <span class="comment">/*i的后缀link放入i,也就是g表示源点到终止节点的方向,fa数组的反hash*/</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=cnt;i++) g[fa[i]].push_back(i);</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">1</span>,v;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(root,<span class="number">0</span>,<span class="keyword">sizeof</span>(root));</span><br><span class="line">        A[<span class="number">0</span>].L=A[<span class="number">0</span>].R=A[<span class="number">0</span>].sum=num=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*插入构建主席树*/</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;s[i];i++)&#123;</span><br><span class="line">            v=s[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="comment">/*p就是转移之后的节点啊，所以就是说每个节点在主席树上都是一棵新树*/</span></span><br><span class="line">            p=T[p][v];</span><br><span class="line">            <span class="comment">/*对，pos就是endpos，转移就是转移到下一个状态*/</span></span><br><span class="line">            pos[i]=p;</span><br><span class="line">            update(root[p],<span class="number">1</span>,n,i,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*前面生成g[]数组的时候,fa[i]最小值就是1,所以dfs(1)就是从源点跑到各个点去,然后合并每个endpos对应的所有后缀...*/</span></span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l,r,k,u,a;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;a);</span><br><span class="line">            <span class="comment">/*获取endpos为r的状态点*/</span></span><br><span class="line">            p=pos[r];</span><br><span class="line">            <span class="comment">/*这里的k竟然是长度...*/</span></span><br><span class="line">            k=r-l+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">/*为啥又是19,这个是哪来的数字！==&gt;难道说是一个log(n)的大小！好像是！</span></span><br><span class="line"><span class="comment">            那么这里的意思应该就是: 找出最短的长度大于要求的字串长的后缀</span></span><br><span class="line"><span class="comment">            然后如果对应的节点的权值不够a(其实就是题中说的k),那么直接输出-1</span></span><br><span class="line"><span class="comment">            否则就去主席树中找出答案，所以dfs(1)应该就是从源点出发找到终止节点之类的操作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            可得好好研究一下Fa数组的作用! 这里从它的作用来看就是用在了自成一体的fa树！就是</span></span><br><span class="line"><span class="comment">            答案中说的  扒出 parent树 ，然后利用这个来操作...找到这个串位置对应于主席树的位置</span></span><br><span class="line"><span class="comment">            因为之前的fa[]是与主席树没有任何联系的，所以我们需要这个Fa来构建联系</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(len[Fa[p][i]]&gt;=k) p=Fa[p][i];</span><br><span class="line">            <span class="keyword">if</span>(a&gt;A[root[p]].sum) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                u=qkth(root[p],<span class="number">1</span>,n,a);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,u-k+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法二SA解法-1"><a href="#解法二SA解法-1" class="headerlink" title="解法二SA解法"></a>解法二SA解法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> t1[N],t2[N],sum[N],rk[N],ht[N],sa[N],str[N];<span class="keyword">char</span> s[<span class="number">100100</span>];</span><br><span class="line"><span class="comment">/*最小19*N,保守(2^5)*N(即N&lt;&lt;5)*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node1</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125; tr[N * <span class="number">22</span>];</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">22</span>];</span><br><span class="line"><span class="keyword">int</span> root[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_sa</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *x=t1,*y=t2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) sum[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) sum[x[i]=str[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++) sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--sum[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p,j=<span class="number">1</span>;p&lt;=n;j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-j;i&lt;n;i++) y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(sa[i]&gt;=j) y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) sum[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) sum[x[y[i]]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++) sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--sum[x[y[i]]]]=y[i];</span><br><span class="line">        swap(x,y);</span><br><span class="line">        p=<span class="number">1</span>;</span><br><span class="line">        x[sa[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) x[sa[i]]=y[sa[i<span class="number">-1</span>]]==y[sa[i]]&amp;&amp;y[sa[i<span class="number">-1</span>]+j]==y[sa[i]+j]?p<span class="number">-1</span>:p++;</span><br><span class="line">        <span class="keyword">if</span>(p&gt;=n) <span class="keyword">break</span>;</span><br><span class="line">        m=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;n--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) rk[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k)k--;<span class="keyword">else</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=sa[rk[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(str[i+k]==str[j+k])k++;</span><br><span class="line">        ht[rk[i]]=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*对ht数组建立st表,这样就能取区间LCP*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i][<span class="number">0</span>] = ht[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">22</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n; j++)</span><br><span class="line">            f[j][i] = min(f[j][i - <span class="number">1</span>], f[j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pl, <span class="keyword">int</span> pr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = log2(pr - pl + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> min(f[pl][t], f[pr - (<span class="number">1</span> &lt;&lt; t) + <span class="number">1</span>][t]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// root[i] = update1(root[i - 1], 1, n, sa[i] + 1);</span></span><br><span class="line"><span class="comment">/*root数组的key是rk,然后值是key对应的值是线段树节点位置(1是主根)</span></span><br><span class="line"><span class="comment">root也是tr的键,val记录的是某个rk的在root[rk]号树上的**位置前缀和**</span></span><br><span class="line"><span class="comment">然后tr数组就就是记录着主席树上的节点轨迹</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update1</span><span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*主席树外分支++*/</span></span><br><span class="line">    <span class="keyword">int</span> cur = ++tot;</span><br><span class="line">    <span class="comment">/*新开轨迹获取之前轨迹的信息,在之前信息上添加*/</span></span><br><span class="line">    tr[cur] = tr[pre];</span><br><span class="line">    tr[cur].val++;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> cur;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*动态开左孩子或者右孩子点*/</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid) tr[cur].l = update1(tr[pre].l, l, mid, pos);</span><br><span class="line">    <span class="keyword">else</span> tr[cur].r = update1(tr[pre].r, mid + <span class="number">1</span>, r, pos);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// queryk(root[cntl - 1], root[cntr], 1, n, k)</span></span><br><span class="line"><span class="comment">/*cntl - 1 的rk也是LCP符合条件的，所以这里需要cntl-1*/</span></span><br><span class="line"><span class="comment">/*pl.pr是rk区间对应的根区间，他们的val值记录着sa之间的差值，类是于线段树rmq=&gt;可以rkq</span></span><br><span class="line"><span class="comment">然后是主席树是同左同右操作的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryk</span><span class="params">(<span class="keyword">int</span> pl, <span class="keyword">int</span> pr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[tr[pr].l].val - tr[tr[pl].l].val &gt;= k) <span class="keyword">return</span> queryk(tr[pl].l, tr[pr].l, l, mid, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> queryk(tr[pl].r, tr[pr].r, mid + <span class="number">1</span>, r, k - (tr[tr[pr].l].val - tr[tr[pl].l].val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;<span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">int</span> l, r, k;</span><br><span class="line">    <span class="keyword">int</span> ll, rr, mid;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> cntl, cntr;<span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        n=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) str[i] = s[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">        str[n]=<span class="number">0</span>;</span><br><span class="line">        get_sa(n+<span class="number">1</span>,<span class="number">30</span>);</span><br><span class="line">        <span class="comment">/*这里是ht的st_rmq*/</span></span><br><span class="line">        build(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">            root[i] = update1(root[i - <span class="number">1</span>], <span class="number">1</span>, n, sa[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;l, &amp;r, &amp;k);</span><br><span class="line">            tmp = r - l + <span class="number">1</span>;</span><br><span class="line">            l = rk[l - <span class="number">1</span>];</span><br><span class="line">            ll = <span class="number">1</span>, rr = l;</span><br><span class="line">            <span class="keyword">while</span>(ll &lt;= rr) &#123;</span><br><span class="line">                mid = (ll + rr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                cnt = <span class="number">100000</span>;</span><br><span class="line">                <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= l) cnt = query(mid + <span class="number">1</span>, l);</span><br><span class="line">                <span class="keyword">if</span>(cnt &gt;= tmp) &#123;</span><br><span class="line">                    cntl = mid;</span><br><span class="line">                    rr = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ll = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ll = l, rr = n;</span><br><span class="line">            <span class="keyword">while</span>(ll &lt;= rr) &#123;</span><br><span class="line">                mid = (ll + rr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                cnt = <span class="number">100000</span>;</span><br><span class="line">                <span class="keyword">if</span>(l + <span class="number">1</span> &lt;= mid) cnt = query(l + <span class="number">1</span>, mid);</span><br><span class="line">                <span class="keyword">if</span>(cnt &gt;= tmp) &#123;</span><br><span class="line">                    cntr = mid;</span><br><span class="line">                    ll = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    rr = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cntr - cntl + <span class="number">1</span> &lt; k) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, queryk(root[cntl - <span class="number">1</span>], root[cntr], <span class="number">1</span>, n, k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考大佬链接"><a href="#参考大佬链接" class="headerlink" title="参考大佬链接"></a>参考大佬链接</h3><p><a href="https://blog.csdn.net/mmk27_word/article/details/100045708" target="_blank" rel="noopener">https://blog.csdn.net/mmk27_word/article/details/100045708</a></p><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p>世界上总是存在很多的二八定律，不过也应该二八定律，因为总有那么一些人愿意花几倍于人的自律和代价去提高一点点被幸运之神眷顾的机会</p>]]></content>
    
    <summary type="html">
    
      2019CCPC网络预选赛1003 K-th occurrence 题解_算法日常 HDU-6704 K-th occurrence (后缀自动机father树上倍增建权值线段树合并) 后缀数组+ST 二分+主席树 世界上总是存在很多的二八定律，不过也应该二八定律，因为总有那么一些人愿意花几倍于人的自律和代价去提高一点点被幸运之神眷顾的机会 2019.8.27有解法二补充 2019.9.4对解法一补充
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="后缀数组" scheme="http://www.wolfdan.cn/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
      <category term="后缀自动机" scheme="http://www.wolfdan.cn/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>HDU5008详解_后缀数组_二分_RMQ_算法日常[17/100]</title>
    <link href="http://www.wolfdan.cn/2019/08/22/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-17-100/"/>
    <id>http://www.wolfdan.cn/2019/08/22/算法日常-17-100/</id>
    <published>2019-08-22T11:28:10.000Z</published>
    <updated>2019-08-22T13:52:51.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HDU5008"><a href="#HDU5008" class="headerlink" title="HDU5008"></a>HDU5008</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://vjudge.net/problem/HDU-5008" target="_blank" rel="noopener">VJ上面</a><br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5008" target="_blank" rel="noopener">hdu上面</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个串，q次查询里面第k大的字串，并且要求输出这个串最早出现的位置的左右下标值</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>Tips:看不懂题解的话可以看题解下面的题解小细节(<del>之所以在前面提示是因为小编经常看到一个东西自己想了半天，然后发现后面竟然有解释…所以感觉有点浪费时间，所以自己的博文应该防止自己陷入同样的坑</del>)</strong></p><h3 id="解法一-无RMQ-O-case-q-log-n-n"><a href="#解法一-无RMQ-O-case-q-log-n-n" class="headerlink" title="解法一 无RMQ O(case*q*(log_(n)+n))"></a>解法一 无RMQ O(<code>case*q*(log_(n)+n)</code>)</h3><p>考虑找到第k小的子串，直接拿原串先构造后缀数组，统计一下第i个后缀有多少个不同的前缀num[i]（也就是在原串中有多少个不重复的子串），按sa排序后，这些连续出现的子串的字典序也是相同的，那么对num[i]求前缀和后就可以去二分一个位置，找到字典序第k小的子串出现的位置pos了(到这里解法二也要用)。这里找到的位置不一定是最靠左的(不理解可以看下面的题解分析)，所以还要在原串中找一下最左的位置，其实到了这里，直接向后，暴力遍历后面排名的串(不理解可以看下面的题解分析)，若串的最长的连续的height[i]&gt;=目标子串长度，则维护min(L,l)就可以直接得到最小的答案</p><h3 id="解法二-RMQ-O-case-n-log-n-q-log-n"><a href="#解法二-RMQ-O-case-n-log-n-q-log-n" class="headerlink" title="解法二 RMQ O(case*(n*log_(n)+q*log_(n)))"></a>解法二 RMQ O(<code>case*(n*log_(n)+q*log_(n))</code>)</h3><p>当然解法一在极限数组（例如10W个a）很可能会TLE的，所以我们来看更快的方法，以应对更高的要求，把平时的节俭(<del>抠门</del>)习惯在计算机上面发挥到极致</p><p>先像解法一前面部分一样确定了当前的位置pos，我们要做的就是在pos后面找个R，使得[pos,R]这个区间的height的最小值&gt;=目标子串的长度，那么找R可以直接在[POS,n]中二分，由于我们的height数组并不是有序的，所以我们不能使用lower_bound,但是要应对多次询问，我们不能像解法一一样暴力了，所以可以使用RMQ，在case开始的时候用n*log_(n)进行预处理，然后在多次查询中享受O(1)带来的极致体验(<del>节俭的生活就是如此地惬意</del>),最后我们在[pos,R]区间再RMQ一下就得到最后的答案了。注意这里求区间的RMQ和求答案的RMQ是查询的两个数组，要分别初始化…</p><h2 id="题解细节精讲QA"><a href="#题解细节精讲QA" class="headerlink" title="题解细节精讲QA"></a>题解细节精讲QA</h2><p><strong>Q1:</strong> 为什么后面只要找pos后的后缀中的前缀，不用往前找？而且为什么不同的串是那样求出来的？<br><strong>A:</strong></p><h3 id="首先是关于一个字符串有多少不同子串的问题，串由小到大排起序来应该是按照sa-i-的顺序排出来的产生的。"><a href="#首先是关于一个字符串有多少不同子串的问题，串由小到大排起序来应该是按照sa-i-的顺序排出来的产生的。" class="headerlink" title="首先是关于一个字符串有多少不同子串的问题，串由小到大排起序来应该是按照sa[i]的顺序排出来的产生的。"></a>首先是关于一个字符串有多少不同子串的问题，串由小到大排起序来应该是按照sa[i]的顺序排出来的产生的。</h3><p>比如abbacd，排序出来的后缀是这样的<br>rank值i—-对应的后缀sa[i]</p><p>　　1—-abbacd　　　第一个串产生的6个<strong>前缀</strong>都是新的子串(a,ab,abb……)</p><p>　　2—-acd　　　　　第二个串除了和上一个串的相同的前缀a(长度为1) 3-1=2 产生了2个子串</p><p>　　3—-bacd　　　　　4-0=4</p><p>　　4—-bbacd　　　　5-1=4</p><p>　　5—-cd　　　　　　2－0=0</p><p>　　6—-d　　　　　　　1－0=0</p><p>所以所有不同的前缀应该是(len-sa[i])-height[i]的和，即后缀串长(总串长减后缀起始位置)减去与上一个串的最长公共前缀，然后求和。<br>如果你不了解height数组—-&gt;建议看看<a href="https://www.wolfdan.cn/2019/08/20/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-15-100/">学习后缀数组的小建议</a></p><h3 id="然后我们可以观察到字串是按照排名过来的"><a href="#然后我们可以观察到字串是按照排名过来的" class="headerlink" title="然后我们可以观察到字串是按照排名过来的"></a>然后我们可以观察到字串是按照排名过来的</h3><p>a,ab,abb,abba,abbac,abbacd,ac,acd,b,ba,……</p><h3 id="并且也可以观察到第k大的不同的串如果在多个位置出现，那么一定是在后面的串中出现，比如k-3-即abb只能在后面的串出现-在abba，abbac-abbacd中出现-—-gt-所以只要在后面查找"><a href="#并且也可以观察到第k大的不同的串如果在多个位置出现，那么一定是在后面的串中出现，比如k-3-即abb只能在后面的串出现-在abba，abbac-abbacd中出现-—-gt-所以只要在后面查找" class="headerlink" title="并且也可以观察到第k大的不同的串如果在多个位置出现，那么一定是在后面的串中出现，比如k=3,即abb只能在后面的串出现(在abba，abbac,abbacd中出现)—&gt;所以只要在后面查找"></a>并且也可以观察到第k大的不同的串如果在多个位置出现，那么一定是在后面的串中出现，比如k=3,即abb只能在后面的串出现(在abba，abbac,abbacd中出现)—&gt;所以只要在后面查找</h3><p><strong>主要原因是所有的不同的串都是每个后缀的前缀</strong></p><p><strong>Q2:</strong> 为什么我们找到的第一个不是最靠左的呢？<br><strong>A:</strong><br>这里可以举一个反例就解决了，而且其实我们在题解二也举了这个例子(10w个a),我们这里为了分析方便就举例给的串是aaa，那么<br>排名rank　　　　　对应的后缀串<br>1　　　　　　　　　　a(rank[1]=2,即是后缀2)<br>2　　　　　　　　　　aa<br>3　　　　　　　　　　aaa<br><strong>因此我们就可以看到第一个找到的a不是位置上最左边的，反而是最右边的</strong></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>提交都是G++</p><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> sa[maxn],height[maxn],rank[maxn],t[maxn],t2[maxn],c[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> str[maxn];</span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line">LL sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_sa</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *x=t,*y=t2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)c[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)c[x[i]=str[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)sa[--c[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-k;i&lt;n;i++)y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(sa[i]&gt;=k)y[p++]=sa[i]-k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)c[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)c[x[y[i]]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)sa[--c[x[y[i]]]]=y[i];</span><br><span class="line">        swap(x,y);</span><br><span class="line">        x[sa[<span class="number">0</span>]]=<span class="number">0</span>;p=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            x[sa[i]]=(y[sa[i<span class="number">-1</span>]]==y[sa[i]]&amp;&amp;y[sa[i<span class="number">-1</span>]+k]==y[sa[i]+k]?p<span class="number">-1</span>:p++);</span><br><span class="line">        <span class="keyword">if</span>(p&gt;=n)<span class="keyword">break</span>;</span><br><span class="line">        m=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getheight</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)::rank[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k)k--;</span><br><span class="line">        <span class="keyword">int</span> j=sa[::rank[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(str[i+k]==str[j+k])k++;</span><br><span class="line">        height[::rank[i]]=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));</span><br><span class="line">    sum[<span class="number">1</span>]=n-sa[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+n-sa[i]-height[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    LL l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    process();</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        LL v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;v);</span><br><span class="line">        LL k=(l^r^v)+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/*获取有第k排名的不同字符的起始位置(sum见process函数)*/</span></span><br><span class="line">        <span class="keyword">int</span> pos=lower_bound(sum+<span class="number">1</span>,sum+<span class="number">1</span>+n,k)-sum;</span><br><span class="line">        <span class="comment">/*因为每个串都是  后缀 所以sum[pos]-(k-1)就能得到第k个起始的后缀长度！</span></span><br><span class="line"><span class="comment">        然后用n减去,就是k起始的位置！</span></span><br><span class="line"><span class="comment">        (字符串下标从0开始,可以用k=1,来模拟理解一遍) */</span></span><br><span class="line">        LL tl=sa[pos],tr=n-(sum[pos]-k+<span class="number">1</span>);</span><br><span class="line">        l=tl,r=tr;</span><br><span class="line">        <span class="keyword">int</span> len=tr-tl+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos+<span class="number">1</span>&lt;=n&amp;&amp;height[pos+<span class="number">1</span>]&gt;=len)&#123;</span><br><span class="line">            pos++;</span><br><span class="line">            tl=sa[pos],tr=tl+len<span class="number">-1</span>;</span><br><span class="line">            l=min(l,tl),r=min(r,tr);</span><br><span class="line">        &#125;</span><br><span class="line">        l++,r++;</span><br><span class="line">        <span class="keyword">if</span>(pos&gt;=n+<span class="number">1</span>)l=r=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">" "</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str)!=EOF)&#123;</span><br><span class="line">        n=<span class="built_in">strlen</span>(str);</span><br><span class="line">        build_sa(<span class="number">123</span>,n+<span class="number">1</span>);</span><br><span class="line">        getheight(n);</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">205000</span>;</span><br><span class="line"><span class="keyword">char</span> str[maxn];</span><br><span class="line"><span class="keyword">int</span> belong[maxn];</span><br><span class="line"><span class="keyword">int</span> s[maxn],rs[maxn];</span><br><span class="line"><span class="keyword">int</span> sa[maxn],t[maxn],t2[maxn],c[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,tt;</span><br><span class="line"><span class="keyword">int</span> rank[maxn],height[maxn];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">2</span>][maxn][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> LOG[maxn];</span><br><span class="line">ll num[maxn];</span><br><span class="line"><span class="keyword">int</span> len,l;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123; <span class="keyword">return</span> c-<span class="string">'a'</span>+<span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">fdx</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> <span class="keyword">char</span>(x<span class="number">-1</span>+<span class="string">'a'</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=n; i++) ::rank[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k) k--;</span><br><span class="line">        <span class="keyword">int</span> j=sa[::rank[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(s[i+k]==s[j+k]) k++;</span><br><span class="line">        height[::rank[i]]=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">int</span> i,*x=t,*y=t2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) c[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) c[x[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">      sa[--c[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n; k&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=n-k; i&lt;n; i++) y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) <span class="keyword">if</span> (sa[i]&gt;=k) y[p++]=sa[i]-k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;m; i++) c[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) c[x[y[i]]]++;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;m; i++) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) sa[--c[x[y[i]]]] = y[i];</span><br><span class="line">        swap(x,y);</span><br><span class="line">        p=<span class="number">1</span>;</span><br><span class="line">        x[sa[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">        x[sa[i]]=(y[sa[i<span class="number">-1</span>]]==y[sa[i]] &amp;&amp; y[sa[i<span class="number">-1</span>]+k]==y[sa[i]+k])? p<span class="number">-1</span> : p++;</span><br><span class="line">        <span class="keyword">if</span> (p&gt;=n) <span class="keyword">break</span>;</span><br><span class="line">        m=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RMQ_init</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> A[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) d[x][i][<span class="number">0</span>]=A[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; (<span class="number">1</span>&lt;&lt;j)&lt;=n; j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n; i++)</span><br><span class="line">            d[x][i][j]=min(d[x][i][j<span class="number">-1</span>],d[x][i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RMQ</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=LOG[R-L+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> min(d[x][L][k],d[x][R-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">105000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;(k+<span class="number">1</span>))&lt;=i) k++;</span><br><span class="line">        LOG[i]=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str))&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;l; i++) s[i]=idx(str[i]);</span><br><span class="line">        n=l;</span><br><span class="line">        s[n]=<span class="number">0</span>;</span><br><span class="line">        da(<span class="number">33</span>,n);</span><br><span class="line">        calheight(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) num[i]=n-sa[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) num[i]-=height[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) num[i]+=num[i<span class="number">-1</span>];</span><br><span class="line">        ll tot=num[n];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        ll la=<span class="number">0</span>,lb=<span class="number">0</span>;</span><br><span class="line">        ll k;</span><br><span class="line">        <span class="comment">/*d[0]存着height的rmq,d[1]存着sa的rmq*/</span></span><br><span class="line">        RMQ_init(<span class="number">0</span>,height);</span><br><span class="line">        RMQ_init(<span class="number">1</span>,sa);</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;k);</span><br><span class="line">            k=(k^la^lb)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (k&gt;=<span class="number">1</span> &amp;&amp; k&lt;=tot)&#123;</span><br><span class="line">                <span class="keyword">int</span> pos=lower_bound(num+<span class="number">1</span>,num+<span class="number">1</span>+n,k)-num;</span><br><span class="line">                <span class="comment">/*这个len求得很精致,k-(pos-1)位置起始的不同串的个数,</span></span><br><span class="line"><span class="comment">                这样就能得到k结束位置距离height结束位置的串长，加上height就是正好len*/</span></span><br><span class="line">                <span class="keyword">int</span> len=k-num[pos<span class="number">-1</span>]+height[pos];</span><br><span class="line">                <span class="keyword">int</span> l=pos+<span class="number">1</span>,r=n;</span><br><span class="line">                <span class="keyword">int</span> mid;</span><br><span class="line">                <span class="keyword">int</span> L=pos,R;</span><br><span class="line">                <span class="comment">/*二分右端点使得右边的最需最长公共字串是我们的k长串*/</span></span><br><span class="line">                <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                    mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (RMQ(<span class="number">0</span>,pos+<span class="number">1</span>,mid)&gt;=len) l=mid+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> r=mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*因为上面二分是mid+1,所以这里需要保险一下*/</span></span><br><span class="line">                <span class="keyword">if</span> (RMQ(<span class="number">0</span>,pos+<span class="number">1</span>,l)&gt;=len) R=l; <span class="keyword">else</span> R=l<span class="number">-1</span>;</span><br><span class="line">                <span class="comment">/*所有地方求最小的sa*/</span></span><br><span class="line">                la=RMQ(<span class="number">1</span>,L,R);</span><br><span class="line">                lb=la+len<span class="number">-1</span>;la++;lb++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>,la,lb);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> la=lb=<span class="number">0</span>,<span class="built_in">puts</span>(<span class="string">"0 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考:<br><a href="http://www.voidcn.com/article/p-xboamjdx-bg.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-xboamjdx-bg.html</a><br><a href="https://www.cnblogs.com/chanme/p/4000976.html" target="_blank" rel="noopener">https://www.cnblogs.com/chanme/p/4000976.html</a></p><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p>从明天起，做一个幸福的人(每天只玩半个小时的手机,让自己要么大屏高效,要么认真体验生活)</p><p>喂马、劈柴，周游世界</p><p>从明天起，关心粮食和蔬菜</p><p>我有一所房子，面朝大海，春暖花开</p><p>从明天起，和每一个亲人通信</p><p>告诉他们我的幸福</p><p>那幸福的闪电告诉我的</p><p>我将告诉每一个人</p><p>给每一条河每一座山取一个温暖的名字</p><p>陌生人，我也为你祝福</p><p>愿你有一个灿烂的前程</p><p>愿你有情人终成眷属</p><p>愿你在尘世获得幸福</p><p>我只愿面朝大海，春暖花开</p>]]></content>
    
    <summary type="html">
    
      HDU5008详解_后缀数组_二分_RMQ_算法日常 从明天起，做一个幸福的人(每天只玩半个小时的手机,让自己要么大屏高效,要么认真体验生活)
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="狼胆带你每天头铁一题" scheme="http://www.wolfdan.cn/tags/%E7%8B%BC%E8%83%86%E5%B8%A6%E4%BD%A0%E6%AF%8F%E5%A4%A9%E5%A4%B4%E9%93%81%E4%B8%80%E9%A2%98/"/>
    
      <category term="后缀数组" scheme="http://www.wolfdan.cn/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>后缀数组基础题poj1743详解_算法日常[16/100]</title>
    <link href="http://www.wolfdan.cn/2019/08/21/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-16-100/"/>
    <id>http://www.wolfdan.cn/2019/08/21/算法日常-16-100/</id>
    <published>2019-08-21T11:27:18.000Z</published>
    <updated>2019-08-22T13:46:53.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="POJ1743"><a href="#POJ1743" class="headerlink" title="POJ1743"></a>POJ1743</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://poj.org/problem?id=1743" target="_blank" rel="noopener">POJ上面</a></p><p><a href="https://vjudge.net/problem/POJ-1743" target="_blank" rel="noopener">VJ上面</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个字符串，求最长重复子串，这两个子串不能重叠</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>由于配置不是简单的匹配，有升降调的处理，但是我们无法确定升降的幅度，所以我们首先对输入的数组进行差值处理</li><li>可以发现同一个旋律的区段，它们的差值数组是相等的</li><li>因为之前我们处理成了差值，所以我们内卷了一个值，我们的差值相当于左右两个值，所以4个值代表着5个值</li><li><strong>所以只要找到最长相同串长的长度不小于4的差值区段即可</strong></li><li>由于需要求出最长的长度，考虑二分后验证可行性，二分区段的长度x，对差值数组求一遍后缀数组，将最长公共前缀大于等于x的划分成一组，如果存在一组的sa差值大于等于x+1(详见下面的重点解释)，那么就表示x长度的差值数组能够被找到。二分结束即可得到答案。</li></ul><h2 id="没学后缀数组？"><a href="#没学后缀数组？" class="headerlink" title="没学后缀数组？"></a>没学后缀数组？</h2><p><a href="https://www.wolfdan.cn/2019/08/20/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-15-100/">出门左转给你后缀数组学习合集</a></p><h2 id="思路重点"><a href="#思路重点" class="headerlink" title="思路重点"></a>思路重点</h2><h3 id="为什么c-1-ans-1"><a href="#为什么c-1-ans-1" class="headerlink" title="为什么c+1,ans+1"></a>为什么c+1,ans+1</h3><p>二分检查的时候，最长公共前缀是x,sa差值却要大于x+1:</p><p>因为之前我们处理成了差值，所以我们内卷了一个值，我们的差值相当于左右两个值，所以4个值代表着5个值.所以最长公共字串只要在4的时候就相当于5,然后sa的差值还是要相间隔5才行==&gt;这样真实的5个值也才是真的间隔5个值，所以同理答案也就是<code>c+1</code>(<code>ans+1</code>)</p><p>比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line"> 1 1 1 1 &apos; 1 1 1 1</span><br></pre></td></tr></table></figure></p><p>中间的<code>&#39;</code>也是1，但是代表的5,6，所以如果从这里开始和前面的4个1构成相同串的话，然后就重叠了一个，所以必须从<code>&#39;</code>后面1开始</p><p>我看了别的几个博主对于这题的分析没有谈及，这里，还有些代码没有考虑这里也能AC，说明数据都去卡时间了，没有卡下面这个特例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure></p><h3 id="为什么da函数的n值要加1而getheight函数不用"><a href="#为什么da函数的n值要加1而getheight函数不用" class="headerlink" title="为什么da函数的n值要加1而getheight函数不用"></a>为什么da函数的n值要加1而getheight函数不用</h3><p>da要加一个位置的字符,让它比所有的字符都小，所以这个字符起始的后缀是其本身，其排名为0(rank[n]=0,sa[0]=n)<br>然而calheight却不要…因为calheight直接从rank值为1(rank为0的地方是添加的最小字符)的地方记到n，根本不会用到<code>sa[0]</code>(排名为0的后缀)，重点还有<strong>for中用的是&lt;=</strong>..所以只要使用n.</p><p><code>for(i=1;i&lt;=n;i++) ::rank[sa[i]]=i;</code></p><h3 id="height分组为什么直接遍历下去分就好，不用吧height值相同的放在一起"><a href="#height分组为什么直接遍历下去分就好，不用吧height值相同的放在一起" class="headerlink" title="height分组为什么直接遍历下去分就好，不用吧height值相同的放在一起"></a>height分组为什么直接遍历下去分就好，不用吧height值相同的放在一起</h3><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/poj1743_height%E6%95%B0%E7%BB%84%E5%88%86%E7%BB%84%E5%88%86%E6%9E%90.png" alt></p><h2 id="AC代码1-推荐"><a href="#AC代码1-推荐" class="headerlink" title="AC代码1(推荐)"></a>AC代码1(推荐)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">int</span> sa[maxn],rank[maxn],height[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> str[maxn];</span><br><span class="line"><span class="keyword">int</span> wa[maxn],wb[maxn],wv[maxn],ws[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb,*t;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) ::ws[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) ::ws[x[i]=r[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) ::ws[i]+=::ws[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--::ws[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j*=<span class="number">2</span>,m=p)&#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;i++) y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(sa[i]&gt;=j) y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) ::ws[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) ::ws[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) ::ws[i]+=::ws[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--::ws[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(t=x,x=y,y=t,p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        x[sa[i]]=cmp(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*r为字符串数组,sa是后缀数组,n为字符串长度*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*用sa[]得到rank[]*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) ::rank[sa[i]]=i;</span><br><span class="line">    <span class="comment">/*j就是后缀i的前一名的后缀位置,然后如果前一个串之间有k,那么就从k--起步*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[::rank[i++]]=k)</span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[::rank[i]<span class="number">-1</span>];r[i+k]==r[j+k];k++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">为什么check里面的间隔是c+1:</span></span><br><span class="line"><span class="comment">    因为之前我们处理成了差值，所以我们内卷了一个值，</span></span><br><span class="line"><span class="comment">    我们的差值相当于左右两个值，所以4个值代表着5个值</span></span><br><span class="line"><span class="comment">    所以最长公共字串只要在4的时候就相当于5,然后sa的</span></span><br><span class="line"><span class="comment">    差值还是要相间隔5才行==&gt;这样真实的5个值也才是真的</span></span><br><span class="line"><span class="comment">    间隔5个值，所以同理答案也就是c+1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Max=sa[<span class="number">1</span>],Min=sa[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">/*这里的for是枚举的排名值，而height就是相邻排名的</span></span><br><span class="line"><span class="comment">        最长公共前缀,所以直接分组就行了*/</span></span><br><span class="line">        <span class="keyword">if</span>(height[i]&gt;=c) Max=max(Max,sa[i]),Min=min(Min,sa[i]);</span><br><span class="line">        <span class="keyword">else</span> Max=sa[i],Min=sa[i];</span><br><span class="line">        <span class="keyword">if</span>(Max-Min&gt;=c+<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;str[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) str[i]=str[i+<span class="number">1</span>]-str[i]+<span class="number">90</span>;</span><br><span class="line">        <span class="comment">/*因为转变差值了，所以少一个值*/</span></span><br><span class="line">        str[n<span class="number">-1</span>]=<span class="number">0</span>;n--;</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;=n-1;i++) cout&lt;&lt;str[i]&lt;&lt;" "; cout&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*da要加一个位置的字符,让它比所有的字符都小</span></span><br><span class="line"><span class="comment">        然而calheight却不要...因为calheight直接从rank只为1(rank为0的地方是添加的最小字符)</span></span><br><span class="line"><span class="comment">        的地方记到n(用的是&lt;=)..所以只要使用n.不需要n+1*/</span></span><br><span class="line">        da(str,sa,n+<span class="number">1</span>,<span class="number">178</span>);</span><br><span class="line">        calheight(str,sa,n);</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=n,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid)) l=mid+<span class="number">1</span>,ans=mid;</span><br><span class="line">            <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans&lt;<span class="number">4</span>) <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码2-RMQ版"><a href="#AC代码2-RMQ版" class="headerlink" title="AC代码2(RMQ版)"></a>AC代码2(RMQ版)</h2><p><strong>此AC代码为2019年8月22日做<a href="https://www.wolfdan.cn/2019/08/22/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-17-100/">HDU5008(因为那题最好还是用RMQ的后缀数组题)</a>的时候发现的</strong><br>不过这题用RMQ比较鸡肋，为什么? <strong>请看下面的代码头部注释</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">今天在第二次研究hdu5008的时候,发现好多题目都是没有用rmq的</span></span><br><span class="line"><span class="comment">但是总有大佬不满足于暴力裸sa就完事,于是都加了rmq,</span></span><br><span class="line"><span class="comment">然后我有点看不懂,就去逛oi-wiki,发现居然有不重叠重复两次</span></span><br><span class="line"><span class="comment">的串也可以用rmq，那不就是我昨天做的poj1743的更优做法吗？</span></span><br><span class="line"><span class="comment">是的，然后就在网上搜到了O(test*(nlogn+logn))的做法！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">之前的写法是O(test*nlogn)的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">但是实测发现RMQ版的反而还慢了100多ms!好像是因为他的check还是O(n)而非O(1)的</span></span><br><span class="line"><span class="comment">因为这里的check是我们自己去寻找一个左右区间，而非输入直接给我们左右区间，</span></span><br><span class="line"><span class="comment">所以这里的寻找的复杂度是O(n),所以RMQ无济于补</span></span><br><span class="line"><span class="comment">而且RMQ是nlog(n)的预处理...  所以当然会慢啊 ---&gt; 所以在更大一个量级的询问的时候再用比较好</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">----------------上面为简单分析-----下面为用途---------------</span></span><br><span class="line"><span class="comment">这里有rmq求排名区间内最远的sa位置差值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">21000</span>;</span><br><span class="line"><span class="keyword">int</span> dp1[maxn][<span class="number">20</span>],dp2[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> mm[maxn];</span><br><span class="line"><span class="keyword">int</span> str[maxn],tmp[maxn];</span><br><span class="line"><span class="keyword">int</span> wa[maxn],wb[maxn],wv[maxn],ws[maxn];</span><br><span class="line"><span class="keyword">int</span> sa[maxn],ranks[maxn],height[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb,*t;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) ws[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) ws[x[i]=r[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) ws[i]+=ws[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--ws[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j*=<span class="number">2</span>,m=p)&#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;i++) y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(sa[i]&gt;=j) y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) ws[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) ws[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) ws[i]+=ws[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--ws[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(t=x,x=y,y=t,p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            x[sa[i]]=cmp(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) ranks[sa[i]]=i;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k) k--;</span><br><span class="line">        j=sa[ranks[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(r[i+k]==r[j+k]) k++;</span><br><span class="line">        height[ranks[i]]=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initRMQ</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*mm其实是log,这里赋值为-1是为了后面mm[1]=0,也就是2^0=1*/</span></span><br><span class="line">    mm[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">/*(i&amp;(i-1))==0表示n==0或者是2的倍数*/</span></span><br><span class="line">        mm[i]=((i&amp;(i<span class="number">-1</span>))==<span class="number">0</span>)?mm[i<span class="number">-1</span>]+<span class="number">1</span>:mm[i<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">/*这里是预处理sa的rmq*/</span></span><br><span class="line">        dp1[i][<span class="number">0</span>]=dp2[i][<span class="number">0</span>]=sa[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=mm[n];j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)&#123;</span><br><span class="line">            dp1[i][j]=max(dp1[i][j<span class="number">-1</span>],dp1[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">            dp2[i][j]=min(dp2[i][j<span class="number">-1</span>],dp2[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmq</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=mm[y-x+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> max(dp1[x][k],dp1[y-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k])-min(dp2[x][k],dp2[y-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> len,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">1</span>,e=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(e&lt;N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(height[e+<span class="number">1</span>]&gt;=len<span class="number">-1</span>) e++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(rmq(s,e)&gt;=len) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            s=++e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N)&amp;&amp;N)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;str[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N<span class="number">-1</span>;i++)</span><br><span class="line">            tmp[i]=str[i+<span class="number">1</span>]-str[i]+<span class="number">90</span>;</span><br><span class="line">        tmp[N<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*这里没有N--,所以直接使用的N,而RMQ使用的N-1,height封锁掉N号位置*/</span></span><br><span class="line">        da(tmp,N,<span class="number">200</span>);</span><br><span class="line">        initRMQ(N<span class="number">-1</span>);</span><br><span class="line">        height[N]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>,right=N/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid,N)) left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;<span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p><strong>我不管你是什么垃圾，我只看结果</strong></p><p><strong>要达到结果，你应该知道怎么做</strong></p><p><strong>I know you have the urge to give up!</strong></p><p><strong>But you must keep faith!</strong></p><p><strong>You do make a difference!</strong></p>]]></content>
    
    <summary type="html">
    
      后缀数组基础题poj1743详解_算法日常 POJ1743 为什么c+1,ans+1 为什么da函数的n值要加1而getheight函数不用 height分组为什么直接遍历下去分就好，不用吧height值相同的放在一起
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="狼胆带你每天头铁一题" scheme="http://www.wolfdan.cn/tags/%E7%8B%BC%E8%83%86%E5%B8%A6%E4%BD%A0%E6%AF%8F%E5%A4%A9%E5%A4%B4%E9%93%81%E4%B8%80%E9%A2%98/"/>
    
      <category term="后缀数组" scheme="http://www.wolfdan.cn/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>后缀数组学习路径以及后缀数组板子推送_算法日常[15/100]</title>
    <link href="http://www.wolfdan.cn/2019/08/20/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-15-100/"/>
    <id>http://www.wolfdan.cn/2019/08/20/算法日常-15-100/</id>
    <published>2019-08-20T06:53:00.000Z</published>
    <updated>2019-08-22T01:09:01.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习后缀数组的小建议"><a href="#学习后缀数组的小建议" class="headerlink" title="学习后缀数组的小建议"></a>学习后缀数组的小建议</h1><h2 id="时刻分析数组含义"><a href="#时刻分析数组含义" class="headerlink" title="时刻分析数组含义"></a>时刻分析数组含义</h2><p>学习后缀数组的核心是时刻分析这到底是<strong>排名i的后缀位置</strong>还是<strong>后缀i的排名值</strong></p><p>一般的<code>SA[i]</code>代表着排名第i的后缀位置从哪里开始</p><p>然后<code>Rank[i]</code>代表着后缀i的排名</p><p><strong>后缀i</strong>就从下标i开始一直到字符串末尾的那个后缀<code>s.substr(i)</code></p><h2 id="演算"><a href="#演算" class="headerlink" title="演算"></a>演算</h2><p>脑子的内存是有限的，所以有时候想不出来，尽量使用草稿纸加以演算，这样才能更高效地学习后缀数组(<del>否则像小编这种脑子不怎么好使的，不演算之前看了一天都没看懂某两行代码</del>)</p><h1 id="后缀数组学习材料"><a href="#后缀数组学习材料" class="headerlink" title="后缀数组学习材料"></a>后缀数组学习材料</h1><p>当然小编也是一个初学者，所以暂时只能说出一些学习的小建议，让我写出来还是不太现实，不过小编可以给你们推荐一些学习的资料</p><h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><p><strong>下面这篇论文基本上网罗了后缀数组的方方面面，而且写得也十分详细，所以十分推荐</strong><br><a href="https://github.com/wolfdan666/BlogPic/tree/master/%E7%AE%97%E6%B3%95/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">后缀数组论文分享</a></p><h2 id="学习网址"><a href="#学习网址" class="headerlink" title="学习网址"></a>学习网址</h2><p>也挺详细的</p><p><a href="https://oi-wiki.org/string/sa/" target="_blank" rel="noopener">OI-wiki上的介绍</a></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://cn.vjudge.net/article/752?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">当然是先刷一手kuangbin专题</a></p><h2 id="板子整理推送-LTS"><a href="#板子整理推送-LTS" class="headerlink" title="板子整理推送(LTS)"></a>板子整理推送(LTS)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">板子声明 :</span></span><br><span class="line"><span class="comment">1. r从0开始,而非像oi-wiki中的从1开始</span></span><br><span class="line"><span class="comment">2. [build使用 n + 1 , calheight 使用 n ](https://www.wolfdan.cn/2019/08/21/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-16-100/)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> sa[maxn],wa[maxn],wb[maxn],wv[maxn],ws[maxn];</span><br><span class="line"><span class="comment">/*LCP:最长公共字串部分*/</span></span><br><span class="line"><span class="keyword">int</span> rank[maxn],height[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*r为字符串数组,sa是后缀数组,n为字符串长度,m为字符种类数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb,*t;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) ws[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) ws[x[i]=r[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) ws[i]+=ws[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--ws[x[i]]]=i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j*=<span class="number">2</span>,m=p)&#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;i++) y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(sa[i]&gt;=j) y[p++]=sa[i]-j;</span><br><span class="line">        <span class="comment">/*提取第一关键字*/</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) ws[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) ws[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) ws[i]+=ws[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--ws[wv[i]]]=y[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(t=x,x=y,y=t,p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        x[sa[i]]=(y[sa[i<span class="number">-1</span>]]==y[sa[i]]&amp;&amp;r[sa[i<span class="number">-1</span>]+j]==r[sa[i]+j])?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*r为字符串数组,sa是后缀数组,n为字符串长度*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*用sa[]得到rank[]*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) rank[sa[i]]=i;</span><br><span class="line">    <span class="comment">/*j就是后缀i的前一名的后缀位置,然后如果前一个串之间有k,那么就从k--起步*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[rank[i++]]=k)</span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];r[i+k]==r[j+k];k++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p><strong>愿回首岁月之时，你不会后悔</strong></p>]]></content>
    
    <summary type="html">
    
      后缀数组学习路径以及后缀数组板子推送_算法日常
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
</feed>
