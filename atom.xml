<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>狼胆</title>
  
  <subtitle>wolfdan&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wolfdan.cn/"/>
  <updated>2019-08-22T13:45:55.445Z</updated>
  <id>http://www.wolfdan.cn/</id>
  
  <author>
    <name>wolfdan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HDU5008详解_后缀数组_二分_RMQ_算法日常[17/100]</title>
    <link href="http://www.wolfdan.cn/2019/08/22/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-17-100/"/>
    <id>http://www.wolfdan.cn/2019/08/22/算法日常-17-100/</id>
    <published>2019-08-22T11:28:10.000Z</published>
    <updated>2019-08-22T13:45:55.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HDU5008"><a href="#HDU5008" class="headerlink" title="HDU5008"></a>HDU5008</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://vjudge.net/problem/HDU-5008" target="_blank" rel="noopener">VJ上面</a><br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5008" target="_blank" rel="noopener">hdu上面</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个串，q次查询里面第k大的字串，并且要求输出这个串最早出现的位置的左右下标值</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>Tips:看不懂题解的话可以看题解下面的题解小细节(<del>之所以在前面提示是因为小编经常看到一个东西自己想了半天，然后发现后面竟然有解释…所以感觉有点浪费时间，所以自己的博文应该防止自己陷入同样的坑</del>)</strong></p><h3 id="解法一-无RMQ-O-case-q-log-n-n"><a href="#解法一-无RMQ-O-case-q-log-n-n" class="headerlink" title="解法一 无RMQ O(case*q*(log_(n)+n))"></a>解法一 无RMQ O(<code>case*q*(log_(n)+n)</code>)</h3><p>考虑找到第k小的子串，直接拿原串先构造后缀数组，统计一下第i个后缀有多少个不同的前缀num[i]（也就是在原串中有多少个不重复的子串），按sa排序后，这些连续出现的子串的字典序也是相同的，那么对num[i]求前缀和后就可以去二分一个位置，找到字典序第k小的子串出现的位置pos了(到这里解法二也要用)。这里找到的位置不一定是最靠左的(不理解可以看下面的题解分析)，所以还要在原串中找一下最左的位置，其实到了这里，直接向后，暴力遍历后面排名的串(不理解可以看下面的题解分析)，若串的最长的连续的height[i]&gt;=目标子串长度，则维护min(L,l)就可以直接得到最小的答案</p><h3 id="解法二-RMQ-O-case-n-log-n-q-log-n"><a href="#解法二-RMQ-O-case-n-log-n-q-log-n" class="headerlink" title="解法二 RMQ O(case(n*log_(n)+q*log_(n)))"></a>解法二 RMQ O(<code>case(n*log_(n)+q*log_(n))</code>)</h3><p>当然解法一在极限数组（例如10W个a）很可能会TLE的，所以我们来看更快的方法，以应对更高的要求，把平时的节俭(<del>抠门</del>)习惯在计算机上面发挥到极致</p><p>先像解法一前面部分一样确定了当前的位置pos，我们要做的就是在pos后面找个R，使得[pos,R]这个区间的height的最小值&gt;=目标子串的长度，那么找R可以直接在[POS,n]中二分，由于我们的height数组并不是有序的，所以我们不能使用lower_bound,但是要应对多次询问，我们不能像解法一一样暴力了，所以可以使用RMQ，在case开始的时候用n*log_(n)进行预处理，然后在多次查询中享受O(1)带来的极致体验(<del>节俭的生活就是如此地惬意</del>),最后我们在[pos,R]区间再RMQ一下就得到最后的答案了。注意这里求区间的RMQ和求答案的RMQ是查询的两个数组，要分别初始化…</p><h2 id="题解细节精讲QA"><a href="#题解细节精讲QA" class="headerlink" title="题解细节精讲QA"></a>题解细节精讲QA</h2><p>Q1: 为什么后面只要找pos后的后缀中的前缀，不用往前找？而且为什么不同的串是那样求出来的？<br>A:</p><ol><li>首先是关于一个字符串有多少不同子串的问题，串由小到大排起序来应该是按照sa[i]的顺序排出来的产生的。</li></ol><p>比如abbacd，排序出来的后缀是这样的<br>rank值i—-对应的后缀sa[i]</p><p>　　1—-abbacd　　　第一个串产生的6个<strong>前缀</strong>都是新的子串(a,ab,abb……)</p><p>　　2—-acd　　　　　第二个串除了和上一个串的相同的前缀a(长度为1) 3-1=2 产生了2个子串</p><p>　　3—-bacd　　　　　4-0=4</p><p>　　4—-bbacd　　　　5-1=4</p><p>　　5—-cd　　　　　　2－0=0</p><p>　　6—-d　　　　　　　1－0=0</p><p>所以所有不同的前缀应该是(len-sa[i])-height[i]的和，即后缀串长(总串长减后缀起始位置)减去与上一个串的最长公共前缀，然后求和。<br>如果你不了解height数组—-&gt;建议看看<a href="https://www.wolfdan.cn/2019/08/20/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-15-100/">学习后缀数组的小建议</a></p><ol><li>然后我们可以观察到字串是按照排名过来的<br>a,ab,abb,abba,abbac,abbacd,ac,acd,b,ba,……</li><li>并且也可以观察到第k大的不同的串如果在多个位置出现，那么一定是在后面的串中出现，比如k=3,即abb只能在后面的串出现(在abba，abbac,abbacd中出现)—&gt;所以只要在后面查找<br><strong>主要原因是所有的不同的串都是每个后缀的前缀</strong></li></ol><p>Q2：为什么我们找到的第一个不是最靠左的呢？<br>A:<br>这里可以举一个反例就解决了，而且其实我们在题解二也举了这个例子(10w个a),我们这里为了分析方便就举例给的串是aaa，那么<br>排名rank　　　　　对应的后缀串<br>1　　　　　　　　　　a(rank[1]=2,即是后缀2)<br>2　　　　　　　　　　aa<br>3　　　　　　　　　　aaa<br><strong>因此我们就可以看到第一个找到的a不是位置上最左边的，反而是最右边的</strong></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>提交都是G++</p><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> sa[maxn],height[maxn],rank[maxn],t[maxn],t2[maxn],c[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> str[maxn];</span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line">LL sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_sa</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *x=t,*y=t2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)c[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)c[x[i]=str[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)sa[--c[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-k;i&lt;n;i++)y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(sa[i]&gt;=k)y[p++]=sa[i]-k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)c[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)c[x[y[i]]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)sa[--c[x[y[i]]]]=y[i];</span><br><span class="line">        swap(x,y);</span><br><span class="line">        x[sa[<span class="number">0</span>]]=<span class="number">0</span>;p=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            x[sa[i]]=(y[sa[i<span class="number">-1</span>]]==y[sa[i]]&amp;&amp;y[sa[i<span class="number">-1</span>]+k]==y[sa[i]+k]?p<span class="number">-1</span>:p++);</span><br><span class="line">        <span class="keyword">if</span>(p&gt;=n)<span class="keyword">break</span>;</span><br><span class="line">        m=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getheight</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)::rank[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k)k--;</span><br><span class="line">        <span class="keyword">int</span> j=sa[::rank[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(str[i+k]==str[j+k])k++;</span><br><span class="line">        height[::rank[i]]=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));</span><br><span class="line">    sum[<span class="number">1</span>]=n-sa[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+n-sa[i]-height[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    LL l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    process();</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        LL v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;v);</span><br><span class="line">        LL k=(l^r^v)+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/*获取有第k排名的不同字符的起始位置(sum见process函数)*/</span></span><br><span class="line">        <span class="keyword">int</span> pos=lower_bound(sum+<span class="number">1</span>,sum+<span class="number">1</span>+n,k)-sum;</span><br><span class="line">        <span class="comment">/*因为每个串都是  后缀 所以sum[pos]-(k-1)就能得到第k个起始的后缀长度！</span></span><br><span class="line"><span class="comment">        然后用n减去,就是k起始的位置！</span></span><br><span class="line"><span class="comment">        (字符串下标从0开始,可以用k=1,来模拟理解一遍) */</span></span><br><span class="line">        LL tl=sa[pos],tr=n-(sum[pos]-k+<span class="number">1</span>);</span><br><span class="line">        l=tl,r=tr;</span><br><span class="line">        <span class="keyword">int</span> len=tr-tl+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos+<span class="number">1</span>&lt;=n&amp;&amp;height[pos+<span class="number">1</span>]&gt;=len)&#123;</span><br><span class="line">            pos++;</span><br><span class="line">            tl=sa[pos],tr=tl+len<span class="number">-1</span>;</span><br><span class="line">            l=min(l,tl),r=min(r,tr);</span><br><span class="line">        &#125;</span><br><span class="line">        l++,r++;</span><br><span class="line">        <span class="keyword">if</span>(pos&gt;=n+<span class="number">1</span>)l=r=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">" "</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str)!=EOF)&#123;</span><br><span class="line">        n=<span class="built_in">strlen</span>(str);</span><br><span class="line">        build_sa(<span class="number">123</span>,n+<span class="number">1</span>);</span><br><span class="line">        getheight(n);</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">205000</span>;</span><br><span class="line"><span class="keyword">char</span> str[maxn];</span><br><span class="line"><span class="keyword">int</span> belong[maxn];</span><br><span class="line"><span class="keyword">int</span> s[maxn],rs[maxn];</span><br><span class="line"><span class="keyword">int</span> sa[maxn],t[maxn],t2[maxn],c[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,tt;</span><br><span class="line"><span class="keyword">int</span> rank[maxn],height[maxn];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">2</span>][maxn][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> LOG[maxn];</span><br><span class="line">ll num[maxn];</span><br><span class="line"><span class="keyword">int</span> len,l;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123; <span class="keyword">return</span> c-<span class="string">'a'</span>+<span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">fdx</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> <span class="keyword">char</span>(x<span class="number">-1</span>+<span class="string">'a'</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=n; i++) ::rank[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k) k--;</span><br><span class="line">        <span class="keyword">int</span> j=sa[::rank[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(s[i+k]==s[j+k]) k++;</span><br><span class="line">        height[::rank[i]]=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">int</span> i,*x=t,*y=t2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) c[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) c[x[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">      sa[--c[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n; k&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=n-k; i&lt;n; i++) y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) <span class="keyword">if</span> (sa[i]&gt;=k) y[p++]=sa[i]-k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;m; i++) c[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) c[x[y[i]]]++;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;m; i++) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) sa[--c[x[y[i]]]] = y[i];</span><br><span class="line">        swap(x,y);</span><br><span class="line">        p=<span class="number">1</span>;</span><br><span class="line">        x[sa[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">        x[sa[i]]=(y[sa[i<span class="number">-1</span>]]==y[sa[i]] &amp;&amp; y[sa[i<span class="number">-1</span>]+k]==y[sa[i]+k])? p<span class="number">-1</span> : p++;</span><br><span class="line">        <span class="keyword">if</span> (p&gt;=n) <span class="keyword">break</span>;</span><br><span class="line">        m=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RMQ_init</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> A[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) d[x][i][<span class="number">0</span>]=A[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; (<span class="number">1</span>&lt;&lt;j)&lt;=n; j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n; i++)</span><br><span class="line">            d[x][i][j]=min(d[x][i][j<span class="number">-1</span>],d[x][i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RMQ</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=LOG[R-L+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> min(d[x][L][k],d[x][R-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">105000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;(k+<span class="number">1</span>))&lt;=i) k++;</span><br><span class="line">        LOG[i]=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str))&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;l; i++) s[i]=idx(str[i]);</span><br><span class="line">        n=l;</span><br><span class="line">        s[n]=<span class="number">0</span>;</span><br><span class="line">        da(<span class="number">33</span>,n);</span><br><span class="line">        calheight(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) num[i]=n-sa[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) num[i]-=height[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) num[i]+=num[i<span class="number">-1</span>];</span><br><span class="line">        ll tot=num[n];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        ll la=<span class="number">0</span>,lb=<span class="number">0</span>;</span><br><span class="line">        ll k;</span><br><span class="line">        <span class="comment">/*d[0]存着height的rmq,d[1]存着sa的rmq*/</span></span><br><span class="line">        RMQ_init(<span class="number">0</span>,height);</span><br><span class="line">        RMQ_init(<span class="number">1</span>,sa);</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;k);</span><br><span class="line">            k=(k^la^lb)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (k&gt;=<span class="number">1</span> &amp;&amp; k&lt;=tot)&#123;</span><br><span class="line">                <span class="keyword">int</span> pos=lower_bound(num+<span class="number">1</span>,num+<span class="number">1</span>+n,k)-num;</span><br><span class="line">                <span class="comment">/*这个len求得很精致,k-(pos-1)位置起始的不同串的个数,</span></span><br><span class="line"><span class="comment">                这样就能得到k结束位置距离height结束位置的串长，加上height就是正好len*/</span></span><br><span class="line">                <span class="keyword">int</span> len=k-num[pos<span class="number">-1</span>]+height[pos];</span><br><span class="line">                <span class="keyword">int</span> l=pos+<span class="number">1</span>,r=n;</span><br><span class="line">                <span class="keyword">int</span> mid;</span><br><span class="line">                <span class="keyword">int</span> L=pos,R;</span><br><span class="line">                <span class="comment">/*二分右端点使得右边的最需最长公共字串是我们的k长串*/</span></span><br><span class="line">                <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                    mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (RMQ(<span class="number">0</span>,pos+<span class="number">1</span>,mid)&gt;=len) l=mid+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> r=mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*因为上面二分是mid+1,所以这里需要保险一下*/</span></span><br><span class="line">                <span class="keyword">if</span> (RMQ(<span class="number">0</span>,pos+<span class="number">1</span>,l)&gt;=len) R=l; <span class="keyword">else</span> R=l<span class="number">-1</span>;</span><br><span class="line">                <span class="comment">/*所有地方求最小的sa*/</span></span><br><span class="line">                la=RMQ(<span class="number">1</span>,L,R);</span><br><span class="line">                lb=la+len<span class="number">-1</span>;la++;lb++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>,la,lb);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> la=lb=<span class="number">0</span>,<span class="built_in">puts</span>(<span class="string">"0 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考:<br><a href="http://www.voidcn.com/article/p-xboamjdx-bg.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-xboamjdx-bg.html</a><br><a href="https://www.cnblogs.com/chanme/p/4000976.html" target="_blank" rel="noopener">https://www.cnblogs.com/chanme/p/4000976.html</a></p><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p>从明天起，做一个幸福的人(每天只玩半个小时的手机,让自己要么大屏高效,要么认真体验生活)</p><p>喂马、劈柴，周游世界</p><p>从明天起，关心粮食和蔬菜</p><p>我有一所房子，面朝大海，春暖花开</p><p>从明天起，和每一个亲人通信</p><p>告诉他们我的幸福</p><p>那幸福的闪电告诉我的</p><p>我将告诉每一个人</p><p>给每一条河每一座山取一个温暖的名字</p><p>陌生人，我也为你祝福</p><p>愿你有一个灿烂的前程</p><p>愿你有情人终成眷属</p><p>愿你在尘世获得幸福</p><p>我只愿面朝大海，春暖花开</p>]]></content>
    
    <summary type="html">
    
      HDU5008详解_后缀数组_二分_RMQ_算法日常 从明天起，做一个幸福的人(每天只玩半个小时的手机,让自己要么大屏高效,要么认真体验生活)
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="后缀数组" scheme="http://www.wolfdan.cn/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
      <category term="狼胆带你每天头铁一题" scheme="http://www.wolfdan.cn/tags/%E7%8B%BC%E8%83%86%E5%B8%A6%E4%BD%A0%E6%AF%8F%E5%A4%A9%E5%A4%B4%E9%93%81%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>后缀数组基础题poj1743详解_算法日常[16/100]</title>
    <link href="http://www.wolfdan.cn/2019/08/21/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-16-100/"/>
    <id>http://www.wolfdan.cn/2019/08/21/算法日常-16-100/</id>
    <published>2019-08-21T11:27:18.000Z</published>
    <updated>2019-08-22T13:34:23.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="POJ1743"><a href="#POJ1743" class="headerlink" title="POJ1743"></a>POJ1743</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://poj.org/problem?id=1743" target="_blank" rel="noopener">POJ上面</a></p><p><a href="https://vjudge.net/problem/POJ-1743" target="_blank" rel="noopener">VJ上面</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个字符串，求最长重复子串，这两个子串不能重叠</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>由于配置不是简单的匹配，有升降调的处理，但是我们无法确定升降的幅度，所以我们首先对输入的数组进行差值处理</li><li>可以发现同一个旋律的区段，它们的差值数组是相等的</li><li>因为之前我们处理成了差值，所以我们内卷了一个值，我们的差值相当于左右两个值，所以4个值代表着5个值</li><li><strong>所以只要找到最长相同串长的长度不小于4的差值区段即可</strong></li><li>由于需要求出最长的长度，考虑二分后验证可行性，二分区段的长度x，对差值数组求一遍后缀数组，将最长公共前缀大于等于x的划分成一组，如果存在一组的sa差值大于等于x+1(详见下面的重点解释)，那么就表示x长度的差值数组能够被找到。二分结束即可得到答案。</li></ul><h2 id="没学后缀数组？"><a href="#没学后缀数组？" class="headerlink" title="没学后缀数组？"></a>没学后缀数组？</h2><p><a href="https://www.wolfdan.cn/2019/08/20/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-15-100/">出门左转给你后缀数组学习合集</a></p><h2 id="思路重点"><a href="#思路重点" class="headerlink" title="思路重点"></a>思路重点</h2><h3 id="为什么c-1-ans-1"><a href="#为什么c-1-ans-1" class="headerlink" title="为什么c+1,ans+1"></a>为什么c+1,ans+1</h3><p>二分检查的时候，最长公共前缀是x,sa差值却要大于x+1:</p><p>因为之前我们处理成了差值，所以我们内卷了一个值，我们的差值相当于左右两个值，所以4个值代表着5个值.所以最长公共字串只要在4的时候就相当于5,然后sa的差值还是要相间隔5才行==&gt;这样真实的5个值也才是真的间隔5个值，所以同理答案也就是<code>c+1</code>(<code>ans+1</code>)</p><p>比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line"> 1 1 1 1 &apos; 1 1 1 1</span><br></pre></td></tr></table></figure></p><p>中间的<code>&#39;</code>也是1，但是代表的5,6，所以如果从这里开始和前面的4个1构成相同串的话，然后就重叠了一个，所以必须从<code>&#39;</code>后面1开始</p><p>我看了别的几个博主对于这题的分析没有谈及，这里，还有些代码没有考虑这里也能AC，说明数据都去卡时间了，没有卡下面这个特例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure></p><h3 id="为什么da函数的n值要加1而getheight函数不用"><a href="#为什么da函数的n值要加1而getheight函数不用" class="headerlink" title="为什么da函数的n值要加1而getheight函数不用"></a>为什么da函数的n值要加1而getheight函数不用</h3><p>da要加一个位置的字符,让它比所有的字符都小，所以这个字符起始的后缀是其本身，其排名为0(rank[n]=0,sa[0]=n)<br>然而calheight却不要…因为calheight直接从rank值为1(rank为0的地方是添加的最小字符)的地方记到n，根本不会用到<code>sa[0]</code>(排名为0的后缀)，重点还有<strong>for中用的是&lt;=</strong>..所以只要使用n.</p><p><code>for(i=1;i&lt;=n;i++) ::rank[sa[i]]=i;</code></p><h3 id="height分组为什么直接遍历下去分就好，不用吧height值相同的放在一起"><a href="#height分组为什么直接遍历下去分就好，不用吧height值相同的放在一起" class="headerlink" title="height分组为什么直接遍历下去分就好，不用吧height值相同的放在一起"></a>height分组为什么直接遍历下去分就好，不用吧height值相同的放在一起</h3><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/poj1743_height%E6%95%B0%E7%BB%84%E5%88%86%E7%BB%84%E5%88%86%E6%9E%90.png" alt></p><h2 id="AC代码1-推荐"><a href="#AC代码1-推荐" class="headerlink" title="AC代码1(推荐)"></a>AC代码1(推荐)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">int</span> sa[maxn],rank[maxn],height[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> str[maxn];</span><br><span class="line"><span class="keyword">int</span> wa[maxn],wb[maxn],wv[maxn],ws[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb,*t;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) ::ws[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) ::ws[x[i]=r[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) ::ws[i]+=::ws[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--::ws[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j*=<span class="number">2</span>,m=p)&#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;i++) y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(sa[i]&gt;=j) y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) ::ws[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) ::ws[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) ::ws[i]+=::ws[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--::ws[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(t=x,x=y,y=t,p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        x[sa[i]]=cmp(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*r为字符串数组,sa是后缀数组,n为字符串长度*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*用sa[]得到rank[]*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) ::rank[sa[i]]=i;</span><br><span class="line">    <span class="comment">/*j就是后缀i的前一名的后缀位置,然后如果前一个串之间有k,那么就从k--起步*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[::rank[i++]]=k)</span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[::rank[i]<span class="number">-1</span>];r[i+k]==r[j+k];k++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">为什么check里面的间隔是c+1:</span></span><br><span class="line"><span class="comment">    因为之前我们处理成了差值，所以我们内卷了一个值，</span></span><br><span class="line"><span class="comment">    我们的差值相当于左右两个值，所以4个值代表着5个值</span></span><br><span class="line"><span class="comment">    所以最长公共字串只要在4的时候就相当于5,然后sa的</span></span><br><span class="line"><span class="comment">    差值还是要相间隔5才行==&gt;这样真实的5个值也才是真的</span></span><br><span class="line"><span class="comment">    间隔5个值，所以同理答案也就是c+1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Max=sa[<span class="number">1</span>],Min=sa[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">/*这里的for是枚举的排名值，而height就是相邻排名的</span></span><br><span class="line"><span class="comment">        最长公共前缀,所以直接分组就行了*/</span></span><br><span class="line">        <span class="keyword">if</span>(height[i]&gt;=c) Max=max(Max,sa[i]),Min=min(Min,sa[i]);</span><br><span class="line">        <span class="keyword">else</span> Max=sa[i],Min=sa[i];</span><br><span class="line">        <span class="keyword">if</span>(Max-Min&gt;=c+<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;str[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) str[i]=str[i+<span class="number">1</span>]-str[i]+<span class="number">90</span>;</span><br><span class="line">        <span class="comment">/*因为转变差值了，所以少一个值*/</span></span><br><span class="line">        str[n<span class="number">-1</span>]=<span class="number">0</span>;n--;</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;=n-1;i++) cout&lt;&lt;str[i]&lt;&lt;" "; cout&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*da要加一个位置的字符,让它比所有的字符都小</span></span><br><span class="line"><span class="comment">        然而calheight却不要...因为calheight直接从rank只为1(rank为0的地方是添加的最小字符)</span></span><br><span class="line"><span class="comment">        的地方记到n(用的是&lt;=)..所以只要使用n.不需要n+1*/</span></span><br><span class="line">        da(str,sa,n+<span class="number">1</span>,<span class="number">178</span>);</span><br><span class="line">        calheight(str,sa,n);</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=n,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid)) l=mid+<span class="number">1</span>,ans=mid;</span><br><span class="line">            <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans&lt;<span class="number">4</span>) <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码2-RMQ版"><a href="#AC代码2-RMQ版" class="headerlink" title="AC代码2(RMQ版)"></a>AC代码2(RMQ版)</h2><p><strong>此AC代码为2019年8月22日做<a href>HDU5008(因为那题最好还是用RMQ的后缀数组题)</a>的时候发现的</strong><br>不过这题用RMQ比较鸡肋，为什么? <strong>请看下面的代码头部注释</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">今天在第二次研究hdu5008的时候,发现好多题目都是没有用rmq的</span></span><br><span class="line"><span class="comment">但是总有大佬不满足于暴力裸sa就完事,于是都加了rmq,</span></span><br><span class="line"><span class="comment">然后我有点看不懂,就去逛oi-wiki,发现居然有不重叠重复两次</span></span><br><span class="line"><span class="comment">的串也可以用rmq，那不就是我昨天做的poj1743的更优做法吗？</span></span><br><span class="line"><span class="comment">是的，然后就在网上搜到了O(test*(nlogn+logn))的做法！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">之前的写法是O(test*nlogn)的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">但是实测发现RMQ版的反而还慢了100多ms!好像是因为他的check还是O(n)而非O(1)的</span></span><br><span class="line"><span class="comment">因为这里的check是我们自己去寻找一个左右区间，而非输入直接给我们左右区间，</span></span><br><span class="line"><span class="comment">所以这里的寻找的复杂度是O(n),所以RMQ无济于补</span></span><br><span class="line"><span class="comment">而且RMQ是nlog(n)的预处理...  所以当然会慢啊 ---&gt; 所以在更大一个量级的询问的时候再用比较好</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">----------------上面为简单分析-----下面为用途---------------</span></span><br><span class="line"><span class="comment">这里有rmq求排名区间内最远的sa位置差值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">21000</span>;</span><br><span class="line"><span class="keyword">int</span> dp1[maxn][<span class="number">20</span>],dp2[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> mm[maxn];</span><br><span class="line"><span class="keyword">int</span> str[maxn],tmp[maxn];</span><br><span class="line"><span class="keyword">int</span> wa[maxn],wb[maxn],wv[maxn],ws[maxn];</span><br><span class="line"><span class="keyword">int</span> sa[maxn],ranks[maxn],height[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb,*t;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) ws[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) ws[x[i]=r[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) ws[i]+=ws[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--ws[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j*=<span class="number">2</span>,m=p)&#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;i++) y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(sa[i]&gt;=j) y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) ws[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) ws[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) ws[i]+=ws[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--ws[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(t=x,x=y,y=t,p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            x[sa[i]]=cmp(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) ranks[sa[i]]=i;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k) k--;</span><br><span class="line">        j=sa[ranks[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(r[i+k]==r[j+k]) k++;</span><br><span class="line">        height[ranks[i]]=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initRMQ</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*mm其实是log,这里赋值为-1是为了后面mm[1]=0,也就是2^0=1*/</span></span><br><span class="line">    mm[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">/*(i&amp;(i-1))==0表示n==0或者是2的倍数*/</span></span><br><span class="line">        mm[i]=((i&amp;(i<span class="number">-1</span>))==<span class="number">0</span>)?mm[i<span class="number">-1</span>]+<span class="number">1</span>:mm[i<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">/*这里是预处理sa的rmq*/</span></span><br><span class="line">        dp1[i][<span class="number">0</span>]=dp2[i][<span class="number">0</span>]=sa[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=mm[n];j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)&#123;</span><br><span class="line">            dp1[i][j]=max(dp1[i][j<span class="number">-1</span>],dp1[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">            dp2[i][j]=min(dp2[i][j<span class="number">-1</span>],dp2[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmq</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=mm[y-x+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> max(dp1[x][k],dp1[y-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k])-min(dp2[x][k],dp2[y-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> len,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">1</span>,e=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(e&lt;N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(height[e+<span class="number">1</span>]&gt;=len<span class="number">-1</span>) e++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(rmq(s,e)&gt;=len) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            s=++e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N)&amp;&amp;N)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;str[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N<span class="number">-1</span>;i++)</span><br><span class="line">            tmp[i]=str[i+<span class="number">1</span>]-str[i]+<span class="number">90</span>;</span><br><span class="line">        tmp[N<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*这里没有N--,所以直接使用的N,而RMQ使用的N-1,height封锁掉N号位置*/</span></span><br><span class="line">        da(tmp,N,<span class="number">200</span>);</span><br><span class="line">        initRMQ(N<span class="number">-1</span>);</span><br><span class="line">        height[N]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>,right=N/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid,N)) left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;<span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p><strong>我不管你是什么垃圾，我只看结果</strong></p><p><strong>要达到结果，你应该知道怎么做</strong></p><p><strong>I know you have the urge to give up!</strong></p><p><strong>But you must keep faith!</strong></p><p><strong>You do make a difference!</strong></p>]]></content>
    
    <summary type="html">
    
      后缀数组基础题poj1743详解_算法日常 POJ1743 为什么c+1,ans+1 为什么da函数的n值要加1而getheight函数不用 height分组为什么直接遍历下去分就好，不用吧height值相同的放在一起
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="后缀数组" scheme="http://www.wolfdan.cn/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
      <category term="狼胆带你每天头铁一题" scheme="http://www.wolfdan.cn/tags/%E7%8B%BC%E8%83%86%E5%B8%A6%E4%BD%A0%E6%AF%8F%E5%A4%A9%E5%A4%B4%E9%93%81%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>后缀数组学习路径以及后缀数组板子推送_算法日常[15/100]</title>
    <link href="http://www.wolfdan.cn/2019/08/20/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-15-100/"/>
    <id>http://www.wolfdan.cn/2019/08/20/算法日常-15-100/</id>
    <published>2019-08-20T06:53:00.000Z</published>
    <updated>2019-08-22T01:09:01.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习后缀数组的小建议"><a href="#学习后缀数组的小建议" class="headerlink" title="学习后缀数组的小建议"></a>学习后缀数组的小建议</h1><h2 id="时刻分析数组含义"><a href="#时刻分析数组含义" class="headerlink" title="时刻分析数组含义"></a>时刻分析数组含义</h2><p>学习后缀数组的核心是时刻分析这到底是<strong>排名i的后缀位置</strong>还是<strong>后缀i的排名值</strong></p><p>一般的<code>SA[i]</code>代表着排名第i的后缀位置从哪里开始</p><p>然后<code>Rank[i]</code>代表着后缀i的排名</p><p><strong>后缀i</strong>就从下标i开始一直到字符串末尾的那个后缀<code>s.substr(i)</code></p><h2 id="演算"><a href="#演算" class="headerlink" title="演算"></a>演算</h2><p>脑子的内存是有限的，所以有时候想不出来，尽量使用草稿纸加以演算，这样才能更高效地学习后缀数组(<del>否则像小编这种脑子不怎么好使的，不演算之前看了一天都没看懂某两行代码</del>)</p><h1 id="后缀数组学习材料"><a href="#后缀数组学习材料" class="headerlink" title="后缀数组学习材料"></a>后缀数组学习材料</h1><p>当然小编也是一个初学者，所以暂时只能说出一些学习的小建议，让我写出来还是不太现实，不过小编可以给你们推荐一些学习的资料</p><h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><p><strong>下面这篇论文基本上网罗了后缀数组的方方面面，而且写得也十分详细，所以十分推荐</strong><br><a href="https://github.com/wolfdan666/BlogPic/tree/master/%E7%AE%97%E6%B3%95/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">后缀数组论文分享</a></p><h2 id="学习网址"><a href="#学习网址" class="headerlink" title="学习网址"></a>学习网址</h2><p>也挺详细的</p><p><a href="https://oi-wiki.org/string/sa/" target="_blank" rel="noopener">OI-wiki上的介绍</a></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://cn.vjudge.net/article/752?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">当然是先刷一手kuangbin专题</a></p><h2 id="板子整理推送-LTS"><a href="#板子整理推送-LTS" class="headerlink" title="板子整理推送(LTS)"></a>板子整理推送(LTS)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">板子声明 :</span></span><br><span class="line"><span class="comment">1. r从0开始,而非像oi-wiki中的从1开始</span></span><br><span class="line"><span class="comment">2. [build使用 n + 1 , calheight 使用 n ](https://www.wolfdan.cn/2019/08/21/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-16-100/)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> sa[maxn],wa[maxn],wb[maxn],wv[maxn],ws[maxn];</span><br><span class="line"><span class="comment">/*LCP:最长公共字串部分*/</span></span><br><span class="line"><span class="keyword">int</span> rank[maxn],height[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*r为字符串数组,sa是后缀数组,n为字符串长度,m为字符种类数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb,*t;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) ws[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) ws[x[i]=r[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) ws[i]+=ws[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--ws[x[i]]]=i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j*=<span class="number">2</span>,m=p)&#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;i++) y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(sa[i]&gt;=j) y[p++]=sa[i]-j;</span><br><span class="line">        <span class="comment">/*提取第一关键字*/</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) ws[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) ws[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) ws[i]+=ws[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--ws[wv[i]]]=y[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(t=x,x=y,y=t,p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        x[sa[i]]=(y[sa[i<span class="number">-1</span>]]==y[sa[i]]&amp;&amp;r[sa[i<span class="number">-1</span>]+j]==r[sa[i]+j])?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*r为字符串数组,sa是后缀数组,n为字符串长度*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*用sa[]得到rank[]*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) rank[sa[i]]=i;</span><br><span class="line">    <span class="comment">/*j就是后缀i的前一名的后缀位置,然后如果前一个串之间有k,那么就从k--起步*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[rank[i++]]=k)</span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];r[i+k]==r[j+k];k++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p><strong>愿回首岁月之时，你不会后悔</strong></p>]]></content>
    
    <summary type="html">
    
      后缀数组学习路径以及后缀数组板子推送_算法日常
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>2019杭电多校9题解_算法日常[14/100]</title>
    <link href="http://www.wolfdan.cn/2019/08/19/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-14-100/"/>
    <id>http://www.wolfdan.cn/2019/08/19/算法日常-14-100/</id>
    <published>2019-08-19T02:57:09.000Z</published>
    <updated>2019-08-19T15:39:43.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jls题解"><a href="#jls题解" class="headerlink" title="jls题解"></a>jls题解</h1><p>因为有些 ddl 要肝.. 把视频题解咕了..大家凑合着看文字题解吧</p><p>今年又是 Rikka 和 Yuta 在多校上秀恩爱的一年（说不定也是最后一年了.. sad</p><h2 id="1001-Rikka-with-Quicksort"><a href="#1001-Rikka-with-Quicksort" class="headerlink" title="1001 Rikka with Quicksort"></a>1001 Rikka with Quicksort</h2><p>难度：medium</p><p>考察了大家对快速排序时间复杂度推导的熟悉程度（当然我是打表推式子的）</p><p>如果打表的话可以考虑下面这个式子，它是计算在 $m$ 处增加一个 $1$ 对答案的贡献。</p><script type="math/tex; mode=display">\begin{aligned}h_m(i) &= 0 & i < m\\h_m(i) &= 1 & i =m \\h_m(i) &= \frac{1}{i}\sum_{j=1}^{i}\left( h_m(j-1) + h_m(i-j)\right)  & i > m\end{aligned}</script><p>打表之后可以知道 $h_m(m)=1,h_m(n)=\frac{2(n+1)}{(m+1)(m+2)} (n &gt; m)$。应该归纳一下就可以直接证明。所以把对应的贡献求和之后可以得到答案就是：</p><script type="math/tex; mode=display">2(n+1)H(n)-4n-\frac{2(m+2)H(m+1)-4(m+1)-m)(n+1)}{m+2}</script><p>其中 $H(n)$ 表示调和级数。因为模数确定，可以用分段打表的策略来求调和级数的具体值：即把 $H(kS)$ 的值给打入程序中，这样每一次只需要计算 $kS+1$ 到 $n$ 的逆元就行了。</p><h2 id="1002-Rikka-with-Cake"><a href="#1002-Rikka-with-Cake" class="headerlink" title="1002 Rikka with Cake"></a>1002 Rikka with Cake</h2><p>难度：medium easy</p><p>用欧拉（欧拉欧拉欧拉）公式 $V-E+F = 2$ 来算蛋糕的块数。</p><p>首先考虑点数 $V$，蛋糕的四个角以及射线的端点贡献了 $n+4$ 个顶点（$K$ 太丑了我们用 $n$ 表示射线数），射线和四条边的交点共有 $n$ 个，射线之间的交点有 $c$ 个，因此点数是 $2n+4+c$。</p><p>接着考虑边数，对于每一条射线，假设别的射线和他的交点有 $c_i$ 个，那么这条射线被切成了 $c_i+1$ 段，因此所有射线的边数对应的是 $2c+n$（因为每一个交点被用了两次）。同时因为四条边一共和射线交了 $n$ 次，所以四条边界上共有 $4+n$ 条边，所以 $E=2c+2n+4$。</p><p>因此总的区域数为 $F=2+c$，因为要去掉最外面的无穷区域，所以答案就是 $1+c$。于是问题就变成了求交点个数 $c$。这是一个经典的问题，分四个方向讨论一下离散化用树状数组求就行。时间复杂度 $O(n \log n)$</p><h2 id="1003-Rikka-with-Mista"><a href="#1003-Rikka-with-Mista" class="headerlink" title="1003 Rikka with Mista"></a>1003 Rikka with Mista</h2><p>难度：medium-easy</p><p>在，为什么迫害米斯达？</p><p>可以对每一位分开来计算，和最大不超过 $10^{10}$，因此最多只有 $10$ 位。只要对每一位算出它在多少种情况下是 $4$，全部加起来就可以了。</p><p>$40$ 的数据范围指明了可以用 meet in middle 来做，可以先用 $O(2^{\frac{n}{2}})$ 的复杂度分别把前 $\frac{n}{2}$ 个数和后 $\frac{n}{2}$ 个数的所有和求出来，分别存在数组 $A$ 和 $B$ 中，那么对于第 $i$ 位来说，答案就是有多少个数对 $i,j$ 满足 $(A_i+B_j) \text{ mod } 10^{i+1} \in [4 \times 10^i,5 \times 10^i)$。这个问题只要对 $A$ 和 $B$ 按照 $x \text{ mod }  10^{i+1}$ 排序后用 two pointer 扫就可以了。</p><p>对每一位分开来做时间复杂度是 $O(2^{\frac{n}{2}}n \log w_i)$，瓶颈在堆每一位排序。不难发现对每一位排序可以用一次归并排序来实现，这样就能省下一个 $\log$，时间复杂度是 $O(2^{\frac{n}{2}}n)$。</p><h2 id="1004-Rikka-with-Geometric-Sequence"><a href="#1004-Rikka-with-Geometric-Sequence" class="headerlink" title="1004 Rikka with Geometric Sequence"></a>1004 Rikka with Geometric Sequence</h2><p>难度：medium</p><p>首先长度是 $1$ 的答案就是 $n$，长度为 $2$ 的答案就是 $\frac{n(n-1)}{2}$。我们考虑长度大于等于 $3$ 的情况。</p><p>假设公比的最简分数表示是 $\frac{a}{b}(a &gt; b,\gcd(a,b) = 1)$，等比数列长度是 $k$，那么 $x$ 能作为这样的一个等比数列的最后一项的条件就是 $a^{k-1}|x$，因此这样的等比数列一共有 $\left \lfloor \frac{n}{a^{k-1}} \right \rfloor$。而枚举了 $a$，满足小于 $a$ 且与 $a$ 互质的 $b$ 的数量是 $\varphi(a)$，其中 $\varphi$ 表示欧拉函数。 因此我们可以枚举 $a$ 然后对答案求和：</p><script type="math/tex; mode=display">\sum_{a=2}^n \varphi(a)\left \lfloor \frac{n}{a^{k-1}} \right \rfloor</script><p>显然有贡献的 $a$ 必须小于等于 $\sqrt[k-1] n$，因此当 $k&gt;3$ 的时候就能暴力枚举 $a$ 统计答案了，问题就在于 $k=3$ 的时候的处理。这个时候可以证明 $\left \lfloor \frac{n}{a^2} \right \rfloor$ 的取值最多只有 $\sqrt[3] n$ 种：当 $a \leq \sqrt[3]n$ 的时候，只有 $\sqrt[3] n$ 种值，当 $a &gt; \sqrt[3]n$ 的时候，这个商小于等于 $\sqrt[3]n$，因此最多也就只有 $\sqrt[3]n$ 种答案。</p><p>所以相当于把 $a$ 的取值分成了 $\sqrt[3]n$ 段，对每一段分别用杜教筛求 $\varphi(n)$ 的前缀和就可以了。这样的时间复杂度比较迷幻，我展开一层积分一下可以得到时间复杂度是 $O(n^{\frac{5}{12}})$。不确定最终的时间复杂度是什么。但是如果预处理前 $5 \times 10^7$ 项的欧拉函数，可以非常轻松的跑过去。</p><h2 id="1005-Rikka-with-Game"><a href="#1005-Rikka-with-Game" class="headerlink" title="1005 Rikka with Game"></a>1005 Rikka with Game</h2><p>难度：easy</p><p>签到题，随便脑补一下就能知道答案。首先如果第一位是 $a-x$ 的话，先手会直接结束游戏：如果先手增加第一位，那么后手直接结束游戏；如果先手不增加第一位，那么后手增加第一位，此时如果先手还不结束游戏，后手直接选择结束。这三种情况下游戏结束的字典序都要比游戏开始的时候字典序大。</p><p>如果第一位是 $y$，那么不管先手还是后手都不会选择修改它：如果先手修改它，后手直接结束游戏；如果后手修改它，先手再选择同一位，然后在下一次轮到先手的时候结束。这样对于修改 $y$ 的那一方都是亏的。</p><p>如果第一位是 $z$，那么先手会选择修改它，之后后手也会选择修改它，然后就回到了第一种情况先手直接结束游戏，因此结果就是第一位变成了 $b$.</p><p>在上面三种情况下，只有第二种情况游戏不会再只考虑第一位的情况下结束，这时因为大家都不会动第一位，所以相当于不存在，直接考虑后面的情况就可以。</p><p>所以最后的结论就是，找到第一位不是 $y$ 的位，如果它是 $z$，则修改成 $b$，否则不变。 时间复杂度 $O(n)$。</p><h2 id="1006-Rikka-with-Coin"><a href="#1006-Rikka-with-Coin" class="headerlink" title="1006 Rikka with Coin"></a>1006 Rikka with Coin</h2><p>难度：easy</p><p>首先 $10$ 分的硬币最多只会用一个，如果用了两个，直接替换成一个 $10$ 分一个 $20$ 分一定不亏。</p><p>$20$ 分的硬币最多只会用三个，如果用了四个，直接替换成一个 $10$ 分两个 $20$ 分一个 $50$ 分一定不亏。</p><p>$50$ 分的硬币最多只会用一个，如果用了两个，直接替换成一个 $50$ 分和一个一元一定不亏。</p><p>对于任何一种情况，重复使用上述规则一定会达到一个 $10$ 分硬币最多一个，$20$ 分最多三个，$50$ 分最多一个的情况，不会陷入重复甩锅的死循环。</p><p>因此枚举这三种硬币分别用了多少个，然后整百的部分直接用一元硬币填，取最少的答案就行了。</p><h2 id="1007-Rikka-with-Travel"><a href="#1007-Rikka-with-Travel" class="headerlink" title="1007 Rikka with Travel"></a>1007 Rikka with Travel</h2><p>难度：medium easy</p><p>基础直径练习题。</p><p>考虑判断 $(x,y)$ 能不能出现。劼论：任意取树上的一条直径，那么如果 $(x,y)$ 能出现，那么一定存在一种方案使得直径的两端都被使用了。证明很简单：假设存在一个端点没有被使用，那么考虑两条直线的四个端点 $a,b,c,d$，一定可以把一个端点给移动到直径的这个端点上，因为直径是树上最长的路径，因此这次移动一定不会减少路径的长度。</p><p>考虑对每一个长度 $x$，求可以满足的最长的 $y$，这样所有小于等于 $y$ 的值也都能被满足。考虑在直径上计算这些值：第一种情况，直径的两端分属不同的路径，那么可以枚举直径的一个端点那条路径在直径上的最后一个点，那么这一条路径的最大长度就是这个点到直径端点的距离加上这个点往直径外的最大延伸长度，另一条路径的最大长度也可以类似地求，其中最大延伸长度可以用一个 $O(n)$ 的 DFS 计算出来。第二种情况是有一条路径就是这条直径，那么另一条路径就是这条直径之外的最长路径长度，这个只要把直径上的点都删了再求一遍直径就行。</p><p>总的时间复杂度为 $O(n)$。</p><h2 id="1008-Rikka-with-Stable-Marriage"><a href="#1008-Rikka-with-Stable-Marriage" class="headerlink" title="1008 Rikka with Stable Marriage"></a>1008 Rikka with Stable Marriage</h2><p>难度：medium</p><p>稳定婚姻真实一个深刻的模型啊..这题明明很简单但是不知道为什么没人做。</p><p>考虑把男生和女生分别放到一棵 trie 树里面，然后考虑最高位：首先肯定是让不同子树的男生女生进行匹配，如果左子树里有一队，右子树里有一队，那么交换他们的伴侣肯定一个更好的选择。而因为左右子树的大小可能不均匀，所以在分开来匹配之后，不妨设左子树有一些男生剩下，右子树有一些女生剩下，这个时候就只能让败者组的他们互相舔舐伤口了。</p><p>写成代码很简单，下面是一个简单的伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(node_b, node_g, depth)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node_b.size == <span class="number">0</span> || node_g.size == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (depth == <span class="number">-1</span>) &#123;</span><br><span class="line">marriage(node_b, node_g); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">match(node_b.l, node_g.r, depth - <span class="number">1</span>);</span><br><span class="line">match(node_b.r, node_g.l, depth - <span class="number">1</span>);</span><br><span class="line">match(node_b.l, node_g.l, depth - <span class="number">1</span>);</span><br><span class="line">match(node_b.r, node_g.r, depth - <span class="number">1</span>);</span><br><span class="line">node_b.update_size();</span><br><span class="line">node_g.update_size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>node_b</code> 和 <code>node_g</code> 分别表示男孩和女孩对应的 trie 树节点，<code>depth</code> 表示现在考虑的是哪一层。大致的思想就是暴力递归下去然后贪心的匹配就行了。</p><p>因为每递归 $O(\log a_i)$ 层一定会有一对新人产生，所以总的时间复杂度是 $O(n \log a_i)$ 的。</p><h2 id="1009-Rikka-with-Traffic-Light"><a href="#1009-Rikka-with-Traffic-Light" class="headerlink" title="1009 Rikka with Traffic Light"></a>1009 Rikka with Traffic Light</h2><p>难度：medium hard</p><p>首先可以发现一定存在一个最优方案，所有绿灯区间长度都大于等于 $T_1$，所有红灯区间长度都大于等于 $T_2$。如果如果小于的话，反正这一段时间也没有办法让人过红绿灯，不如就不变了。接着考虑如果灯在第 $t$ 时刻变成了绿灯，最优解中它会在什么时候变成红灯。（对于红灯变成绿灯的分析类似）</p><p>第一种可能性是在 $t+T_1$ 时刻变成红灯，在这种情况下，一定有在 $t$ 之前（包括 $t$） 时刻到达且还没有过马路的人，不然这一段没有人能过马路。</p><p>第二种可能性是在 $t+T_1$ 时刻之后，考虑在这段绿灯中最后过马路的那个人 $i$，他会在 $t_i+T_1$ 时刻后通过马路。因此这段绿灯在第 $t_i+T_1$ 时刻结束一定不亏。</p><p>我们把所有 $t_i+T_1$ 或者 $t_i+T_2$ (取决于 $i$ 的种类) 作为关键点，设 $f_i$ 为在第 $i$ 个人对应的关键切换成另一种灯时的已经能确定过马路时间的人的总等待时间（不妨假设第 $i$ 个人是第一类人）。注意这儿已经能确定过马路时间的人包括在 $t_i$ 时刻之前到达的第一类人和第 $t_i+T_1$  时刻之前达到的第二类人 (最开始发现的性质保证了他们都能在 t_i+T_1) 时刻过马路。</p><p>考虑转移，首先从 $t_i+T1$ 开始，最优方案可能会进行若干段第一种可能性的转移，接着通过一个第二种可能性的转移直接跳到后面的某一个关键点。因为第一种可能性要求必须要有对应的人在等待，因此第一种转移最多进行 $O(n)$ 次。我们可以枚举第一段转移进行的次数，并求出对应的总等待时间（总等待时间的定义和 $f_i$ 一样）。</p><p>最后要处理的就是从枚举的这 $O(n)$ 段到后面的某一个关键点之间的转移，这个把式子列出来之后可以发现用斜率优化就能直接优化到 $O(n)$ 了。</p><p>总时间复杂度为 $O(n^2)$。数据造的我想吐。</p><h2 id="1010-Rikka-with-Defensive-Line"><a href="#1010-Rikka-with-Defensive-Line" class="headerlink" title="1010 Rikka with Defensive Line"></a>1010 Rikka with Defensive Line</h2><p>难度：medium hard</p><p>我九条可怜最喜欢做的一件事，就是出大几何题，对自以为多开就能 AK 的人说“不”。</p><p>过气计算几何选手拼尽全力出的计算几何题..然后根本没人帮我验题..偷偷搞了一个 60 核 server 并行用极角排序验了一下.. 发现这个数据范围的 $O(n^2 \log n)$ 的极角排序并行后两三分钟就跑完了.. 感觉有点牛逼</p><p>首先可以发现对于一个凸包来说，如果一个直线和它有交，那么一定在直线的两侧（不严格）都有至少一个凸包上的顶点。因此我们对点集剥 $m$ （因为 $K$ 太丑这儿就用 $m$ 代替了）层凸包（重复求凸包，删除凸包上的点这一过程 $m$ 次），只有这些凸包上的点可能作为防御线的两个点之一，其他点都没有用了。</p><p>枚举一个点集中的点，把这个点作为坐标系的原点，那么对于任何一个方案，它小于等于 $m$ 的那一边一定覆盖了 $y$ 轴正半轴或者负半轴中的一个。可以先求所有覆盖了 $y$ 轴正半轴的方案，那么另一边只要对称一下再做一遍就行。同时不妨假设另一个端点在 $x$ 轴正方向，逆方向的情况也只要对称一下就行。</p><p>考虑这时哪些点可能作为答案：答案是把 $y$ 轴沿着逆时针防线方向旋转碰到的前 $m$ 个点。同时为了判断这些点是否合法还需要求沿着顺时针方向旋转碰到的前 $m$ 个点。如果把这些点求出来，那么就只要对每一个点看一下这 $2m+1$ 个点（包括原点）里是否有超过 $m$ 个点在这一边就行，这是一个非常基础的 two pointer （注意处理共线的情况）。</p><p>问题的关键就是如何求逆时针方向（顺时针方向同理）的前 $m$ 个点。因为现在的点集有特殊性：由 $m$ 个相互嵌套的凸包组成，因此我们考虑只有一个凸包的特殊情况。讨论可以发现，$y$ 轴正半轴和凸包的交点以及原点到凸包的切点把凸包分成了若干段，其中每一段从极角上考虑都是有序的。因此 $m$ 个凸包一共分成了 $O(m)$ 段，用一个多路归并把这些段归并起来就行。求交点可以按照 $x$ 轴排序枚举原点，这样就可以分上下凸壳分别扫过去；求割点可以用旋转卡壳预处理，这两部分总的时间复杂度都是 $O(nm)$ 的。</p><p>算上 $m$ 路归并的复杂度 $O(m \log m)$，总的时间复杂度为 $O(nm \log m)$。</p><h2 id="1011-Rikka-with-Segment-Tree"><a href="#1011-Rikka-with-Segment-Tree" class="headerlink" title="1011 Rikka with Segment Tree"></a>1011 Rikka with Segment Tree</h2><p>难度：medium</p><p>这个题是一个简单的分形题.. 做法也很传统，就是大力递归下去，难点在于比较麻烦。</p><p>我们用 $F(N)$ 表示到线段树的区间长度到 $N$ 为止的求和。那么除了 $1$ 的情况直接结束，其他的线段树都会递归左子树和右子树。如果我们假设左右子树都是从 $1$ 开始重新标号的话，那么左右子树都是递归到 $\frac{N}{2}$ 上下取整的子问题，这一部分用一个记忆化的递归就行。</p><p>考虑合并左右子树成 $n$ 的情况，首先所有叶子节点的深度都会增加 $1$，这一部分的贡献是 $\sum_{n=2}^N \sum_{i=1}^n i$，可以直接计算。</p><p>最后，因为加上左子树之后，右子树的所有点的编号会对应地发生变化，因此需要再算上对应的贡献。令 $g(n)$ 表示对应区间为 $n$ 的线段树所有叶子节点的深度和，设 $m$ 是最大的整数满足 $2^m \leq n$，那么 $g(n) = nm+2(n-2^m)$。而这一部分的贡献就是：</p><script type="math/tex; mode=display">\sum_{n=2}^N \left \lceil \frac{N}{2}\right \rceil g\left(\left \lfloor \frac{n}{2}\right \rfloor\right)</script><p>推一个式子加上一通预处理，就能 $O(1)$ 计算这个和式了。</p><p>如果用 map 来进行记忆化的话，时间复杂度为 $O(\log^2 n)$。</p><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><ul><li><p>jls真牛逼</p></li><li><p>自己因为浪，导致今天又没学到什么，继续加油吧</p></li><li><p>你真的有在拼吗？想一想你3个月后的回想，你会后悔吗</p></li></ul>]]></content>
    
    <summary type="html">
    
      2019杭电多校9题解_算法日常
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>ARST打卡第17周[17/521]</title>
    <link href="http://www.wolfdan.cn/2019/08/18/ARST%E6%89%93%E5%8D%A1%E7%AC%AC17%E5%91%A8-17-521/"/>
    <id>http://www.wolfdan.cn/2019/08/18/ARST打卡第17周-17-521/</id>
    <published>2019-08-18T13:28:37.000Z</published>
    <updated>2019-08-18T13:30:36.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p><a href="https://github.com/wolfdan666/WolfEat3moreMeatEveryday/tree/master/2019.8/2019.8.17" target="_blank" rel="noopener">虽然比赛很自闭，但仍一直在补牛客杭电多校题目，一起加油</a></p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p><a href="https://medium.com/s/story/your-work-is-the-only-thing-that-matters-26a47ccf778c" target="_blank" rel="noopener">Your Work Is the Only Thing That Matters</a><br><strong>If you cease practicing for a second, if you let your mind get wound too tight or simply allowed to drift elsewhere, you will lose that ability. Your bat will stop connecting with the ball, your batting average will drop and soon enough you yourself will be dropped, first from the majors and then the sport altogether.</strong></p><p><strong>是啊，我们只要放松一秒，我们的竞技水平就会急剧下滑，所以我们不能放松，否则就是万丈深渊，输掉曾经所有的努力</strong></p><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p><a href="https://blog.csdn.net/yockie/article/details/52674366" target="_blank" rel="noopener">C++11使用emplace_back代替push_back</a><br>这个文章好久好在它的泛用性，你可以使用里面的头文件去做其他的时间测试</p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p><a href="https://www.wolfdan.cn/2019/08/13/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-8-100/">银联挑战赛复赛A,B题_算法日常[8/100]</a></p><p><a href="https://www.wolfdan.cn/2019/08/14/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-9-100/">10进制矩阵快速幂-狼胆带你每天头铁一题-算法日常[9/100]</a></p><p><a href="https://www.wolfdan.cn/2019/08/15/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-10-521/">折半搜索_算法日常[10/521]</a></p><p><a href="https://www.wolfdan.cn/2019/08/16/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-11-100/">2019牛客多校9E题详解_算法日常[11/100]</a></p><p><a href="https://www.wolfdan.cn/2019/08/17/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-12-100/">2019牛客多校10 B题_算法日常[12/100]</a></p><p><a href="https://www.wolfdan.cn/2019/08/18/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-13-100/">2019牛客第十场F题详解_算法日常[13/100]</a></p>]]></content>
    
    <summary type="html">
    
      ARST打卡 银联挑战赛复赛A,B题_算法日常[8/100] 10进制矩阵快速幂-狼胆带你每天头铁一题算法日常[9/100] 折半搜索算法日常[10/521] 2019牛客多校9E题详解算法日常[11/100] 2019牛客多校10 B题算法日常[12/100] 2019牛客第十场F题详解算法日常[13/100]
    
    </summary>
    
      <category term="ARST" scheme="http://www.wolfdan.cn/categories/ARST/"/>
    
    
      <category term="ARST" scheme="http://www.wolfdan.cn/tags/ARST/"/>
    
  </entry>
  
  <entry>
    <title>2019牛客第十场F题详解_算法日常[13/100]</title>
    <link href="http://www.wolfdan.cn/2019/08/18/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-13-100/"/>
    <id>http://www.wolfdan.cn/2019/08/18/算法日常-13-100/</id>
    <published>2019-08-18T10:15:16.000Z</published>
    <updated>2019-08-18T12:53:26.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019牛客第十场F题详解"><a href="#2019牛客第十场F题详解" class="headerlink" title="2019牛客第十场F题详解"></a>2019牛客第十场F题详解</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://ac.nowcoder.com/acm/contest/890/F" target="_blank" rel="noopener">2019牛客第十场F题详解</a></p><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/2019%E5%B9%B4%E5%A4%9A%E6%A0%A1/%E7%89%9B%E5%AE%A2/%E7%AC%AC%E5%8D%81%E5%9C%BA/F_1.png" alt><br><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/2019%E5%B9%B4%E5%A4%9A%E6%A0%A1/%E7%89%9B%E5%AE%A2/%E7%AC%AC%E5%8D%81%E5%9C%BA/F_2.png" alt></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>我的分析请看代码</strong><br><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/2019%E5%B9%B4%E5%A4%9A%E6%A0%A1/%E7%89%9B%E5%AE%A2/%E7%AC%AC%E5%8D%81%E5%9C%BA/F_an.png" alt></p><p><strong>本来以为发现了更快更简单的做法，结果想写成思路给大家看，然后不断想怎么表述这个算法，想着想着发现这是一个假的超快AC算法，然后大家有兴趣的话可以看我的AC代码二的分析(果然写blog<del>做搬运工</del>也是有收获的)</strong></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">6e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">6e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn],cnt[maxn],ans,n,r;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; h[maxn];</span><br><span class="line"><span class="built_in">multiset</span> &lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p=s.find(cnt[x]);</span><br><span class="line">    s.erase(p); cnt[x]++;</span><br><span class="line">    s.insert(cnt[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p=s.find(cnt[x]);</span><br><span class="line">    s.erase(p); cnt[x]--;</span><br><span class="line">    s.insert(cnt[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">        <span class="comment">/* 统一右移2*r */</span></span><br><span class="line">        a[i]+=r*<span class="number">2</span>; b[i]+=r*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">/*打a[i]的时候,把a[i]-r,a[i]+r也叠加上a[i]上面的值,</span></span><br><span class="line"><span class="comment">        这样就能使得a[i]表示打a[i]能获得的总值*/</span></span><br><span class="line">        h[a[i]-r].pb(b[i]);</span><br><span class="line">        h[a[i]].pb(b[i]);</span><br><span class="line">        h[aa[i]+r].pb(b[i]);</span><br><span class="line">        cnt[b[i]]++; cnt[b[i]-r]++; cnt[b[i]+r]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=r;i&lt;=N-r;i++) s.insert(cnt[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=r;i&lt;=N-r;i++)&#123;</span><br><span class="line">        <span class="comment">/*得到中间打这里能够得到的个数*/</span></span><br><span class="line">        <span class="keyword">int</span> ret=(<span class="keyword">int</span>)h[i].size();</span><br><span class="line">        <span class="comment">/*暂时删除相关的所有列值*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x:h[i]) del(x),del(x-r),del(x+r);</span><br><span class="line">        <span class="comment">/*然后得到当下最大的3列值*/</span></span><br><span class="line">        <span class="keyword">auto</span> p=s.rbegin();</span><br><span class="line">        ans=max(ans,ret+(*p));</span><br><span class="line">        <span class="comment">/*再把列值插回去*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x:h[i]) add(x),add(x-r),add(x+r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="能更快AC的假算法"><a href="#能更快AC的假算法" class="headerlink" title="能更快AC的假算法"></a>能更快AC的假算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*直接行列序列化排序的做法,真滴是好想法!*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*2019年8月18日20:26:30 发现这是一个假做法！靠着数据水才过的！因为这里只比较了最大的3个</span></span><br><span class="line"><span class="comment">行值，就去比较列值了！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">因为可能有一种情况就是选第4大行，但是取到的列值更多，这应该是有可能出现的，</span></span><br><span class="line"><span class="comment">总之这种做法虽然能过   但是是有可能遗漏情况的假算法！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">必须要枚举到所有的行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M =<span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> num[M *<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span>  n , r , ans;</span><br><span class="line"><span class="keyword">int</span> cnt[M * <span class="number">3</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x , y;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node d)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; d.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[M] , b[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt;r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i].x &gt;&gt; a[i].y;</span><br><span class="line">        a[i].x++;</span><br><span class="line">        a[i].y++;</span><br><span class="line">        num[a[i].x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*枚举每个行坐标,相加从上到下3行的值--&gt;二维降到一维*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">100000</span>;i++)&#123;</span><br><span class="line">        <span class="comment">/*之所以放在最左边是因为i是从最左边开始,免去判断*/</span></span><br><span class="line">        b[i].x = num[i] + num[i +r] + num[i +r +r];</span><br><span class="line">        b[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*行值获利大到小排序*/</span></span><br><span class="line">    sort(b + <span class="number">1</span> ,b + <span class="number">100001</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt , <span class="number">0</span> ,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            <span class="comment">/*除去原来的行(3次行值取max)以外的其他列的值的统计*/</span></span><br><span class="line">            <span class="keyword">if</span>(a[j].x != b[i].id &amp;&amp; a[j].x != b[i].id +r  &amp;&amp; a[j].x != b[i].id +r * <span class="number">2</span>) cnt[a[j].y]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; M;j++) sum = max( sum , cnt[j] + cnt[j +r] +cnt[j + r + r]);</span><br><span class="line">        ans = max(ans , sum + b[i].x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="每天叨叨一句"><a href="#每天叨叨一句" class="headerlink" title="每天叨叨一句"></a>每天叨叨一句</h1><p><strong>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能</strong></p>]]></content>
    
    <summary type="html">
    
      2019牛客第十场F题详解 贪心题 天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="狼胆带你每天头铁一题" scheme="http://www.wolfdan.cn/tags/%E7%8B%BC%E8%83%86%E5%B8%A6%E4%BD%A0%E6%AF%8F%E5%A4%A9%E5%A4%B4%E9%93%81%E4%B8%80%E9%A2%98/"/>
    
      <category term="贪心" scheme="http://www.wolfdan.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>2019牛客多校10 B题_算法日常[12/100]</title>
    <link href="http://www.wolfdan.cn/2019/08/17/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-12-100/"/>
    <id>http://www.wolfdan.cn/2019/08/17/算法日常-12-100/</id>
    <published>2019-08-17T15:01:59.000Z</published>
    <updated>2019-08-18T02:08:29.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019牛客多校10-B题"><a href="#2019牛客多校10-B题" class="headerlink" title="2019牛客多校10 B题"></a>2019牛客多校10 B题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://ac.nowcoder.com/acm/contest/890/B" target="_blank" rel="noopener">2019牛客多校10 B题</a><br><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/2019%E5%B9%B4%E5%A4%9A%E6%A0%A1/%E7%89%9B%E5%AE%A2/%E7%AC%AC%E5%8D%81%E5%9C%BA/B_1.png" alt="B_1"></p><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/2019%E5%B9%B4%E5%A4%9A%E6%A0%A1/%E7%89%9B%E5%AE%A2/%E7%AC%AC%E5%8D%81%E5%9C%BA/B_2.png" alt="B_2"></p><h2 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h2><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/2019%E5%B9%B4%E5%A4%9A%E6%A0%A1/%E7%89%9B%E5%AE%A2/%E7%AC%AC%E5%8D%81%E5%9C%BA/B_A.png" alt="B_A"></p><p><strong>(详见代码注释)</strong></p><p><strong>C++由于容易数据溢出，所以必须加限制，否则会造成数据溢出的错误，昨晚WA了两个小时的血的教训</strong></p><p>k不会到很大的数据范围(限制在了k&lt;10^12)</p><p>然后递归的时候是一样的,最终也是递归到x==1,x==2</p><p>是按照题中斐波那契递归回去的，所以不会出错</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p><strong>写了python版之后去写C++版本的，结果一直WA了整整2个多小时，眼睛痛，所以决定明天早起再看看哪里出错了并给出C++版的AC代码</strong>(第二天已经更新)</p><h3 id="Python3版"><a href="#Python3版" class="headerlink" title="Python3版"></a>Python3版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line"></span><br><span class="line">lf = [<span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="comment"># 一千多项的时候远远超过了10^12+7的</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>) :</span><br><span class="line">    lf.append(lf[<span class="number">-2</span>] + lf[<span class="number">-1</span>])</span><br><span class="line">    <span class="comment"># if _ == 999:</span></span><br><span class="line">    <span class="comment">#     print(If[-1])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, s)</span> :</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">1</span> :</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"COFFEE"</span>[s]</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">2</span> :</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"CHICKEN"</span>[s]</span><br><span class="line">    <span class="keyword">if</span> s &gt;= lf[x<span class="number">-2</span>] :</span><br><span class="line">        <span class="keyword">return</span> f(x - <span class="number">1</span>, s - lf[x - <span class="number">2</span>])</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="keyword">return</span> f(x - <span class="number">2</span>, s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(eval(input())) :</span><br><span class="line">    n, s = map(int, input().split())</span><br><span class="line">    s -= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 从s到min(s+10,lf[n]), 用中括号括起来生成列表</span></span><br><span class="line">    r = [f(n, t) <span class="keyword">for</span> t <span class="keyword">in</span> range(s, min(s + <span class="number">10</span>, lf[n]))]</span><br><span class="line">    print(<span class="string">''</span>.join(r))</span><br></pre></td></tr></table></figure><h3 id="C-AC代码1-与题解思路相同的"><a href="#C-AC代码1-与题解思路相同的" class="headerlink" title="C++AC代码1_与题解思路相同的"></a>C++AC代码1_与题解思路相同的</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line">ll len[<span class="number">505</span>];</span><br><span class="line"><span class="built_in">string</span> ans;</span><br><span class="line"><span class="keyword">int</span> T,n;ll k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x,ll k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">return</span> <span class="string">"COFFEE"</span>[k];</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2</span>) <span class="keyword">return</span> <span class="string">"CHICKEN"</span>[k];</span><br><span class="line">    <span class="keyword">if</span>(k&gt;=len[x<span class="number">-2</span>]) <span class="keyword">return</span> f(x<span class="number">-1</span>,k-len[x<span class="number">-2</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> f(x<span class="number">-2</span>,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    len[<span class="number">1</span>] = <span class="number">6</span>,len[<span class="number">2</span>] = <span class="number">7</span>;</span><br><span class="line">    ll mx = <span class="number">1e13</span>;</span><br><span class="line">    <span class="comment">/*这里最好不要break,否则会造成数组的部分是0值，除非先赋值为mx</span></span><br><span class="line"><span class="comment">    (当然也可以使用C++AC代码二的特殊提前处理去使用break)</span></span><br><span class="line"><span class="comment">    但是可以通过min控制数值大小，以免引发数据溢出错误</span></span><br><span class="line"><span class="comment">    可以使用min的原因是，k不会到很大的数据范围</span></span><br><span class="line"><span class="comment">    然后递归的时候是一样的,最终也是递归到x==1,x==2</span></span><br><span class="line"><span class="comment">    是按照题中斐波那契递归回去的，所以不会出错*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">500</span>;i++)&#123;</span><br><span class="line">        len[i] = min(len[i<span class="number">-2</span>]+len[i<span class="number">-1</span>],mx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">cin</span>&gt;&gt;T;T--;)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        k-=<span class="number">1</span>;</span><br><span class="line">        ans.clear();</span><br><span class="line">        ll tn = min(k+<span class="number">10</span>,len[n]);</span><br><span class="line">        <span class="keyword">for</span>(ll i=k;i&lt;tn;i++)&#123;</span><br><span class="line">            ans += f(n,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-AC代码2"><a href="#C-AC代码2" class="headerlink" title="C++AC代码2"></a>C++AC代码2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll len[<span class="number">505</span>];</span><br><span class="line"><span class="built_in">string</span> str[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*substr的第二个参数是长度*/</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= <span class="number">2</span>) <span class="keyword">return</span> str[x].substr(a<span class="number">-1</span>, b);</span><br><span class="line">    <span class="keyword">if</span>(a+b<span class="number">-1</span> &lt;= len[x<span class="number">-2</span>]) <span class="keyword">return</span> dfs(x<span class="number">-2</span>, a, b);</span><br><span class="line">    <span class="keyword">if</span>(a &gt; len[x<span class="number">-2</span>]) <span class="keyword">return</span> dfs(x<span class="number">-1</span>, a-len[x<span class="number">-2</span>], b);</span><br><span class="line">    <span class="comment">/*分段后..x-1可以直接从1开始了*/</span></span><br><span class="line">    <span class="keyword">return</span> dfs(x<span class="number">-2</span>, a, len[x<span class="number">-2</span>]-a+<span class="number">1</span>) + dfs(x<span class="number">-1</span>, <span class="number">1</span>, b-(len[x<span class="number">-2</span>]-a+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    str[<span class="number">1</span>] = <span class="string">"COFFEE"</span>; str[<span class="number">2</span>] = <span class="string">"CHICKEN"</span>;</span><br><span class="line">    len[<span class="number">1</span>] = <span class="number">6</span>, len[<span class="number">2</span>] = <span class="number">7</span>;</span><br><span class="line">    ll mx = <span class="number">1e17</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">500</span>; i++) &#123;</span><br><span class="line">        <span class="comment">/*前缀和*/</span></span><br><span class="line">        len[i] = len[i<span class="number">-1</span>] + len[i<span class="number">-2</span>];</span><br><span class="line">        <span class="comment">/* i=80就会跳出*/</span></span><br><span class="line">        <span class="keyword">if</span>(len[i] &gt; mx) &#123;<span class="comment">/*cout&lt;&lt;i&lt;&lt;endl;*/</span><span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n; ll k;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="comment">/*提前给x降低大小，所以就可以前面使用break，并且减少递归的次数*/</span></span><br><span class="line">        <span class="keyword">for</span>(x = <span class="number">1</span>; x &lt;= n; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(len[x] &gt;= k+<span class="number">10</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == n+<span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; dfs(x<span class="number">-1</span>, k, min(<span class="number">10l</span>l, len[x]-k+<span class="number">1</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>((n-x)%<span class="number">2</span>) x++;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; dfs(x, k, min(<span class="number">10l</span>l, len[x]-k+<span class="number">1</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p><strong>不用去刻意讨好谁，因为只有做自己，才配得上最棒的人生</strong></p>]]></content>
    
    <summary type="html">
    
      2019牛客多校10 B题,斐波那契数列递归构造字符串的思维题 C++由于容易数据溢出，所以必须加限制，否则会造成数据溢出的错误，昨晚WA了两个小时的血的教训 不用去刻意讨好谁，因为只有做自己，才配得上最棒的人生
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="狼胆带你每天头铁一题" scheme="http://www.wolfdan.cn/tags/%E7%8B%BC%E8%83%86%E5%B8%A6%E4%BD%A0%E6%AF%8F%E5%A4%A9%E5%A4%B4%E9%93%81%E4%B8%80%E9%A2%98/"/>
    
      <category term="斐波那契数列" scheme="http://www.wolfdan.cn/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    
      <category term="递归" scheme="http://www.wolfdan.cn/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="字符串" scheme="http://www.wolfdan.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>2019牛客多校9E题详解_算法日常[11/100]</title>
    <link href="http://www.wolfdan.cn/2019/08/16/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-11-100/"/>
    <id>http://www.wolfdan.cn/2019/08/16/算法日常-11-100/</id>
    <published>2019-08-16T12:20:54.000Z</published>
    <updated>2019-08-16T13:00:46.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组合数学思维题"><a href="#组合数学思维题" class="headerlink" title="组合数学思维题"></a>组合数学思维题</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://ac.nowcoder.com/acm/contest/889/E" target="_blank" rel="noopener">2019牛客多校9 E题</a></p><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/2019%E5%B9%B4%E5%A4%9A%E6%A0%A1/%E7%89%9B%E5%AE%A2/%E7%AC%AC%E4%B9%9D%E5%9C%BA/E_ti1.png" alt="ti1"></p><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/2019%E5%B9%B4%E5%A4%9A%E6%A0%A1/%E7%89%9B%E5%AE%A2/%E7%AC%AC%E4%B9%9D%E5%9C%BA/E_ti2.png" alt="ti2"></p><h2 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h2><p><strong>其实解法一二的本质内核是一样的，可以都看一下</strong></p><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>当合并这两个集合的时候，应该将这两个集合合并后消失的贡献减去<br>消失的贡献就应该是选择了一个a，选择了一个b，从剩下的众多集合中选择两个<br>(即cd,ce,ef……)那么这个怎么算呢，可以用完全平方公式来推导<br>(a+b+c+d)^2=a^2+b^2+c^2+d^2+2ab+2ac+2bc+2ad+2bd+2cd<br>所以众多集合中选择任意选择两个的情况可以用（和的平方-平方的和）/2来求（最重要的一步）</p><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/2019%E5%B9%B4%E5%A4%9A%E6%A0%A1/%E7%89%9B%E5%AE%A2/%E7%AC%AC%E4%B9%9D%E5%9C%BA/E_tijie_ldm.png" alt="tijie"></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h3 id="解法一代码"><a href="#解法一代码" class="headerlink" title="解法一代码"></a>解法一代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> f[MAXN], sz[MAXN];</span><br><span class="line">ll sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">sqr</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l * x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x] == x ? x : (f[x] = getf(f[x]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    ll ans = (__int128) n * (n - <span class="number">1</span>) * (n - <span class="number">2</span>) * (n - <span class="number">3</span>) / <span class="number">24</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i] = i;</span><br><span class="line">        sz[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*最开始的平方和*/</span></span><br><span class="line">    sum = n;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        u = getf(u);</span><br><span class="line">        v = getf(v);</span><br><span class="line">        <span class="keyword">if</span>(ans==<span class="number">0</span> || u==v) <span class="keyword">goto</span> END;</span><br><span class="line">        <span class="keyword">if</span> (u != v) &#123;</span><br><span class="line">            <span class="comment">/*减掉合并部分的平方和*/</span></span><br><span class="line">            sum -= sqr(sz[u]) + sqr(sz[v]);</span><br><span class="line">            <span class="comment">/*后面的(sqr(n - sz[u] - sz[v]) - sum) / 2;就是`和的平方`-`平方和`=`剩下的所有两两组合`*/</span></span><br><span class="line">            ll tmp = <span class="number">1l</span>l * sz[u] * sz[v] * (sqr(n - sz[u] - sz[v]) - sum) / <span class="number">2</span>;</span><br><span class="line">            f[u] = v;</span><br><span class="line">            sz[v] += sz[u];</span><br><span class="line">            <span class="comment">/*新的平方和的维护*/</span></span><br><span class="line">            sum += sqr(sz[v]);</span><br><span class="line">            <span class="comment">/*减去合并减少的贡献值*/</span></span><br><span class="line">            ans -= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        END:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法二代码"><a href="#解法二代码" class="headerlink" title="解法二代码"></a>解法二代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll C[maxn][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> p[maxn], sz[maxn], cnt[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++) C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            C[i][j] = C[i<span class="number">-1</span>][j] + C[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == p[x] ? x : p[x] = Find(p[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = Find(x), fy = Find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx != fy) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fx &gt; fy) swap(fx, fy);</span><br><span class="line">        p[fx] = fy;</span><br><span class="line">        ll tp = C[n-sz[fx]-sz[fy]][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : st) &#123;</span><br><span class="line">            tp -= C[i][<span class="number">2</span>]*cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">        tp += C[sz[fx]][<span class="number">2</span>]+C[sz[fy]][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(tp &gt; <span class="number">0</span>) ans -= <span class="number">1L</span>L*sz[fx]*sz[fy]*tp;</span><br><span class="line">        cnt[sz[fx]]--;</span><br><span class="line">        cnt[sz[fy]]--;</span><br><span class="line">        <span class="keyword">if</span>(cnt[sz[fx]] == <span class="number">0</span>) st.erase(sz[fx]);</span><br><span class="line">        <span class="keyword">if</span>(cnt[sz[fy]] == <span class="number">0</span>) st.erase(sz[fy]);</span><br><span class="line">        sz[fy] += sz[fx];</span><br><span class="line">        cnt[sz[fy]]++;</span><br><span class="line">        st.insert(sz[fy]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        sz[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[<span class="number">1</span>] = n; st.insert(<span class="number">1</span>);</span><br><span class="line">    ans = C[n][<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        Union(u, v);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p>生活总是很奇妙，我们到底该去向何方？</p><p>世俗的成功吗？还是当下的快乐呢？</p><p>珍惜身边的人呢？还是继续寻找？</p>]]></content>
    
    <summary type="html">
    
      2019牛客多校9 E题,组合数学的思维题 生活到底是什么
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="狼胆带你每天头铁一题" scheme="http://www.wolfdan.cn/tags/%E7%8B%BC%E8%83%86%E5%B8%A6%E4%BD%A0%E6%AF%8F%E5%A4%A9%E5%A4%B4%E9%93%81%E4%B8%80%E9%A2%98/"/>
    
      <category term="组合数学" scheme="http://www.wolfdan.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>折半搜索_算法日常[10/521]</title>
    <link href="http://www.wolfdan.cn/2019/08/15/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-10-521/"/>
    <id>http://www.wolfdan.cn/2019/08/15/算法日常-10-521/</id>
    <published>2019-08-15T12:18:44.000Z</published>
    <updated>2019-08-15T13:08:27.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://ac.nowcoder.com/acm/contest/889/D" target="_blank" rel="noopener">2019牛客多校9 D题</a></p><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/2019%E5%B9%B4%E5%A4%9A%E6%A0%A1/%E7%89%9B%E5%AE%A2/%E7%AC%AC%E4%B9%9D%E5%9C%BA/D_ti.png" alt="D_ti"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>折半搜索,详见下面的算法推荐和下面的AC的代码</p><p><a href="https://oi-wiki.org/search/#meet-in-middle" target="_blank" rel="noopener">meet-in-middle</a></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ll v;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; r) <span class="keyword">const</span> &#123; <span class="keyword">return</span> v &lt; r.v; &#125;</span><br><span class="line">&#125;b[maxn];</span><br><span class="line">ll arr[<span class="number">40</span>];</span><br><span class="line">ll a[maxn], c[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; ll sum;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;n, &amp;sum);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;arr[i]);</span><br><span class="line">    <span class="keyword">int</span> x = n/<span class="number">2</span>, y = n-x;</span><br><span class="line">    <span class="keyword">int</span> up1 = (<span class="number">1</span>&lt;&lt;x), up2 = (<span class="number">1</span>&lt;&lt;y);</span><br><span class="line">    <span class="comment">/*全0到全1串的遍历，然后之后是对每个串的逐位遍历，记录此串的和值*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; up1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &amp; (<span class="number">1</span>&lt;&lt;j)) a[i] += arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; up2; i++) &#123;</span><br><span class="line">        b[i].id = i; b[i].v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; y; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &amp; (<span class="number">1</span>&lt;&lt;j)) b[i].v += arr[x+j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*让B[i]数组有序，然后使用lower_bound去搜索*/</span></span><br><span class="line">    sort(b, b+up2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; up2; i++) c[i] = b[i].v;</span><br><span class="line">    <span class="comment">/*这里复杂度是2^18*log(2^18) = 4.7*10^6左右*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; up1; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = lower_bound(c, c+up2, sum-a[i])-c;</span><br><span class="line">        <span class="keyword">if</span>(c[p]+a[i] == sum) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &amp; (<span class="number">1</span>&lt;&lt;j)) <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> id = b[p].id;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; y; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(id &amp; (<span class="number">1</span>&lt;&lt;j)) <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="每天叨叨一句"><a href="#每天叨叨一句" class="headerlink" title="每天叨叨一句"></a>每天叨叨一句</h1><h2 id="“我不同意你，-但我可以支持你”"><a href="#“我不同意你，-但我可以支持你”" class="headerlink" title="“我不同意你， 但我可以支持你”"></a>“我不同意你， 但我可以支持你”</h2><p>李开复原来是学法律的，但他爱好计算机，后来师从美国卡内基梅隆大学计算机学院院长罗杰·瑞迪。</p><p>罗杰非常喜欢李开复，把自己的知识毫无保留地传授给李开复，使得他在编程水平突飞猛进。但随着研究的深入，李开复与导师有了分歧，尤其是在计算机语音识别系统研究时，罗杰主张用传统的方法，可是李开复却想从另一个方向，这悖离了主流，有别于大多数语音技术同行。怎么办？导师给李开复指出来了，让他“悬崖勒马”。可是李开复还是想按照自己的想法做。</p><p>有不少关系李开复的好心人提醒他：“你在计算机领域还乳臭未干，人家罗杰是美国国家工程学院和美国艺术与科学学院院士，你听导师的，可以少走弯路。”可是李开复却说：“我想另辟溪径。”“可是这样会得罪导师，如果得不到他的支持，你可能寸步难行。你另搞一套，如果成了，让他多没面子。相反你顺从了他，他是总统特别顾问委员会信息委员会成员、‘图灵奖’获得者，有他的提携，将来前途不可限量。”可是那时的李开复没想那么复杂，还是决定走自己的路。</p><p>没想到，尽管导师批评了李开复几次，可是李开复一意孤行。罗杰说：<strong>“作为科学家，我也不是全知全能。我不同意你的看法，但我可以支持你。”</strong>这让李开复非常意外。</p><p>此后，李开复就放开手脚大干起来。不久，罗杰又来问李开复：“有没有什么困难？”“暂时没有。”“如果有什么需要我帮助的，尽管说啊。”李开复反问道：“你不生我的气啊？”“‘不认同’不等于‘不支持’。”罗杰说。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://blog.sina.com.cn/s/blog_98acb6e70102w95o.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_98acb6e70102w95o.html</a></p>]]></content>
    
    <summary type="html">
    
      2019牛客多校9 D题,折半搜索  我不同意你， 但我可以支持你
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="狼胆带你每天头铁一题" scheme="http://www.wolfdan.cn/tags/%E7%8B%BC%E8%83%86%E5%B8%A6%E4%BD%A0%E6%AF%8F%E5%A4%A9%E5%A4%B4%E9%93%81%E4%B8%80%E9%A2%98/"/>
    
      <category term="折半搜索" scheme="http://www.wolfdan.cn/tags/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>10进制矩阵快速幂-狼胆带你每天头铁一题-算法日常[9/100]</title>
    <link href="http://www.wolfdan.cn/2019/08/14/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-9-100/"/>
    <id>http://www.wolfdan.cn/2019/08/14/算法日常-9-100/</id>
    <published>2019-08-14T12:30:59.000Z</published>
    <updated>2019-08-14T15:16:45.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="头铁来源"><a href="#头铁来源" class="headerlink" title="头铁来源"></a>头铁来源</h1><p>因为狼胆小编本人比较垃圾，所以只能每天带大家头铁一题简单常识题(大佬眼中的常识，我这个蒟蒻还只能头铁)，希望能帮助到小白，那就很开心了</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://ac.nowcoder.com/acm/contest/885/B" target="_blank" rel="noopener">2019牛客多校5 B题</a></p><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/2019%E5%B9%B4%E5%A4%9A%E6%A0%A1/%E7%89%9B%E5%AE%A2/%E7%AC%AC%E4%BA%94%E5%9C%BA/B_ti.png" alt="B_ti"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="理想中的草稿状态"><a href="#理想中的草稿状态" class="headerlink" title="理想中的草稿状态"></a>理想中的草稿状态</h3><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/2019%E5%B9%B4%E5%A4%9A%E6%A0%A1/%E7%89%9B%E5%AE%A2/%E7%AC%AC%E4%BA%94%E5%9C%BA/%E7%90%86%E6%83%B3%E8%8D%89%E7%A8%BF.png" alt="理想"></p><h3 id="真实的草稿状态"><a href="#真实的草稿状态" class="headerlink" title="真实的草稿状态"></a>真实的草稿状态</h3><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/2019%E5%B9%B4%E5%A4%9A%E6%A0%A1/%E7%89%9B%E5%AE%A2/%E7%AC%AC%E4%BA%94%E5%9C%BA/%E7%8E%B0%E5%AE%9E%E8%8D%89%E7%A8%BF.png" alt="真实"></p><h3 id="dreammoon大佬的官方的题解也可以看看"><a href="#dreammoon大佬的官方的题解也可以看看" class="headerlink" title="dreammoon大佬的官方的题解也可以看看"></a>dreammoon大佬的官方的题解也可以看看</h3><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/2019%E5%B9%B4%E5%A4%9A%E6%A0%A1/%E7%89%9B%E5%AE%A2/%E7%AC%AC%E4%BA%94%E5%9C%BA/%E8%BF%99%E9%87%8C%E7%9A%84%E5%8D%95%E4%BD%8D%E6%98%AFbase%EF%BC%8C%E5%BA%95%E7%9A%84%E6%84%8F%E6%80%9D...%E4%BB%A5%E5%89%8D%E4%B8%80%E7%9B%B4get%E4%B8%8D%E5%88%B0%E6%A2%A6%E6%9C%88%E5%A4%A7%E4%BD%AC%E7%9A%84%E7%82%B9.png" alt></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">3000010</span>;</span><br><span class="line">ULL MOD;</span><br><span class="line"><span class="keyword">char</span> s[SIZE];</span><br><span class="line"><span class="comment">/*矩阵相乘，第一行乘以第一列，第一行乘以第二列……也可以使用for两重循环求*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(ULL* c1, ULL* c2, ULL *res)</span></span>&#123;</span><br><span class="line">    res[<span class="number">0</span>] = (c1[<span class="number">0</span>] * c2[<span class="number">0</span>] + c1[<span class="number">1</span>] * c2[<span class="number">2</span>]) % MOD;</span><br><span class="line">    res[<span class="number">1</span>] = (c1[<span class="number">0</span>] * c2[<span class="number">1</span>] + c1[<span class="number">1</span>] * c2[<span class="number">3</span>]) % MOD;</span><br><span class="line">    res[<span class="number">2</span>] = (c1[<span class="number">2</span>] * c2[<span class="number">0</span>] + c1[<span class="number">3</span>] * c2[<span class="number">2</span>]) % MOD;</span><br><span class="line">    res[<span class="number">3</span>] = (c1[<span class="number">3</span>] * c2[<span class="number">3</span>] + c1[<span class="number">2</span>] * c2[<span class="number">1</span>]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">int</span> x1,x2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;x1, &amp;x2, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%llu"</span>,s, &amp;MOD);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 统计长度，并且把个位的值(即最后一位的值)减去1 */</span></span><br><span class="line">    <span class="keyword">for</span>(; s[len]; len++);</span><br><span class="line">    s[len<span class="number">-1</span>]--;</span><br><span class="line">    <span class="comment">/* 个位减掉了之后向前面借位 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; s[i] &lt; <span class="string">'0'</span>; i--)&#123;</span><br><span class="line">        s[i] = <span class="string">'9'</span>;</span><br><span class="line">        s[i<span class="number">-1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    ULL now0 = x1, now1 = x2;</span><br><span class="line">    ULL d[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">2</span>] = b;</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">3</span>] = a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> it = len - <span class="number">1</span>; it &gt;= <span class="number">0</span>; it--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(d[<span class="number">1</span>], <span class="number">0</span>, <span class="keyword">sizeof</span>(ULL) * <span class="number">12</span>);</span><br><span class="line">        <span class="comment">/*A "常数"矩阵相乘4次*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">1</span>; p &lt; <span class="number">4</span>; p++)&#123;</span><br><span class="line">            mul(d[p<span class="number">-1</span>], d[p<span class="number">-1</span>], d[p]);</span><br><span class="line">        &#125;</span><br><span class="line">        s[it] -= <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; <span class="number">4</span>; p++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((s[it] &gt;&gt; p) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                ULL* ml = d[p];</span><br><span class="line">                <span class="built_in">std</span>::tie(now0, now1) = <span class="built_in">std</span>::make_pair((ml[<span class="number">0</span>] * now0 + ml[<span class="number">1</span>] * now1) % MOD,(ml[<span class="number">2</span>] * now0 + ml[<span class="number">3</span>] * now1) % MOD);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mul(d[<span class="number">1</span>], d[<span class="number">3</span>], d[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%llu\n"</span>, now1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="少量知识点"><a href="#少量知识点" class="headerlink" title="少量知识点"></a>少量知识点</h3><p><a href="http://www.cplusplus.com/reference/tuple/tie/?kw=tie" target="_blank" rel="noopener">tie</a></p><p>pair是tuple的一个子集</p><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p>今天看到一禅小和尚: 我们尝遍生活的苦，却都只是为了过好平凡的一生</p><p><strong>但我觉得如果自己明知道人生是苦，明知道<a href="https://www.wolfdan.cn/2019/08/05/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-4-100/">人是基因的机器人(参见算法日常4的叨叨)</a>，却认认认真真地选择好好生活，这就是一种伟大，这就是自由，这就是自己的突破，就是自己的英雄！</strong></p>]]></content>
    
    <summary type="html">
    
      2019牛客多校5 B题,数学,10进制矩阵快速幂，矩阵快速幂,算法学习日常___我觉得如果自己明知道人生是苦，却认认认真真地选择好好生活，这就是一种伟大，这就是自由，这就是自己的突破，就是自己的英雄！
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="狼胆带你每天头铁一题" scheme="http://www.wolfdan.cn/tags/%E7%8B%BC%E8%83%86%E5%B8%A6%E4%BD%A0%E6%AF%8F%E5%A4%A9%E5%A4%B4%E9%93%81%E4%B8%80%E9%A2%98/"/>
    
      <category term="数学" scheme="http://www.wolfdan.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="矩阵快速幂" scheme="http://www.wolfdan.cn/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
      <category term="10进制矩阵快速幂" scheme="http://www.wolfdan.cn/tags/10%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>银联挑战赛复赛A,B题_算法日常[8/100]</title>
    <link href="http://www.wolfdan.cn/2019/08/13/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-8-100/"/>
    <id>http://www.wolfdan.cn/2019/08/13/算法日常-8-100/</id>
    <published>2019-08-13T09:22:31.000Z</published>
    <updated>2019-08-13T13:15:46.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>8月10号是计算机设计大赛决赛答辩的最后一天，这天下午是牛客多校8，晚上是银联挑战赛复赛，队友出去吃吃喝喝了，我点个外卖，打着比赛，然后第一题就卡住不会做，然后自闭了，果然银联的比赛很重视数学题啊啊啊，是我数学题没怎么练，太菜了—-&gt;所以菜导致既没有吃到好东西，又导致爆零没太多收获，所以还是需要多多努力</p><h1 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h1><h2 id="爱喝「肥宅快乐水」的班长"><a href="#爱喝「肥宅快乐水」的班长" class="headerlink" title="爱喝「肥宅快乐水」的班长"></a>爱喝「肥宅快乐水」的班长</h2><p><a href="https://nanti.jisuanke.com/t/40548" target="_blank" rel="noopener">爱喝「肥宅快乐水」的班长</a></p><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/%E6%AF%94%E8%B5%9B/%E7%BA%BF%E4%B8%8A/2019%E9%93%B6%E8%81%94%E6%8C%91%E6%88%98%E8%B5%9B%E5%A4%8D%E8%B5%9B/A_an.png" alt="A_an"></p><h2 id="看不懂的知识链接"><a href="#看不懂的知识链接" class="headerlink" title="看不懂的知识链接"></a>看不懂的知识链接</h2><p><a href="https://zh.wikipedia.org/wiki/%E9%9A%94%E6%9D%BF%E6%B3%95" target="_blank" rel="noopener">隔板法</a></p><p>扩展的隔板法中：</p><p>转化前的空盒 == 转化后每个盒子至少放一个</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e3</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> C[M][M];</span><br><span class="line"><span class="keyword">int</span> T,n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll &amp;a,ll v)</span></span>&#123;</span><br><span class="line">    a += v;</span><br><span class="line">    <span class="keyword">if</span>(a &gt;= mod) a-=mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            C[i][j]=C[i<span class="number">-1</span>][j<span class="number">-1</span>]+C[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(C[i][j]&gt;=mod) C[i][j]-=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    pre();</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;C[n+m<span class="number">-2</span>][m<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h1><h2 id="整数对"><a href="#整数对" class="headerlink" title="整数对"></a>整数对</h2><p><a href="https://nanti.jisuanke.com/t/40549" target="_blank" rel="noopener">整数对</a></p><h2 id="题目解法-1"><a href="#题目解法-1" class="headerlink" title="题目解法"></a>题目解法</h2><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/%E6%AF%94%E8%B5%9B/%E7%BA%BF%E4%B8%8A/2019%E9%93%B6%E8%81%94%E6%8C%91%E6%88%98%E8%B5%9B%E5%A4%8D%E8%B5%9B/B_an.png" alt="B_an"></p><h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll T,n,m,p,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        ll x = n/p;</span><br><span class="line">        <span class="keyword">for</span>(ll r = <span class="number">0</span>; r &lt; p ; r++ )&#123;</span><br><span class="line">            <span class="comment">/*求出b的种类数*/</span></span><br><span class="line">            ll bn = m/(p/__gcd(r,p));</span><br><span class="line">            <span class="comment">/*分别对应题解的1,2,3种情况,其实1,3可以合并*/</span></span><br><span class="line">            <span class="keyword">if</span>(!r) ans+=x*bn;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span>&lt;r &amp;&amp; r&lt;=n%p) ans+=(x+<span class="number">1</span>)*bn;</span><br><span class="line">            <span class="keyword">else</span> ans+=x*bn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p>人心的成见如同一座大山，我们总是口上说不能有偏见，其实真正的内心想法却不是这样的…</p><p>所以我对别人的偏见，我只能尽量克制，让自己理性对待，然后做之不止，乃成君子</p><p>对于别人对自己的偏见不要在意，而是要专注自己的目标</p><p>感觉自己生来就有一种追求挑战的血液，在小时候尤为明显，但是感觉在长久的教化过程中削弱了，所以我想要找回本真，生命不息，战斗不止，和天生的不公斗到底，做自己的英雄</p>]]></content>
    
    <summary type="html">
    
      银联挑战赛复赛A,B题,组合数学,隔板法,数学思维题,算法学习日常
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="组合数学" scheme="http://www.wolfdan.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="隔板法" scheme="http://www.wolfdan.cn/tags/%E9%9A%94%E6%9D%BF%E6%B3%95/"/>
    
      <category term="数学思维题" scheme="http://www.wolfdan.cn/tags/%E6%95%B0%E5%AD%A6%E6%80%9D%E7%BB%B4%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ARST打卡第16周[16/521]</title>
    <link href="http://www.wolfdan.cn/2019/08/11/ARST%E6%89%93%E5%8D%A1%E7%AC%AC16%E5%91%A8-16-521/"/>
    <id>http://www.wolfdan.cn/2019/08/11/ARST打卡第16周-16-521/</id>
    <published>2019-08-11T14:11:33.000Z</published>
    <updated>2019-08-13T08:01:25.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p><a href="https://github.com/wolfdan666/WolfEat3moreMeatEveryday/tree/master/2019.8/2019.8.10" target="_blank" rel="noopener">牛客多校8的签到</a></p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p><a href="https://humanparts.medium.com/being-happy-is-hard-work-bcc222913c79" target="_blank" rel="noopener">Being Happy Is Hard Work</a><br>好多生词啊，所以决定开始背单词<br><strong>Happiness, in other words, is practiced.</strong></p><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p><a href="https://oi-wiki.org/ds/seg/" target="_blank" rel="noopener">打算法比赛一定要熟练使用线段树啊，血的教训</a></p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p><a href="https://www.wolfdan.cn/2019/08/05/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-4-100/">2019杭电多校1006和1007算法日常[4/100]</a></p><p><a href="https://www.wolfdan.cn/2019/08/06/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8-5-100/">后缀数组-算法学习日常[5/100]</a></p><p><a href="https://www.wolfdan.cn/2019/08/07/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-6-100/">2019杭电多校6_1005算法日常[6/100]</a></p><p><a href="https://www.wolfdan.cn/2019/08/11/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-7-100/">2019牛客多校8_B题算法日常[7/100]</a></p><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p><strong>生活总有太多的美好无法用相机记录下来，所以那就给每一个当下投以最好的微笑吧</strong></p>]]></content>
    
    <summary type="html">
    
      ARST打卡 打算法比赛一定要熟练使用线段树啊，血的教训 2019杭电多校1006和1007算法日常[4/100] 后缀数组-算法学习日常[5/100] 2019杭电多校6_1005算法日常[6/100] 2019牛客多校8_B题算法日常[7/100]
    
    </summary>
    
      <category term="ARST" scheme="http://www.wolfdan.cn/categories/ARST/"/>
    
    
      <category term="ARST" scheme="http://www.wolfdan.cn/tags/ARST/"/>
    
  </entry>
  
  <entry>
    <title>2019牛客多校8_B题算法日常[7/100]</title>
    <link href="http://www.wolfdan.cn/2019/08/11/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-7-100/"/>
    <id>http://www.wolfdan.cn/2019/08/11/算法日常-7-100/</id>
    <published>2019-08-10T17:33:57.000Z</published>
    <updated>2019-08-12T12:11:49.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目链接以及描述"><a href="#题目链接以及描述" class="headerlink" title="题目链接以及描述"></a>题目链接以及描述</h2><p><a href="https://ac.nowcoder.com/acm/contest/888/B" target="_blank" rel="noopener">2019牛客多校8_B题</a><br><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/2019%E5%B9%B4%E5%A4%9A%E6%A0%A1/%E7%89%9B%E5%AE%A2/%E7%AC%AC%E5%85%AB%E5%9C%BA/B1.png" alt></p><h2 id="题意以及思路"><a href="#题意以及思路" class="headerlink" title="题意以及思路"></a>题意以及思路</h2><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/2019%E5%B9%B4%E5%A4%9A%E6%A0%A1/%E7%89%9B%E5%AE%A2/%E7%AC%AC%E5%85%AB%E5%9C%BA/B2.png" alt></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], c[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="comment">/*c[i]记录的是a[i]的上一个位置加1的位置*/</span></span><br><span class="line">        c[i] = b[a[i]]+<span class="number">1</span>;</span><br><span class="line">        b[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans += <span class="number">1L</span>L*(n-i+<span class="number">1</span>)*(i-c[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="每日一句叨叨"><a href="#每日一句叨叨" class="headerlink" title="每日一句叨叨"></a>每日一句叨叨</h1><p><strong>但求精进,无问西东</strong></p>]]></content>
    
    <summary type="html">
    
      2019牛客多校8_B题,思维题,算法学习日常,但求精进,无问西东
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="思维题" scheme="http://www.wolfdan.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>2019杭电多校6_1005算法日常[6/100]</title>
    <link href="http://www.wolfdan.cn/2019/08/07/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-6-100/"/>
    <id>http://www.wolfdan.cn/2019/08/07/算法日常-6-100/</id>
    <published>2019-08-07T14:04:01.000Z</published>
    <updated>2019-08-07T14:44:48.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6638" target="_blank" rel="noopener">2019杭电多校6_1005_HDU6638</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="自己"><a href="#自己" class="headerlink" title="自己"></a>自己</h3><p>一开想偏了，想着像以前0,1矩阵那种同权值点一样叠加成为矩形的最大面积来求解，这样子就能让复杂度在O(n^2)的样子</p><p>然后并非如此，这里的权值w是一个可正可负的整数…自己隐隐约约地感觉复杂度要达到O(n^2*log(n)),但是没有往下想，虽然想了也不一定会,,,emmmm,继续努力吧</p><h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><ul><li>首先将纵坐标离散化到 O(n) 的范围内，方便后续的处理。</li><li>将所有点按照横坐标排序，枚举矩形的上边界，然后往后依次加入每个点，这样就确定了矩形的上下边界。</li><li>设 v[y] 表示矩形内部纵坐标为 y 的点的权值和，则答案为 v 的最大子段和，用线段树维护带修改的最大子段和即可。</li><li>时间复杂度 O(n^2*log(n))</li></ul><h2 id="std理解版"><a href="#std理解版" class="headerlink" title="std理解版"></a>std理解版</h2><p>今天比较晚了，明天要出一趟远门，所以暂时没有手写，对不起自己啊，等回家一定要好好把这个重新写几遍<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2010</span>,M=<span class="number">4100</span>;</span><br><span class="line"><span class="keyword">int</span> Case,n,m,i,j,k,cb,b[N],pos[N];ll pre[M],suf[M],s[M],v[M],ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span><span class="keyword">int</span> x,y,z;&#125;e[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> E&amp;a,<span class="keyword">const</span> E&amp;b)</span></span>&#123;<span class="keyword">return</span> a.x&lt;b.x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*用纵坐标建的线段树，大佬对于线段树的理解以及如同我对1+1的理解一样了！*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  pre[x]=suf[x]=s[x]=v[x]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(a==b)&#123;</span><br><span class="line">    pos[a]=x;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> mid=(a+b)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  build(x&lt;&lt;<span class="number">1</span>,a,mid),build(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">  x=pos[x];</span><br><span class="line">  s[x]+=p;</span><br><span class="line">  <span class="keyword">if</span>(s[x]&gt;<span class="number">0</span>)pre[x]=suf[x]=v[x]=s[x];<span class="keyword">else</span> pre[x]=suf[x]=v[x]=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">/*上传的操作精辟,orz*/</span></span><br><span class="line">  <span class="keyword">for</span>(x&gt;&gt;=<span class="number">1</span>;x;x&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">/*根的左边的 = max(左子树之前的,左子树+右子树之前的)*/</span></span><br><span class="line">    pre[x]=max(pre[x&lt;&lt;<span class="number">1</span>],s[x&lt;&lt;<span class="number">1</span>]+pre[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">/*根的右边的 = max(右子树右边的,右子树+左子树右边的)*/</span></span><br><span class="line">    suf[x]=max(suf[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],s[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+suf[x&lt;&lt;<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">/*s是直接叠加的*/</span></span><br><span class="line">    s[x]=s[x&lt;&lt;<span class="number">1</span>]+s[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">    <span class="comment">/*区间最大值 = max(左子树最大,右子树最大,左子树后面的+左子树前面的)*/</span></span><br><span class="line">    v[x]=max(max(v[x&lt;&lt;<span class="number">1</span>],v[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]),suf[x&lt;&lt;<span class="number">1</span>]+pre[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Case);</span><br><span class="line">  <span class="keyword">while</span>(Case--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(cb=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;e[i].x,&amp;e[i].y,&amp;e[i].z);</span><br><span class="line">      b[++cb]=e[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*离散化纵坐标*/</span></span><br><span class="line">    sort(b+<span class="number">1</span>,b+cb+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(m=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=cb;i++)<span class="keyword">if</span>(i==<span class="number">1</span>||b[i]!=b[m])b[++m]=b[i];</span><br><span class="line">    <span class="comment">/*给横坐标排序*/</span></span><br><span class="line">    sort(e+<span class="number">1</span>,e+n+<span class="number">1</span>,cmp);</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*用离散化后的纵坐标覆盖掉原来的纵坐标*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)e[i].y=lower_bound(b+<span class="number">1</span>,b+m+<span class="number">1</span>,e[i].y)-b;</span><br><span class="line">    <span class="comment">/*枚举上边界，x是行号，是上边界*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(i==<span class="number">1</span>||e[i].x!=e[i<span class="number">-1</span>].x)&#123;</span><br><span class="line">      build(<span class="number">1</span>,<span class="number">1</span>,m);</span><br><span class="line">      <span class="comment">/*加入点确定好下边界，这样上下边界都确定好了*/</span></span><br><span class="line">      <span class="keyword">for</span>(j=i;j&lt;=n;j=k)&#123;</span><br><span class="line">        <span class="comment">/*又是逐步插入空树维护区间最大值的操作*/</span></span><br><span class="line">        <span class="keyword">for</span>(k=j;k&lt;=n&amp;&amp;e[j].x==e[k].x;k++)change(e[k].y,e[k].z);</span><br><span class="line">        <span class="keyword">if</span>(ans&lt;v[<span class="number">1</span>])ans=v[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p>今天是情人节，然而…没得女朋友…不过有队友和我一起大杭电多校还是很开心的啦(<del>还是有点点失落</del>)</p><h2 id="虽然"><a href="#虽然" class="headerlink" title="虽然"></a>虽然</h2><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8%E7%9A%84%E5%8F%A8%E5%8F%A8/6%E4%B8%83%E5%A4%95%E6%83%85%E4%BA%BA%E8%8A%82/1.jpg" alt></p><h2 id="但是"><a href="#但是" class="headerlink" title="但是"></a>但是</h2><p><strong>谁终将声震人间，必长久深自缄默</strong></p><p><strong>谁终将点燃闪电，必长久如云漂泊</strong></p><p><strong>全力以赴打完这一段时光的退役赛一定会是一个大学乃至人生最珍贵的记忆</strong>，所以这段时间先不要让自己被一个体内的激素控制，<strong>等时机到了，一定会更加美好！加油吧，少年！</strong></p>]]></content>
    
    <summary type="html">
    
      2019杭电多校6_1005_HDU6638,线段树,算法学习日常
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="线段树" scheme="http://www.wolfdan.cn/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>后缀数组-算法学习日常[5/100]</title>
    <link href="http://www.wolfdan.cn/2019/08/06/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8-5-100/"/>
    <id>http://www.wolfdan.cn/2019/08/06/算法学习日常-5-100/</id>
    <published>2019-08-06T15:03:01.000Z</published>
    <updated>2019-08-20T07:23:52.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="后缀数组论文分享"><a href="#后缀数组论文分享" class="headerlink" title="后缀数组论文分享"></a>后缀数组论文分享</h1><p><a href="https://github.com/wolfdan666/BlogPic/tree/master/%E7%AE%97%E6%B3%95/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">后缀数组论文分享</a></p><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p><strong>人一能之，己百之；人十能之，己千之。果能此道矣，虽愚必明，虽柔必强。</strong></p>]]></content>
    
    <summary type="html">
    
      分享一个后缀数组的论文，很全，学了一天也没学完，发现自己之前学了三天的后缀数组又忘光了
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="后缀数组" scheme="http://www.wolfdan.cn/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>2019杭电多校1006和1007算法日常[4/100]</title>
    <link href="http://www.wolfdan.cn/2019/08/05/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-4-100/"/>
    <id>http://www.wolfdan.cn/2019/08/05/算法日常-4-100/</id>
    <published>2019-08-05T03:51:19.000Z</published>
    <updated>2019-08-05T14:42:18.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><ul><li>今天是杭电多校第5场，然后1006签到本来应该10mins内写完，然后我菜鸡写了2小时(各种问题<del>不熟练</del>和<del>紧张</del>)，赛后发现有大佬用dc3(一种据说复杂度O(n)的后缀数组算法,发现自己孤陋寡闻)</li><li>1007真滴有趣…闪电蛇皮走位，然后自己想复杂了一点点…</li></ul><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+5&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019杭电多校5</a></p><h2 id="1006解法"><a href="#1006解法" class="headerlink" title="1006解法"></a>1006解法</h2><p>Ekmp，用s.substr(1)的串来做ekmp函数的原串，s做ekmp函数的匹配串，这样跑一次ekmp就行，然后累加extend</p><p><a href="https://segmentfault.com/a/1190000008663857" target="_blank" rel="noopener">ekmp学习教程·我觉得比较好的一个(我也用这个学的)</a></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="comment">// int next[1000000];</span></span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">int</span> extend[<span class="number">1000000</span>];</span><br><span class="line"><span class="built_in">string</span> S, T;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="comment">/* 求解 T 中 next[]，注释参考 GetExtend() */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="built_in">string</span> &amp; T, <span class="keyword">int</span> &amp; m, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">0</span>] = m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= p || i + next[i - a] &gt;= p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= p)</span><br><span class="line">                p = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (p &lt; m &amp;&amp; T[p] == T[p - i])</span><br><span class="line">                p++;</span><br><span class="line"></span><br><span class="line">            next[i] = p - i;</span><br><span class="line">            a = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next[i] = next[i - a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解 extend[] */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetExtend</span><span class="params">(<span class="built_in">string</span> &amp; S, <span class="keyword">int</span> &amp; n, <span class="built_in">string</span> &amp; T, <span class="keyword">int</span> &amp; m, <span class="keyword">int</span> extend[], <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">    GetNext(T, m, next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= p || i + next[i - a] &gt;= p) <span class="comment">// i &gt;= p 的作用：举个典型例子，S 和 T 无一字符相同</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= p)</span><br><span class="line">                p = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (p &lt; n &amp;&amp; p - i &lt; m &amp;&amp; S[p] == T[p - i])</span><br><span class="line">                p++;</span><br><span class="line"></span><br><span class="line">            extend[i] = p - i;</span><br><span class="line">            a = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            extend[i] = next[i - a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;S;</span><br><span class="line">        n = S.size();</span><br><span class="line">        T = S.substr(<span class="number">1</span>);</span><br><span class="line">        m = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/*可能程序以为我用了前面的函数声明中的next[],所以说我模棱两可,加个全局的命名空间就行</span></span><br><span class="line"><span class="comment">        或者换个变量名也行*/</span></span><br><span class="line">        <span class="comment">// GetExtend(T, m, S, n, extend, ::next);</span></span><br><span class="line">        GetExtend(T, m, S, n, extend, nxt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; extend[j] &lt;&lt; " \n"[j==m-1];</span></span><br><span class="line">            ans += extend[j]+j==n<span class="number">-1</span> ? extend[j] : extend[j]+<span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1007解法"><a href="#1007解法" class="headerlink" title="1007解法"></a>1007解法</h2><h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><p>a[i] = a[i-1]+a[i-3],就是对于第i项有两种情况，要么是直接往上走要么是闪电<br><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/2019%E5%B9%B4%E5%A4%9A%E6%A0%A1/%E6%9D%AD%E7%94%B5/%E7%AC%AC%E4%BA%94%E5%9C%BA/1007_an.png" alt></p><h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><p>dls说暴力打表找规律比较不用动脑子，哭了，臭大佬，好过分</p><h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a[<span class="number">1</span>] = a[<span class="number">2</span>] = a[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt; maxn; i++) a[i] = (a[i<span class="number">-1</span>]+a[i<span class="number">-3</span>])%mod;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) swap(l, r);</span><br><span class="line">        <span class="keyword">if</span>(l != <span class="number">1</span>) l++;</span><br><span class="line">        <span class="keyword">if</span>(r != n) r--;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, a[r-l+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p>因为今天一直在听dls的直播，尽管后面的题听不懂，想听听dls一般解题思路是啥(<del>其实后面听不懂就容易发呆了</del>),所以今天还没有补很多题，然后就只写了这么一点点,<del>我好弱啊</del></p><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p>人总得有个目标，才能继续勇敢而坚强地活着，大部分成年人，在三十岁左右已经没了活着的目标，为了不让自己死去，他们制造了一个孩子，有了这个小孩，他们终于找到了努力工作和继续活下去的目标。</p><p>不，不是的，那是基因的谎言…让你这个机器人帮忙传递他们的存在</p><p>但如果你知道这是谎言，并决定真的要选择它，那才是真正的选择</p><p>教育本来就是不平等的，有些人很年轻就是OI金牌了，然而有些人还在发愁下次要怎么骗外公外婆我出去玩了，其实是偷偷跑去了网吧，如饥似渴地<strong>享受</strong>那几个小时的奥比岛，赛尔号，功夫派，洛克王国，地下城与勇士，英雄联盟…(从小学到高中渐渐变化的是游戏),然而别人早就享受到了算法的美妙，并将来很大程度能因此受到更好的教育，然后享受社会上最好的资源，过上幸福的生活，虽然我不能这样定义幸福，但是不平等确实存在，想要跨越社会阶层的鸿沟，可能要花上很久很久的努力.不过，我认为，跨越社会阶层的鸿沟，才是这个和平时代个人最英雄的挑战.做你自己的英雄，不断超越自己，并同时珍爱身边的人，过好这一生…</p><p>今天说的好像有点小多，叨叨叨多了，快滚去运动洗澡睡觉，明天继续来补题</p>]]></content>
    
    <summary type="html">
    
      1006 ekmp本来应该10mins写完(发现好多大佬用dc3(一种据说复杂度O(n)的后缀数组算法,发现自己孤陋寡闻))，结果自己太菜写了两个小时，然后1007是真滴有点好玩,只是我太菜,一开始把自己玩死了 -- 以及今天叨叨好像有点多
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="ekmp" scheme="http://www.wolfdan.cn/tags/ekmp/"/>
    
  </entry>
  
  <entry>
    <title>Python写字符串模拟真香_算法日常[3/100]</title>
    <link href="http://www.wolfdan.cn/2019/08/04/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-3-100/"/>
    <id>http://www.wolfdan.cn/2019/08/04/算法日常-3-100/</id>
    <published>2019-08-04T06:14:04.000Z</published>
    <updated>2019-08-04T10:00:18.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://ac.nowcoder.com/acm/contest/886/B" target="_blank" rel="noopener">2019牛客多校第6场B题</a></p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/2019%E5%B9%B4%E5%A4%9A%E6%A0%A1/%E7%89%9B%E5%AE%A2/%E7%AC%AC%E5%85%AD%E5%9C%BA/B_ti.png" alt></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>把8段中每段都处理成为一个整数,然后找出最长的连续0,相同的长度的话就让0放前面的段(因为0的ASCII码是48,比:的58小),然后进行判断性输出(<strong>数字用%x可以实现以16进制输出</strong>)</p><p><strong>详见代码注释</strong></p><h3 id="C-版AC代码"><a href="#C-版AC代码" class="headerlink" title="C++版AC代码"></a>C++版AC代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*"%x"以16进制的形式输出,是我孤陋寡闻了*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ii=<span class="number">1</span>;ii&lt;=T;ii++)&#123;</span><br><span class="line">        <span class="keyword">int</span> f=<span class="number">0</span>,l=<span class="number">0</span>,nl=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*观察下面的代码容易知道,只有最前面为0的时候是f=1,</span></span><br><span class="line"><span class="comment">        其他地方为0,f为i-nl(减掉了0的长度即为0开始的地方)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        综上:</span></span><br><span class="line"><span class="comment">        f是最长连续0开始的位置</span></span><br><span class="line"><span class="comment">        然后l是保存维护最长连续0的长度</span></span><br><span class="line"><span class="comment">        nl是当前的最长连续0的长度*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)&#123;</span><br><span class="line">            a[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">16</span>;j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%1d"</span>,&amp;t);</span><br><span class="line">                a[i]=a[i]*<span class="number">2</span>+t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!a[i]) nl++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">/*判断现在的连续0的数目是否超过之前的连续0的数目*/</span></span><br><span class="line">                <span class="keyword">if</span>(nl&gt;=l&amp;&amp;nl&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                    f=i-nl;l=nl;</span><br><span class="line">                &#125;</span><br><span class="line">                nl=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">8</span>&amp;&amp;nl&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nl&gt;l)&#123;</span><br><span class="line">                    f=i-nl+<span class="number">1</span>;l=nl;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*末尾有0，但是末尾的连续0和最前面的连续0相同</span></span><br><span class="line"><span class="comment">                所以考虑字典序最小，由于'0'-48,':'-58</span></span><br><span class="line"><span class="comment">                所以优先让前面输出0,后面就输出':'*/</span></span><br><span class="line">                <span class="keyword">if</span>(nl==l&amp;&amp;f==<span class="number">1</span>)&#123;</span><br><span class="line">                    f=i-nl+<span class="number">1</span>;l=nl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: "</span>,ii);</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">":"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==f)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">":"</span>);</span><br><span class="line">                i+=l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">8</span>)<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%x%c"</span>,a[i],<span class="string">":\n"</span>[i==<span class="number">8</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>通过枚举每种有0的串，然后统一加到一个列表中，之后通过sort(优先长度然后优先字典序)，最后输出</p><p><strong>详见我的Python注释代码</strong></p><h3 id="Python-AC代码"><a href="#Python-AC代码" class="headerlink" title="Python_AC代码"></a>Python_AC代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">T=int(input())</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(T):</span><br><span class="line">    b=input()</span><br><span class="line">    a=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        <span class="comment"># 这个[2:]是去掉'0x'</span></span><br><span class="line">        a.append(hex(int(b[i*<span class="number">16</span>:i*<span class="number">16</span>+<span class="number">16</span>],<span class="number">2</span>))[<span class="number">2</span>:])</span><br><span class="line">    s=[]</span><br><span class="line">    s.append(<span class="string">':'</span>.join(a))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,<span class="number">8</span>):</span><br><span class="line">            <span class="comment"># 对每个i中的后缀长a[i:j+1]判断各元素是否都是等于0的</span></span><br><span class="line">            <span class="comment"># 是就直接把字符串丢进去,比C++AC版本中的记录长度简单很多</span></span><br><span class="line">            <span class="keyword">if</span> all(map(<span class="keyword">lambda</span> x:x==<span class="string">'0'</span>,a[i:j+<span class="number">1</span>])):</span><br><span class="line">                <span class="comment"># 用':'分隔的a[i]串</span></span><br><span class="line">                s.append(<span class="string">':'</span>.join(a[:i])+<span class="string">'::'</span>+<span class="string">':'</span>.join(a[j+<span class="number">1</span>:]))</span><br><span class="line">    <span class="comment"># 优先用长度排序,其实是同长度按照字典序排序</span></span><br><span class="line">    s.sort(key=<span class="keyword">lambda</span> x:(len(x),x))</span><br><span class="line">    print(<span class="string">'Case #%d:'</span>%(t+<span class="number">1</span>),s[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p> 岁月还漫长总会有人陪你骑马喝酒走四方</p>]]></content>
    
    <summary type="html">
    
      Python写字符串模拟真香_算法日常[3/100]
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="Python写算法" scheme="http://www.wolfdan.cn/tags/Python%E5%86%99%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ARST打卡第15周[15/521]</title>
    <link href="http://www.wolfdan.cn/2019/08/04/ARST%E6%89%93%E5%8D%A1%E7%AC%AC15%E5%91%A8-15-521/"/>
    <id>http://www.wolfdan.cn/2019/08/04/ARST打卡第15周-15-521/</id>
    <published>2019-08-04T03:49:12.000Z</published>
    <updated>2019-08-04T10:02:37.070Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/ARST/ARST15/beauty.jpg" alt></p><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p><a href="https://github.com/wolfdan666/WolfEat3moreMeatEveryday/tree/master/2019.7/2019.7.31" target="_blank" rel="noopener">已经下定决心要努力刷题了，所以每天都有刷</a></p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p><a href="https://medium.com/mit-technology-review/china-has-started-a-grand-experiment-in-ai-education-it-could-reshape-how-the-world-learns-c771f5980deb" target="_blank" rel="noopener">China Has Started a Grand Experiment in AI Education. It Could Reshape How the World Learns.</a></p><h2 id="语句摘选"><a href="#语句摘选" class="headerlink" title="语句摘选"></a>语句摘选</h2><ul><li>In three hours we understand students more than the three years spent by the best teachers.</li><li>Three things have fueled China’s AI education boom. The first is tax breaks and other incentives for AI ventures that improve anything from student learning to teacher training to school management. For VCs, this means such ventures are good bets. According to one estimate, China led the way in over $1 billion invested globally last year in AI education.</li><li>Second, academic competition in China is fierce. Ten million students a year take the college entrance exam, the gaokao. Your score determines whether and where you can study for a degree, and it’s seen as the biggest determinant of success for the rest of your life. <strong>Parents willingly pay for tutoring or anything else that helps their children get ahead.</strong></li><li>Finally, <strong>Chinese entrepreneurs have masses of data at their disposal to train and refine their algorithms.</strong>The population is vast, people’s views on data privacy are much more lax than in the West (especially if they can get coveted benefits like academic performance in return), and parents are big believers in the potential of technology, having seen how much it has transformed the country in just a few decades.</li><li>Squirrel’s approach may yield great results on traditional education, but it doesn’t prepare students to be flexible in a changing world, the experts I spoke to say. “There’s a difference between adaptive learning and personalized learning,” says Chris Dede, a professor at Harvard University in the Technology, Innovation, and Education Program. Squirrel is doing adaptive learning, which is about “understanding exactly what students know and don’t know.” <strong>But it pays no attention to what they want to know or how they learn best.</strong> Personalized learning takes their interests and needs into account to “<strong>orchestrate the motivation and time for each student so they are able to make progress.</strong>”</li><li>Much of Squirrel’s philosophy stems from Li’s own experiences as a child. When he was young, he didn’t have very good emotional intelligence, he says, and reading books on the subject didn’t help. So he spent half a year dividing the skill into 27 different components and trained himself on each one. He trained himself to be more observant, for example, and to be an interesting conversationalist (“I spent a lot of time finding 100 topics, so I have a lot of material to talk with others,” he says). <strong>He even trained himself to keep smiling when others criticized him. (“After that, in my life, I do not have any enemies.”)</strong> The method gave him the results he wanted — along with the firm belief that anything can be taught this way.</li><li>That’s exactly what China lacks. If you are able to speak multiple languages, you are able to talk to different people; you are able to communicate different ideas<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2></li><li>估计阅读时间是17mins，然而我抠脚的英语水平加上文章的深度和联想性让我看了整整一个小时</li><li>AI教学有很好的数据分析优势，计算机的快速处理数据能力，不分日夜地工作能力，都使得AI教学有很好的前景，只要不断地迭代分析数据的算法，一定可以让计算机拥有快速检测一个学生水平的能力，<strong>传统老师与计算机的差距在于经验的积累速度，不过对于单个知识点来说目前可能一个老师可能能给更好的帮助</strong>，所以我认为当下如果有AI算法辅助分析一个学生的水平，然后给针对的训练，再在个别的知识点上用上老师，那么可以大大降低对老师经验性的要求。因为我认为一个顶级老师和一个初级老师的区别仅在于对知识系统性的掌握以及对学生知识框架的快速认识能力上面(后者为主)，所以有了AI算法的辅助，将能降低家长花重金请名师的成本，而可以请一个初级老师+AI算法辅助的方式</li><li>感叹世界变化之快！</li><li>感觉自己如果要成为认知层的上层人士，必须和世界进行连接，和更多的大师交流，那就必须学好英语，不然看一篇这样简单的文章要花上太久的时间…所以坚持好好学English！</li></ul><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p><a href="https://oi-wiki.org/" target="_blank" rel="noopener">推荐一个OIwiki网站,内容很全面,分享给你们</a></p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p><a href="https://www.wolfdan.cn/2019/07/30/AcWing-245-%E4%BD%A0%E8%83%BD%E5%9B%9E%E7%AD%94%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%E5%90%97/">线段树入门-AcWing-245-你能回答这些问题吗</a></p><p><a href="https://www.wolfdan.cn/2019/07/30/priority-queue%E5%92%8Cmultiset%E5%BC%82%E5%90%8C%E4%BB%A5%E5%8F%8A%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%A9%BA%E6%A0%91%E6%8F%92%E5%85%A5%E7%BB%B4%E6%8A%A4%E5%88%9D%E8%A7%81/">priority-queue和multiset异同以及线段树空树插入维护初见</a></p><p><a href="https://www.wolfdan.cn/2019/07/31/8%E6%95%B0%E7%A0%81%E5%92%8C15%E6%95%B0%E7%A0%81%E7%AE%97%E6%B3%95%E7%BB%93%E8%AE%BA%E5%92%8C%E5%BB%B6%E5%B1%95/">8数码和15数码算法结论和延展</a></p><p><a href="https://www.wolfdan.cn/2019/08/02/%E5%86%99%E5%B0%81%E6%83%85%E4%B9%A6%E7%BB%99%E7%AE%97%E6%B3%951/">拓扑排序以及C++读取空行[算法学习日常1/100]</a></p><p><a href="https://www.wolfdan.cn/2019/08/03/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-2-100/">反二分题的做法-算法日常[2/100]</a></p><p><a href="https://www.wolfdan.cn/2019/08/04/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-3-100/">Python写字符串模拟真香_算法日常[3/100]</a></p>]]></content>
    
    <summary type="html">
    
      ARST打卡第15周 推荐一个OIwiki网站 线段树入门-AcWing-245-你能回答这些问题吗 priority-queue和multiset异同以及线段树空树插入维护初见 8数码和15数码算法结论和延展 拓扑排序以及C++读取空行 反二分题的做法 China Has Started a Grand Experiment in AI Education. It Could Reshape How the World Learns.
    
    </summary>
    
      <category term="ARST" scheme="http://www.wolfdan.cn/categories/ARST/"/>
    
    
      <category term="ARST" scheme="http://www.wolfdan.cn/tags/ARST/"/>
    
  </entry>
  
  <entry>
    <title>反二分题的做法-算法日常[2/100]</title>
    <link href="http://www.wolfdan.cn/2019/08/03/%E7%AE%97%E6%B3%95%E6%97%A5%E5%B8%B8-2-100/"/>
    <id>http://www.wolfdan.cn/2019/08/03/算法日常-2-100/</id>
    <published>2019-08-03T14:14:21.000Z</published>
    <updated>2019-08-03T14:59:28.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>今天是个好日子，开局多校D看起来就是个简单的<del>二分模拟</del>,马上动手写起来啊！然后一直写到了比赛结束(当然中途看了一下其他题,并且给队友提供了j题的解题思路)</p><h2 id="反二分的2019牛客多校6D题"><a href="#反二分的2019牛客多校6D题" class="headerlink" title="反二分的2019牛客多校6D题"></a>反二分的2019牛客多校6D题</h2><p><a href="https://ac.nowcoder.com/acm/contest/886/D" target="_blank" rel="noopener">题目链接</a></p><p><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/2019%E5%B9%B4%E5%A4%9A%E6%A0%A1/%E7%89%9B%E5%AE%A2/%E7%AC%AC%E5%85%AD%E5%9C%BA/D_ti.png" alt></p><h2 id="哒哒马蹄终究是错"><a href="#哒哒马蹄终究是错" class="headerlink" title="哒哒马蹄终究是错"></a>哒哒马蹄终究是错</h2><p>因为这个题目终极不是正规的二分做法！因为答案根本不满足二分算法中的答案单调性，比如如下反例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15 5</span><br><span class="line">39 39 39 39 39 60 60 60 60 60 100 100 100 100 100</span><br></pre></td></tr></table></figure></p><p>答案是199，而200不能是答案，201也不能是答案</p><p>(二分输出答案是216)(<strong>因为二分总是在较大数值的时候是满足的可能性极大的,所以二分后整体的结果偏大,其实有更小的答案漏掉了</strong>)</p><p>不过这题的美丽错误美就美在了它让人有种是二分的错误—(<strong>哒哒的马蹄，是个美丽的错误</strong>)</p><h2 id="如何AC"><a href="#如何AC" class="headerlink" title="如何AC"></a>如何AC</h2><p>不过因为数据比较弱(其实造一个完美避开二分的数据几乎是不可能在题目数据范围实现的，如果可以，那我把二分后往小的方向开得更远一下枚举，根据上面分析为了避免小概率事件还可以多搞一下向大的方向也枚举)，所以我们现在可以有两种做法</p><ol><li>先二分，然后在这个ans下继续向小的方向枚举20项</li><li>因为答案的下界和上界相差很小，可以直接枚举<br><img src="https://raw.githubusercontent.com/wolfdan666/BlogPic/master/%E7%AE%97%E6%B3%95/2019%E5%B9%B4%E5%A4%9A%E6%A0%A1/%E7%89%9B%E5%AE%A2/%E7%AC%AC%E5%85%AD%E5%9C%BA/D_an.png" alt></li></ol><h3 id="二分再向小方向走"><a href="#二分再向小方向走" class="headerlink" title="二分再向小方向走"></a>二分再向小方向走</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">因为数据弱，所以不满足单调性的时候这样这样来凑一手</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> T,n,K,v[M],sum,vis[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x*K&lt;sum || x&lt;v[n<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=v[n<span class="number">-1</span>] &amp;&amp; K&gt;=n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) vis[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">0</span>,ts=sum;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ts&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> tps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=n &amp;&amp; vis[n-i]) i++;</span><br><span class="line">        <span class="keyword">if</span>(n-i&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            tps += v[n-i];</span><br><span class="line">                <span class="comment">// cout&lt;&lt;"I get you! : "&lt;&lt;v[n-i]&lt;&lt;endl;</span></span><br><span class="line">            vis[n-i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span>(tps&lt;x)&#123;</span><br><span class="line">            <span class="keyword">int</span> tn = upper_bound(v,v+n-i,x-tps)-v;</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;=tn &amp;&amp; vis[tn-j]) j++;</span><br><span class="line">            <span class="keyword">if</span>(tn-j&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                tps += v[tn-j];</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;"I get you! : "&lt;&lt;v[tn-j]&lt;&lt;endl;</span></span><br><span class="line">                vis[tn-j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;"How much is the tps "&lt;&lt;tps&lt;&lt;endl;</span></span><br><span class="line">        ts -= tps;</span><br><span class="line">        tmp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp&gt;K) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;<span class="keyword">int</span> kase=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;K;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;v[i]; sum+=v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(v,v+n);</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">1e6</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;"l: "&lt;&lt;l&lt;&lt;" r: "&lt;&lt;r&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid)) r=mid;<span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = l;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=ans;i&gt;=ans<span class="number">-20</span>;i--) <span class="keyword">if</span>(check(i)) ans = i;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;kase++&lt;&lt;<span class="string">": "</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正规做法-从下界开始枚举"><a href="#正规做法-从下界开始枚举" class="headerlink" title="正规做法-从下界开始枚举"></a>正规做法-从下界开始枚举</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来源--杭电的一个二人小分队 jesus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1086</span>;</span><br><span class="line"><span class="keyword">int</span> v[N],vis[N];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> vv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        vis[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left=n;</span><br><span class="line">    <span class="keyword">int</span> maxx=n,no=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(num)&#123;</span><br><span class="line">        <span class="keyword">int</span> sp=vv;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=maxx;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//如果当前剩余容量比最小的更小，不能继续装，退出循环</span></span><br><span class="line">            <span class="keyword">if</span>(sp&lt;v[no])<span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//如果当前剩余容量足够，并且物品i还没有装过，则装入</span></span><br><span class="line">            <span class="keyword">if</span>(sp&gt;=v[i]&amp;&amp;!vis[i])&#123;</span><br><span class="line">                sp=sp-v[i];vis[i]=<span class="number">1</span>;left--;</span><br><span class="line">                <span class="comment">//如果无剩余，直接退出循环</span></span><br><span class="line">                <span class="keyword">if</span>(!sp)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//压缩下次寻找的范围</span></span><br><span class="line">        <span class="keyword">while</span>(vis[maxx])maxx--;</span><br><span class="line">        <span class="keyword">while</span>(vis[no])no++;</span><br><span class="line">        num--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果无剩余，则正好输出</span></span><br><span class="line">    <span class="keyword">if</span>(!left)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cases;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;cases);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ti=<span class="number">1</span>;ti&lt;=cases;ti++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;v[i]);</span><br><span class="line">            sum+=v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(v+<span class="number">1</span>,v+n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> b=sum/k;</span><br><span class="line">        <span class="keyword">if</span>(sum%k)b++;</span><br><span class="line">        <span class="keyword">int</span> maxx=max(v[n],b);</span><br><span class="line">        <span class="keyword">int</span> ans=maxx;</span><br><span class="line">        <span class="keyword">int</span> i=maxx;</span><br><span class="line">        <span class="keyword">while</span>(i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(check(i))&#123;</span><br><span class="line">                ans=i;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>,ti,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="每天一句叨叨"><a href="#每天一句叨叨" class="headerlink" title="每天一句叨叨"></a>每天一句叨叨</h1><p><strong>人生本来就是一场修行，人的基因把我们当做机器人，然后让我们为他们传递生命</strong>，所以给我们制造了很多激素，其中一些情绪激素让我们时而快乐时而悲伤，时而兴奋时而自闭，我们可能无法改变太多，唯有做的就是享受这个当机器人还能发发牢骚的快乐，并享受这一次人生的偶然，尽自己的快乐，去奋斗，去创造，因为平庸更使自己感到乏味…<strong>那就成为一个，不断进化，并快乐地享受其中的机器人吧</strong></p>]]></content>
    
    <summary type="html">
    
      2019牛客多校6D题  算法学习日常 我的头铁(~~二分~~)写法,然后check还没写好,因为想骚操作但内力不足便走火入魔了..先二分，然后在这个ans下继续向小的方向枚举20项....人的基因把我们当做机器人..那就成为一个，不断进化，并快乐地享受其中的机器人吧
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="反二分" scheme="http://www.wolfdan.cn/tags/%E5%8F%8D%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序以及C++读取空行[算法学习日常1/100]</title>
    <link href="http://www.wolfdan.cn/2019/08/02/%E5%86%99%E5%B0%81%E6%83%85%E4%B9%A6%E7%BB%99%E7%AE%97%E6%B3%951/"/>
    <id>http://www.wolfdan.cn/2019/08/02/写封情书给算法1/</id>
    <published>2019-08-02T14:22:13.000Z</published>
    <updated>2019-08-02T14:22:13.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法学习日常第一天"><a href="#算法学习日常第一天" class="headerlink" title="算法学习日常第一天"></a>算法学习日常第一天</h1><p>2019年8月2日</p><ul><li><p>今天上午，<a href="https://oi-wiki.org/intro/resources/" target="_blank" rel="noopener">重新认识算法的全貌<del>各种资源及知识点总结</del></a></p></li><li><p>并且还了解到了<a href="https://oi-wiki.org/intro/common-mistakes/" target="_blank" rel="noopener"><del>常见错误写法</del></a>，当然自己当年也写过很多错误</p></li><li><p>下午先是补牛客5的多校G题的dp—接着昨天的补都补了90mins(含对着手写第一遍)，还是太菜了</p></li><li>然后补H题，发现自己昨天写了3个小时的这个题目不是<del>字符串插入题</del>…而是一个<strong>拓扑排序</strong>题..真的自己菜得可怕..写错分类怎么可能做对，然后自己又焦虑了很久，知道2019年8月2日15:48:15才静下来认真地学习拓扑排序<ul><li>拓扑排序在紫书上学了下，就是把点对关系看成一个图里面的指向关系，即把每一个点对看做小数指向大数的有向边，如果图没有有向环的话，说明是可以的，否则是不行的</li><li>记自己头铁处理空行读入，搞了整整一个小时读取空行</li></ul></li></ul><h2 id="拓扑排序以及空行头铁见代码"><a href="#拓扑排序以及空行头铁见代码" class="headerlink" title="拓扑排序以及空行头铁见代码"></a>拓扑排序以及空行头铁见代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2019年8月2日19:25:05</span></span><br><span class="line"><span class="comment">拓扑排序bfs</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">拓扑排序算法思想</span></span><br><span class="line"><span class="comment">1、在AOV网络中选一个没有直接前驱的顶点, 并输出之;</span></span><br><span class="line"><span class="comment">2、从图中删去该顶点, 同时删去所有它发出的有向边;---&gt;(我下面的题目使用stop实现删除)</span></span><br><span class="line"><span class="comment">3、重复以上步骤, 直到</span></span><br><span class="line"><span class="comment">◆ 全部顶点均已输出，拓扑有序序列形成，拓扑排序完成；</span></span><br><span class="line"><span class="comment">◆ 或者图中还有未输出的顶点，但已跳出处理循环。这说明图中还剩下一些顶点，</span></span><br><span class="line"><span class="comment">它们都有直接前驱，再也找不到没有前驱的顶点了。这时AOV网络中必定存在有向环。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,lentmp;</span><br><span class="line"><span class="built_in">string</span> s[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="comment">/*用string本来可以不用下面的len*/</span></span><br><span class="line"><span class="keyword">int</span> len[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> it[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="built_in">string</span> ans,t;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m*(m<span class="number">-1</span>)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;t&gt;&gt;lentmp;</span><br><span class="line">        <span class="keyword">int</span> x=t[<span class="number">0</span>]-<span class="string">'a'</span>,y=t[<span class="number">1</span>]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y) swap(x,y);</span><br><span class="line">        len[x][y] = lentmp;</span><br><span class="line">        <span class="comment">// if(lentmp) cin&gt;&gt;s[x][y];</span></span><br><span class="line">        <span class="comment">/*我的头铁(~~比赛因此卡1小时去谷歌~~)写法</span></span><br><span class="line"><span class="comment">        先直接用cin.get()吃掉t和lentmp后面的回车</span></span><br><span class="line"><span class="comment">        再getline(),</span></span><br><span class="line"><span class="comment">        否则getline会吃那个回车而导致少读数据*/</span></span><br><span class="line">        <span class="built_in">cin</span>.get();</span><br><span class="line">        getline(<span class="built_in">cin</span>,s[x][y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!solve()) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*暴力检测每队关系是否和整个串中的样子是一样的</span></span><br><span class="line"><span class="comment">法二: 也可以每一对关系得到一个ans的tmp串,然后再去==判断</span></span><br><span class="line"><span class="comment">      但是效率低</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[k]==<span class="string">'a'</span>+i||ans[k]==<span class="string">'a'</span>+j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ans[k]!=s[i][j][now]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    now++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(now!=len[i][j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">/* 这里是每个大串的排序关系-通过m次的关系问询确定的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意前面巧妙地处理出了j小于k---&gt;这就是拓扑排序的思路</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1.对没有出现过的关系(即s[j][k]的那一维全为空)stop[j]和stop[k]全都赋值为1</span></span><br><span class="line"><span class="comment">        2.对于到最后了的关系(即s[j][k][]='\0')全赋空</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        因为有m*(m-1)/2 对 关系，也就是每两个都有比较，所以一定能够得出最前面的一个字符..所以就完美了！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        这里每次stop都会清零！*/</span></span><br><span class="line">        <span class="keyword">bool</span> stop[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;m;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!s[j][k][it[j][k]]) stop[j]=stop[k]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[j][k][it[j][k]]==<span class="string">'a'</span>+j) stop[k]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> stop[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> done = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!stop[j])&#123;</span><br><span class="line">                ans+=<span class="string">'a'</span>+j;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(k&lt;j) it[k][j]++;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;j) it[j][k]++;</span><br><span class="line">                &#125;</span><br><span class="line">                done = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!done) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!check()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>晚上成功补完H题和I题，发现好像没有时间补B题了，明天上午来补一下B题</li></ul><h1 id="每日一句叨叨"><a href="#每日一句叨叨" class="headerlink" title="每日一句叨叨"></a>每日一句叨叨</h1><p><strong>杜月笙知道成功需要代价</strong>，他想为自己洗白(小时候家里穷只能混黑帮)，为整个帮派洗白，但穿了大半辈子长褂(为了不露出纹身)，让自己的说书先生给自己讲了大半辈子学，也为上海的繁荣安定做了大半辈子贡献，但却最终未被认可(通过人脉被选之为一个参议长，但蒋介石让他自己退位)，<strong>但杜月笙却永远被后人被历史铭记</strong></p><p><strong>若命运不公，那就和它斗到底！</strong></p>]]></content>
    
    <summary type="html">
    
      2019牛客多校5H题 拓扑排序BFS 算法学习日常 我的头铁(~~比赛因此卡1小时去谷歌~~)写法,先直接用cin.get()吃掉t和lentmp后面的回车,再getline(),否则getline会吃那个回车而导致少读数据
    
    </summary>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="算法" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习日常" scheme="http://www.wolfdan.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
    
      <category term="拓扑排序" scheme="http://www.wolfdan.cn/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="BFS" scheme="http://www.wolfdan.cn/tags/BFS/"/>
    
      <category term="读取空行" scheme="http://www.wolfdan.cn/tags/%E8%AF%BB%E5%8F%96%E7%A9%BA%E8%A1%8C/"/>
    
  </entry>
  
</feed>
